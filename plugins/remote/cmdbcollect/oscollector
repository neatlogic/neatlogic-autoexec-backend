#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/lib";
use lib "$FindBin::Bin/../lib";

use strict;
use Getopt::Long;

#use Getopt::Long qw(GetOptionsFromArray);
use POSIX qw(uname);
use File::Basename;
use JSON qw(from_json to_json);

#use JSON;
use ProcessFinder;
use OSGather;
use ConnGather;
use CollectObjCat;

use AutoExecUtils;
use Data::Dumper;

Getopt::Long::Configure qw(gnu_getopt);
Getopt::Long::Configure("pass_through");

my $SINGLE_TIMEOUT = 300;
my $START_TIME     = time();
$ENV{TS_CMDB_AUTOCOLLECT} = $START_TIME;

sub collectTimeout {
    my $osType = ( uname() )[0];
    $osType =~ s/\s.*$//;
    if ( $osType ne 'Windows' ) {
        my @pids = `ps eww|grep TS_CMDB_AUTOCOLLECT=$START_TIME|grep -v grep|awk '{print \$1}'`;
        foreach my $pid (@pids) {
            if ( $pid ne $$ ) {
                kill($pid);
            }
        }
        sleep(3);
        my @pids = `ps eww|grep TS_CMDB_AUTOCOLLECT=$START_TIME|grep -v grep|awk '{print \$1}'`;
        foreach my $pid (@pids) {
            if ( $pid ne $$ ) {
                kill( 'KILL', $pid );
            }
        }
    }
    else {
        #TODO: 需要实现根据环境变量查找进程的powershell脚本
    }
}

sub main {
    $ENV{LANG} = 'C';
    AutoExecUtils::setEnv();
    my $osInfo;
    my $osType = ( uname() )[0];
    $osType =~ s/\s.*$//;

    $SIG{ALRM} = \&collectTimeout;

    my $isVerbose = 0;
    my $isDebug   = 0;
    my $classDef;
    my $defaultPassConf;

    GetOptions(
        'verbose=i'         => \$isVerbose,
        'debug=i'           => \$isDebug,
        'class=s'           => \$classDef,
        'defaultpassconf=s' => \$defaultPassConf
    );
    my @myOpts = @ARGV;

    if ($isDebug) {
        $ENV{OSCOLLECT_DEBUG} = 1;
    }

    # GetOptionsFromArray(
    #     \@myOpts,
    #     'verbose=i'         => \$isVerbose,
    #     'class=s'           => \$classDef,
    #     'defaultpassconf=s' => \$defaultPassConf
    # );

    #拼装账户参数
    my $accountInfo = {};
    for ( my $i = 0 ; $i < $#myOpts ; $i++ ) {
        my $item = $myOpts[$i];
        if ( substr( $item, 0, 1 ) eq '-' ) {
            $item =~ s/^--?//;
            my $optName = $item;
            my $optVal  = $myOpts[ $i + 1 ];
            $i = $i + 1;
            $accountInfo->{$optName} = $optVal;
        }
    }

    my $ignoreOsInfo = 0;
    my $collectClassMap;
    if ( defined($classDef) and $classDef ne '' ) {
        if ( $classDef ne 'OS' ) {
            $ignoreOsInfo = 1;
        }

        $collectClassMap = { OS => 1 };
        map { $collectClassMap->{$_} = 1 } ( split( /\s*,\s*/, $classDef ) );
    }

    # Example:
    #Mysql:${mysqlaccount},Postgresql:${pgaccount}
    #Mysql:root/pass1234,Postgresql:demo/test1234
    # 转换为:
    # {
    #     "Mysql":{
    #         "username":"root",
    #         "password":"mypassword"
    #     },
    #     "Postgresql":{
    #         "username":"pgroot",
    #         "password":"pgpassword"
    #     }
    # }
    my $passArgs = {};
    if ( defined($defaultPassConf) and $defaultPassConf ne '' ) {
        $defaultPassConf =~ s/#\{\s*(\w+)\s*\}/$accountInfo->{$1}/g;
        $defaultPassConf = $defaultPassConf . ',H:H/H';

        while ( $defaultPassConf =~ /(.*?),(?=\w+:\w+\/)/g ) {
            my $part = $1;
            if ( $part =~ /^(\w+):(\w+)\/(.*)$/ ) {
                my $account = {};
                $account->{username} = $2;
                $account->{password} = $3;
                $passArgs->{$1}      = $account;
            }
        }
    }

    #收集OS和硬件信息
    my ( $hostInfo, $osInfo, $ipAddrs, $ipv6Addrs );
    if ( not defined($collectClassMap) or defined( $collectClassMap->{OS} ) ) {
        print("INFO: Begin to collect OS information...\n");
        my $osGather = OSGather->new();
        ( $hostInfo, $osInfo ) = $osGather->collect();
        if ( defined($hostInfo) ) {
            $hostInfo->{_OBJ_CATEGORY} = CollectObjCat->get('HOST');
            $osInfo->{_OBJ_TYPE}       = 'HOST';
            $hostInfo->{OS_ID}         = $osGather->{osId};
            $hostInfo->{MGMT_IP}       = $osGather->{mgmtIp};
            $hostInfo->{MGMT_PORT}     = $osGather->{mgmtPort};
            $hostInfo->{PK}            = ['BOARD_SERIAL'];
            $osInfo->{INDEX_FIELDS}    = ['OS_ID'];
        }

        if ( defined($osInfo) ) {
            $osInfo->{_OBJ_CATEGORY} = CollectObjCat->get('OS');
            $osInfo->{_OBJ_TYPE}     = $osType;
            $osInfo->{OS_TYPE}       = $osType;
            $osInfo->{OS_ID}         = $osGather->{osId};
            $osInfo->{MGMT_IP}       = $osGather->{mgmtIp};
            $osInfo->{MGMT_PORT}     = $osGather->{mgmtPort};
            $osInfo->{PK}            = ['MGMT_IP'];
            $osInfo->{INDEX_FIELDS}  = ['OS_ID'];

            if ( defined($hostInfo) and defined( $hostInfo->{BOARD_SERIAL} ) ) {
                $osInfo->{HOST_ON} = [
                    {
                        '_OBJ_CATEGORY' => 'HOST',
                        '_OBJ_TYPE'     => 'HOST',
                        'BOARD_SERIAL'  => $hostInfo->{BOARD_SERIAL}
                    }
                ];
            }
            else {
                $osInfo->{HOST_ON} = [];
            }
        }

        $ipAddrs   = $osInfo->{IP_ADDRS};
        $ipv6Addrs = $osInfo->{IPV6_ADDRS};
        print("INFO: OS information collected.\n");
    }

    my $appsMap = {};

    #获取收集网络信息的实现类
    my $connGather = ConnGather->new();

    #加载各个Collector，调用getConfig方法获取Process的filter配置
    my @procFilters;
    for my $collectorPmPath ( glob("$FindBin::Bin/*Collector.pm") ) {
        my $collectorName = basename($collectorPmPath);
        if ( $collectorName eq 'DemoCollector.pm' or $collectorName eq 'BaseCollector.pm' ) {
            next;
        }

        my $collectClass = substr( $collectorName, 0, -3 );
        my $objType      = substr( $collectorName, 0, -12 );

        if ( defined($collectClassMap) and not defined( $collectClassMap->{$objType} ) ) {
            next;
        }

        eval {
            require($collectorName);
            my $filter = $collectClass->getConfig();
            if ( defined( $filter->{regExps} ) ) {
                if ( not defined( $filter->{seq} ) ) {
                    $filter->{seq} = 100;
                }
                $filter->{objType}   = $objType;
                $filter->{className} = $collectClass;
                push( @procFilters, $filter );
            }
        };
        if ($@) {
            print("WARN: $@\n");
        }
    }

    #使用filter的seq值进行排序，控制先后匹配的次序，用于standalone应用的匹配
    @procFilters = sort { $a->{seq} <=> $b->{seq} } @procFilters;

    #提供给ProcessFinder调用的回调函数，当进程信息匹配配置的过滤配置时就会调用此函数
    #此回调函数会初始化Collector类并调用其collect方法
    my $cb = sub {
        my ( $collectorClass, $procInfo, $matchedProcsInfo ) = @_;

        #collectorClass: 收集器类名
        #procInfo；ps的进程信息
        #matchedProcsInfo：前面已经匹配上进程信息，用于多进程应用的连接去重

        my $isMatched = 0;
        my $objCat;
        my $pid     = $procInfo->{PID};
        my $objType = $procInfo->{_OBJ_TYPE};
        print("INFO: Process $pid matched filter:$objType, begin to collect data...\n");
        my $connInfo;
        if ( $osType eq 'Windows' and $procInfo->{COMMAND} =~ /^System\b/ ) {
            $connInfo = { PEER => {}, LISTEN => {} };
        }
        else {
            $connInfo = $connGather->getConnInfo($pid);
            $procInfo->{CONN_INFO} = $connInfo;
        }
        print("INFO: Process connection infomation collected.\n");

        my $collector;
        my @appInfos;
        my $pkConfig;

        alarm($SINGLE_TIMEOUT);
        eval {
            $collector = $collectorClass->new( $passArgs, $procInfo, $matchedProcsInfo );
            @appInfos  = $collector->collect($procInfo);
            $pkConfig  = $collector->getPK();
        };
        alarm(0);

        if ($@) {
            print("ERROR: $collectorClass return failed, $@\n");
            return 0;
        }

        my $idx = 0;
        for ( $idx = 0 ; $idx < scalar(@appInfos) ; $idx++ ) {
            my $appInfo = $appInfos[$idx];
            $isMatched = 1;

            $objCat = $appInfo->{_OBJ_CATEGORY};
            if ( not defined($objCat) ) {
                $objCat = CollectObjCat->get('INS');
                $appInfo->{_OBJ_CATEGORY} = $objCat;
            }
            else {
                if ( not CollectObjCat->validate( $appInfo->{_OBJ_CATEGORY} ) ) {
                    return 0;
                }
            }

            $objType = $appInfo->{_OBJ_TYPE};
            if ( not defined($objType) ) {
                $objType = $procInfo->{_OBJ_TYPE};
                $appInfo->{_OBJ_TYPE} = $objType;
            }
            print("INFO: Matched Object Type:$objCat/$objType.\n");

            $appInfo->{PROC_INFO} = $procInfo;
            if ( $idx == 0 ) {
                $appsMap->{ $procInfo->{PID} } = $appInfo;
            }
            else {
                $appsMap->{ $procInfo->{PID} . '-' . $idx } = $appInfo;
            }

            $appInfo->{OS_ID}       = $procInfo->{OS_ID};
            $appInfo->{OS_USER}     = $procInfo->{USER};
            $appInfo->{COMMAND}     = $procInfo->{COMMAND};
            $appInfo->{MGMT_IP}     = $procInfo->{MGMT_IP};
            $appInfo->{MGMT_PORT}   = $procInfo->{MGMT_PORT};
            $appInfo->{CPU_PERCENT} = $procInfo->{'%CPU'};

            if ( $osType eq 'Windows' ) {
                $appInfo->{MEM_USED}    = $procInfo->{MEMSIZE} + 0.0;
                $appInfo->{MEM_PERCENT} = int( $appInfo->{MEM_SIZE} * 10000 / $osInfo->{MEM_TOTAL} ) / 100;
            }
            else {
                $appInfo->{MEM_USED} = int( ( $procInfo->{'%MEM'} + 0.0 ) * $osInfo->{MEM_TOTAL} ) / 100;
                $appInfo->{MEM_PERCENT} = $procInfo->{'%MEM'} + 0.0;
            }

            my $envMap      = $procInfo->{ENVIRONMENT};
            my $insNamePath = $envMap->{TS_INSNAME};
            if ( defined($insNamePath) and $insNamePath ne '' ) {
                my @insPaths = split( '/', $insNamePath );
                if ( scalar(@insPaths) > 1 ) {
                    $appInfo->{BELONG_APPLICATION} = {
                        APP_NAME       => $insPaths[0],
                        APPMODULE_NAME => $insPaths[1],
                    };
                }
                else {
                    $appInfo->{BELONG_APPLICATION} = {};
                }
            }

            if ( defined($pkConfig) and defined( $pkConfig->{$objType} ) ) {
                $appInfo->{PK} = $pkConfig->{$objType};
            }
            else {
                $appInfo->{PK} = [ 'MGMT_IP', 'PORT' ];
                print("ERROR: $objType PK not defined in the collector class:$collectorClass.\n");
            }
            $appInfo->{RUN_ON} = [
                {
                    '_OBJ_CATEGORY' => 'OS',
                    '_OBJ_TYPE'     => $osType,
                    'OS_ID'         => $procInfo->{OS_ID},
                    'MGMT_IP'       => $procInfo->{MGMT_IP}
                }
            ];
        }

        return $isMatched;
    };

    my $pFinder = ProcessFinder->new( \@procFilters, callback => $cb );
    $pFinder->findProcess();

    #处理存在父子关系的进程的连接信息，并合并到父进程
    my $pidToDel = ();
    my @apps     = ();
    print("INFO: Begin to merge connection information with parent processes...\n");
    foreach my $pid ( keys(%$appsMap) ) {
        my $info     = $appsMap->{$pid};
        my $procInfo = $info->{PROC_INFO};

        my $currentInfo = $procInfo;
        my $parentInfo  = $appsMap->{ $currentInfo->{PPID} };

        my $parentTopInfo;
        while ( defined($parentInfo) ) {
            $parentTopInfo             = $parentInfo;
            $parentInfo->{CPU_PERCENT} = $parentInfo->{CPU_PERCENT} + $currentInfo->{CPU_PERCENT};
            $parentInfo->{MEM_PERCENT} = $parentInfo->{MEM_PERCENT} + $currentInfo->{MEM_PERCENT};
            $parentInfo->{MEM_USED}    = $parentInfo->{MEM_USED} + $currentInfo->{MEM_USED};

            $currentInfo = $parentInfo;
            $parentInfo  = $appsMap->{ $currentInfo->{PROC_INFO}->{PPID} };
        }

        if ( defined($parentTopInfo) ) {
            my $parentProc = $parentTopInfo->{PROC_INFO};

            my $parentLsnInfo = $parentProc->{CONN_INFO}->{LISTEN};
            map { $parentLsnInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{LISTEN} } );

            my $parentPeerInfo = $parentProc->{CONN_INFO}->{PEER};
            map { $parentPeerInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{PEER} } );

            $pidToDel->{$pid} = 1;
        }
    }
    print("INFO: Connection information merged.\n");

    #抽取所有的top层的进程，并对CONN_INFO信息进行整理，转换为数组的格式
    while ( my ( $pid, $appInfo ) = each(%$appsMap) ) {
        if ( not defined( $pidToDel->{$pid} ) ) {
            my $connInfo = $appInfo->{PROC_INFO}->{CONN_INFO};
            my @lsnPorts = keys( %{ $connInfo->{LISTEN} } );
            $connInfo->{LISTEN} = \@lsnPorts;

            my $portsMap    = {};
            my @portNumbers = ();
            my @bindAddrs   = ();
            foreach my $lsnPort (@lsnPorts) {
                if ( $lsnPort !~ /:\d+$/ ) {
                    $portsMap->{ int($lsnPort) } = 1;
                    foreach my $ipInfo (@$ipAddrs) {
                        push( @bindAddrs, "$ipInfo->{VALUE}:$lsnPort" );
                    }
                    foreach my $ipInfo (@$ipv6Addrs) {
                        push( @bindAddrs, "$ipInfo->{VALUE}:$lsnPort" );
                    }
                }
                else {
                    push( @bindAddrs, $lsnPort );
                    my $myPort = $lsnPort;
                    $myPort =~ s/^.*://;
                    $portsMap->{ int($myPort) } = 1;
                }
                @portNumbers = keys(%$portsMap);
            }
            $connInfo->{BIND} = \@bindAddrs;

            my @remoteAddrs = keys( %{ $connInfo->{PEER} } );
            $connInfo->{PEER} = \@remoteAddrs;
            delete( $appInfo->{PROC_INFO}->{CONN_INFO} );
            $appInfo->{CONN_INFO} = $connInfo;
            if ( not defined( $appInfo->{PORTS} ) ) {
                $appInfo->{PORTS} = \@portNumbers;
            }
            push( @apps, $appInfo );
        }
    }

    print("INFO: Begin to save collected data.\n");

    my @data = ();
    if ( $ignoreOsInfo == 0 ) {
        if ( defined($hostInfo) ) {
            push( @data, $hostInfo );
        }
        if ( defined($osInfo) ) {
            push( @data, $osInfo );
        }
    }
    push( @data, @apps );

    my $out = {};
    $out->{DATA} = \@data;
    AutoExecUtils::saveOutput($out);
    print("INFO: All is completed.\n");

    if ( $isVerbose == 1 ) {
        print("==================\n");
        print( to_json( $out->{DATA}, { pretty => 1 } ) );
        print("==================\n");
    }
}

main();
