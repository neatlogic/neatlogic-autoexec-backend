#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/lib";
use lib "$FindBin::Bin/../lib";

use strict;
use POSIX qw(uname);
use File::Basename;

#use JSON;
use ProcessFinder;
use OSGather;
use ConnGather;
use CollectObjType;

use Utils;
use Data::Dumper;

sub main {
    my $osInfo;

    #收集OS和硬件信息
    print("INFO: Begin to collect OS information...\n");
    my $osGather = OSGather->new();
    my ( $hostInfo, $osInfo ) = $osGather->collect();
    if ( defined($osInfo) ) {
        $osInfo->{OBJECT_TYPE} = $CollectObjType::OS;
        $osInfo->{OS_TYPE}     = ( uname() )[0];
        $osInfo->{OS_ID}       = $osGather->{osId};
        $osInfo->{MGMT_IP}     = $osGather->{mgmtIp};
        $osInfo->{MGMT_PORT}   = $osGather->{mgmtPort};
        $osInfo->{PK}          = ['MGMT_IP'];
    }
    if ( defined($hostInfo) ) {
        $hostInfo->{OBJECT_TYPE} = $CollectObjType::HOST;
        $hostInfo->{OS_ID}       = $osGather->{osId};
        $hostInfo->{MGMT_IP}     = $osGather->{mgmtIp};
        $hostInfo->{MGMT_PORT}   = $osGather->{mgmtPort};
        $hostInfo->{PK}          = ['MGMT_IP'];
    }

    print("INFO: OS information collected.\n");

    my $appsMap = {};

    #获取收集网络信息的实现类
    my $connGather = ConnGather->new();

    #加载各个Collector，调用getConfig方法获取Process的filter配置
    my @procFilters;
    for my $collectorPmPath ( glob("$FindBin::Bin/*Collector.pm") ) {
        my $collectorName = basename($collectorPmPath);
        if ( $collectorName eq 'DemoCollector.pm' or $collectorName eq 'BaseCollector.pm' ) {
            next;
        }

        my $collectClass = substr( $collectorName, 0, -3 );
        my $appType      = substr( $collectorName, 0, -12 );

        eval {
            require($collectorName);
            my $filter = $collectClass->getConfig();
            if ( defined( $filter->{regExps} ) ) {
                if ( not defined( $filter->{seq} ) ) {
                    $filter->{seq} = 100;
                }
                $filter->{appType}   = $appType;
                $filter->{className} = $collectClass;
                push( @procFilters, $filter );
            }
        };
        if ($@) {
            print("WARN: $@\n");
        }
    }

    #使用filter的seq值进行排序，控制先后匹配的次序，用于standalone应用的匹配
    @procFilters = sort { $a->{seq} <=> $b->{seq} } @procFilters;

    #提供给ProcessFinder调用的回调函数，当进程信息匹配配置的过滤配置时就会调用此函数
    #此回调函数会初始化Collector类并调用其collect方法
    my $cb = sub {
        my ( $collectorClass, $procInfo, $matchedProcsInfo ) = @_;

        #collectorClass: 收集器类名
        #procInfo；ps的进程信息
        #matchedProcsInfo：前面已经匹配上进程信息，用于多进程应用的连接去重

        my $isMatched = 0;
        my $pid       = $procInfo->{PID};
        my $appType   = $procInfo->{APP_TYPE};
        print("INFO: Process $pid matched filter:$appType, begin to collect data...\n");
        my $connInfo = $connGather->getConnInfo($pid);
        $procInfo->{CONN_INFO} = $connInfo;
        print("INFO: Process connection infomation collected.\n");

        my $collector = $collectorClass->new( $procInfo, $matchedProcsInfo );
        my @appInfos  = $collector->collect($procInfo);
        my $pkConfig  = $collector->getPK();

        my $idx = 0;
        for ( $idx = 0 ; $idx < scalar(@appInfos) ; $idx++ ) {
            my $appInfo = $appInfos[$idx];
            $isMatched = 1;
            if ( not defined( $appInfo->{OBJECT_TYPE} ) ) {
                $appInfo->{OBJECT_TYPE} = $CollectObjType::APP;
                print("WARN: $collectorClass did not return OBJECT_TYPE, fallback to $CollectObjType::APP.\n");
            }
            $appType = $appInfo->{APP_TYPE};
            if ( not defined($appType) ) {
                $appType = $procInfo->{APP_TYPE};
                $appInfo->{APP_TYPE} = $appType;
                print("WARN: $collectorClass did not return APP_TYPE, fallback to $appType.\n");
            }
            print("INFO: Matched appType:$appType.\n");

            $appInfo->{PROC_INFO} = $procInfo;
            if ( $idx == 0 ) {
                $appsMap->{ $procInfo->{PID} } = $appInfo;
            }
            else {
                $appsMap->{ $procInfo->{PID} . '-' . $idx } = $appInfo;
            }

            $appInfo->{OS_ID}     = $procInfo->{OS_ID};
            $appInfo->{MGMT_IP}   = $procInfo->{MGMT_IP};
            $appInfo->{MGMT_PORT} = $procInfo->{MGMT_PORT};
            if ( defined($pkConfig) and defined( $pkConfig->{$appType} ) ) {
                $appInfo->{PK} = $pkConfig->{$appType};
            }
            else {
                print("ERROR: $appType PK not defined in the collector class:$collectorClass.\n");
            }
        }

        return $isMatched;
    };

    my $pFinder = ProcessFinder->new( \@procFilters, callback => $cb );
    $pFinder->findProcess();

    #处理存在父子关系的进程的连接信息，并合并到父进程
    my $pidToDel = ();
    my @apps     = ();
    print("INFO: Begin to merge connection information with parent processes...\n");
    foreach my $pid ( keys(%$appsMap) ) {
        my $info     = $appsMap->{$pid};
        my $procInfo = $info->{PROC_INFO};

        my $parentInfo = $appsMap->{ $procInfo->{PPID} };

        my $parentTopInfo;
        while ( defined($parentInfo) ) {
            $parentTopInfo = $parentInfo;
            $parentInfo    = $appsMap->{ $parentInfo->{PROC_INFO}->{PPID} };
        }

        if ( defined($parentTopInfo) ) {
            my $parentProc = $parentTopInfo->{PROC_INFO};

            my $parentLsnInfo = $parentProc->{CONN_INFO}->{LISTEN};
            map { $parentLsnInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{LISTEN} } );

            my $parentPeerInfo = $parentProc->{CONN_INFO}->{PEER};
            map { $parentPeerInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{PEER} } );

            $pidToDel->{$pid} = 1;
        }
    }
    print("INFO: Connection information merged.\n");

    #抽取所有的top层的进程，并对CONN_INFO信息进行整理，转换为数组的格式
    while ( my ( $pid, $appInfo ) = each(%$appsMap) ) {
        if ( not defined( $pidToDel->{$pid} ) ) {
            my $connInfo = $appInfo->{PROC_INFO}->{CONN_INFO};
            my @lsnPorts = keys( %{ $connInfo->{LISTEN} } );
            $connInfo->{LISTEN} = \@lsnPorts;
            my @remoteAddrs = keys( %{ $connInfo->{PEER} } );
            $connInfo->{PEER} = \@remoteAddrs;
            delete( $appInfo->{PROC_INFO}->{CONN_INFO} );
            $appInfo->{CONN_INFO} = $connInfo;
            push( @apps, $appInfo );
        }
    }

    print("INFO: Begin to save collected data.\n");

    #$hostInfo, $osInfo, @apps的数据
    print Dumper ($hostInfo);
    print Dumper ($osInfo);
    print Dumper ( \@apps );

    #TODO: save $apps to output
    my @data = ( $hostInfo, $osInfo, @apps );
    my $out = {};
    $out->{DATA} = \@data;
    Utils::saveOutput($out);
    print("INFO: All is completed.\n");
}

main();
