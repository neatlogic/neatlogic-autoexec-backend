#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/lib";
use lib "$FindBin::Bin/../lib";

use strict;
use Getopt::Long;
use POSIX qw(uname);
use File::Basename;
use JSON qw(from_json to_json);

#use JSON;
use ProcessFinder;
use OSGather;
use ConnGather;
use CollectObjType;

use AutoExecUtils;
use Data::Dumper;

my $SINGLE_TIMEOUT = 300;
my $START_TIME     = time();
$ENV{TS_CMDB_AUTOCOLLECT} = $START_TIME;

sub collectTimeout {
    my $osType = ( uname() )[0];
    $osType =~ s/\s.*$//;
    if ( $osType ne 'Windows' ) {
        my @pids = `ps eww|grep TS_CMDB_AUTOCOLLECT=$START_TIME|grep -v grep|awk '{print \$1}'`;
        foreach my $pid (@pids) {
            if ( $pid ne $$ ) {
                kill($pid);
            }
        }
        sleep(3);
        my @pids = `ps eww|grep TS_CMDB_AUTOCOLLECT=$START_TIME|grep -v grep|awk '{print \$1}'`;
        foreach my $pid (@pids) {
            if ( $pid ne $$ ) {
                kill( 'KILL', $pid );
            }
        }
    }
    else {
        #TODO: 需要实现根据环境变量查找进程的powershell脚本
    }
}

sub main {
    my $osInfo;
    my $osType = ( uname() )[0];
    $osType =~ s/\s.*$//;

    $SIG{ALRM} = \&collectTimeout;

    my $isVerbose = 0;
    my $classDef;
    my $defaultPassConf;

    GetOptions(
        'verbose=i'         => \$isVerbose,
        'class=s'           => \$classDef,
        'defaultpassconf=s' => \$defaultPassConf
    );

    my $ignoreOsInfo = 0;
    my $collectClassMap;
    if ( defined($classDef) and $classDef ne '' ) {
        if ( $classDef ne 'OS' ){
            $ignoreOsInfo = 1;
        }

        $collectClassMap = { OS => 1 };
        map { $collectClassMap->{$_} = 1 } ( split( /\s*,\s*/, $classDef ) );
    }

    my $passArgs = {};

    # #Example:
    # {
    #     "Mysql":{
    #         "username":"root",
    #         "password":"mypassword"
    #     },
    #     "Postgresql":{
    #         "username":"pgroot",
    #         "password":"pgpassword"
    #     }
    # }
    if ( defined($defaultPassConf) and $defaultPassConf ne '' ) {
        eval { $passArgs = from_json($defaultPassConf); };
        if ($@) {
            print("ERROR: parse password config option defaultpassconf failed, $@\n");
        }
    }

    #收集OS和硬件信息
    my ( $hostInfo, $osInfo, $ipAddrs, $ipv6Addrs );
    if ( not defined($collectClassMap) or defined( $collectClassMap->{OS} ) ) {
        print("INFO: Begin to collect OS information...\n");
        my $osGather = OSGather->new();
        ( $hostInfo, $osInfo ) = $osGather->collect();
        if ( defined($osInfo) ) {
            $osInfo->{OBJECT_TYPE} = $CollectObjType::OS;
            $osInfo->{OS_TYPE}     = $osType;
            $osInfo->{OS_ID}       = $osGather->{osId};
            $osInfo->{MGMT_IP}     = $osGather->{mgmtIp};
            $osInfo->{MGMT_PORT}   = $osGather->{mgmtPort};
            $osInfo->{PK}          = ['MGMT_IP'];
        }
        if ( defined($hostInfo) ) {
            $hostInfo->{OBJECT_TYPE} = $CollectObjType::HOST;
            $hostInfo->{OS_ID}       = $osGather->{osId};
            $hostInfo->{MGMT_IP}     = $osGather->{mgmtIp};
            $hostInfo->{MGMT_PORT}   = $osGather->{mgmtPort};
            $hostInfo->{PK}          = ['BOARD_SERIAL'];
        }

        $ipAddrs   = $osInfo->{IP_ADDRS};
        $ipv6Addrs = $osInfo->{IPV6_ADDRS};
        print("INFO: OS information collected.\n");
    }

    my $appsMap = {};

    #获取收集网络信息的实现类
    my $connGather = ConnGather->new();

    #加载各个Collector，调用getConfig方法获取Process的filter配置
    my @procFilters;
    for my $collectorPmPath ( glob("$FindBin::Bin/*Collector.pm") ) {
        my $collectorName = basename($collectorPmPath);
        if ( $collectorName eq 'DemoCollector.pm' or $collectorName eq 'BaseCollector.pm' ) {
            next;
        }

        my $collectClass = substr( $collectorName, 0, -3 );
        my $appType      = substr( $collectorName, 0, -12 );

        if ( defined($collectClassMap) and not defined( $collectClassMap->{$appType} ) ) {
            next;
        }

        eval {
            require($collectorName);
            my $filter = $collectClass->getConfig();
            if ( defined( $filter->{regExps} ) ) {
                if ( not defined( $filter->{seq} ) ) {
                    $filter->{seq} = 100;
                }
                $filter->{appType}   = $appType;
                $filter->{className} = $collectClass;
                push( @procFilters, $filter );
            }
        };
        if ($@) {
            print("WARN: $@\n");
        }
    }

    #使用filter的seq值进行排序，控制先后匹配的次序，用于standalone应用的匹配
    @procFilters = sort { $a->{seq} <=> $b->{seq} } @procFilters;

    #提供给ProcessFinder调用的回调函数，当进程信息匹配配置的过滤配置时就会调用此函数
    #此回调函数会初始化Collector类并调用其collect方法
    my $cb = sub {
        my ( $collectorClass, $procInfo, $matchedProcsInfo ) = @_;

        #collectorClass: 收集器类名
        #procInfo；ps的进程信息
        #matchedProcsInfo：前面已经匹配上进程信息，用于多进程应用的连接去重

        my $isMatched = 0;
        my $pid       = $procInfo->{PID};
        my $appType   = $procInfo->{APP_TYPE};
        print("INFO: Process $pid matched filter:$appType, begin to collect data...\n");
        my $connInfo;
        if ( $osType eq 'Windows' and $procInfo->{COMMAND} =~ /^System\b/ ) {
            $connInfo = { PEER => {}, LISTEN => {} };
        }
        else {
            $connInfo = $connGather->getConnInfo($pid);
            $procInfo->{CONN_INFO} = $connInfo;
        }
        print("INFO: Process connection infomation collected.\n");

        my $collector;
        my @appInfos;
        my $pkConfig;

        alarm($SINGLE_TIMEOUT);
        eval {
            $collector = $collectorClass->new( $passArgs, $procInfo, $matchedProcsInfo );
            @appInfos  = $collector->collect($procInfo);
            $pkConfig  = $collector->getPK();
        };
        alarm(0);

        if ($@) {
            print("ERROR: $collectorClass return failed, $@\n");
            return 0;
        }

        my $idx = 0;
        for ( $idx = 0 ; $idx < scalar(@appInfos) ; $idx++ ) {
            my $appInfo = $appInfos[$idx];
            $isMatched = 1;
            if ( not defined( $appInfo->{OBJECT_TYPE} ) ) {
                $appInfo->{OBJECT_TYPE} = $CollectObjType::APP;
                print("WARN: $collectorClass did not return OBJECT_TYPE, fallback to $CollectObjType::APP.\n");
            }
            $appType = $appInfo->{APP_TYPE};
            if ( not defined($appType) ) {
                $appType = $procInfo->{APP_TYPE};
                $appInfo->{APP_TYPE} = $appType;
                print("INFO: $collectorClass did not return APP_TYPE, fallback to $appType.\n");
            }
            print("INFO: Matched appType:$appType.\n");

            $appInfo->{PROC_INFO} = $procInfo;
            if ( $idx == 0 ) {
                $appsMap->{ $procInfo->{PID} } = $appInfo;
            }
            else {
                $appsMap->{ $procInfo->{PID} . '-' . $idx } = $appInfo;
            }

            $appInfo->{OS_ID}           = $procInfo->{RESOURCE_ID};
            $appInfo->{OS_USER}         = $procInfo->{USER};
            $appInfo->{COMMAND}         = $procInfo->{COMMAND};
            $appInfo->{MGMT_IP}         = $procInfo->{MGMT_IP};
            $appInfo->{MGMT_PORT}       = $procInfo->{MGMT_PORT};
            if ( defined($pkConfig) and defined( $pkConfig->{$appType} ) ) {
                $appInfo->{PK} = $pkConfig->{$appType};
            }
            else {
                print("ERROR: $appType PK not defined in the collector class:$collectorClass.\n");
            }
        }

        return $isMatched;
    };

    my $pFinder = ProcessFinder->new( \@procFilters, callback => $cb );
    $pFinder->findProcess();

    #处理存在父子关系的进程的连接信息，并合并到父进程
    my $pidToDel = ();
    my @apps     = ();
    print("INFO: Begin to merge connection information with parent processes...\n");
    foreach my $pid ( keys(%$appsMap) ) {
        my $info     = $appsMap->{$pid};
        my $procInfo = $info->{PROC_INFO};

        my $parentInfo = $appsMap->{ $procInfo->{PPID} };

        my $parentTopInfo;
        while ( defined($parentInfo) ) {
            $parentTopInfo = $parentInfo;
            $parentInfo    = $appsMap->{ $parentInfo->{PROC_INFO}->{PPID} };
        }

        if ( defined($parentTopInfo) ) {
            my $parentProc = $parentTopInfo->{PROC_INFO};

            my $parentLsnInfo = $parentProc->{CONN_INFO}->{LISTEN};
            map { $parentLsnInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{LISTEN} } );

            my $parentPeerInfo = $parentProc->{CONN_INFO}->{PEER};
            map { $parentPeerInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{PEER} } );

            $pidToDel->{$pid} = 1;
        }
    }
    print("INFO: Connection information merged.\n");

    #抽取所有的top层的进程，并对CONN_INFO信息进行整理，转换为数组的格式
    while ( my ( $pid, $appInfo ) = each(%$appsMap) ) {
        if ( not defined( $pidToDel->{$pid} ) ) {
            my $connInfo = $appInfo->{PROC_INFO}->{CONN_INFO};
            my @lsnPorts = keys( %{ $connInfo->{LISTEN} } );
            $connInfo->{LISTEN} = \@lsnPorts;

            my @portNumbers = ();
            my @bindAddrs   = ();
            foreach my $lsnPort (@lsnPorts) {
                if ( $lsnPort =~ /:\d+$/ ) {
                    push( @portNumbers, int($lsnPort) );
                    foreach my $ipInfo (@$ipAddrs) {
                        push( @bindAddrs, "$ipInfo->{VALUE}:$lsnPort" );
                    }
                    foreach my $ipInfo (@$ipv6Addrs) {
                        push( @bindAddrs, "$ipInfo->{VALUE}:$lsnPort" );
                    }
                }
                else {
                    push( @bindAddrs, "$lsnPort" );
                    $lsnPort =~ s/^.*://;
                    push( @portNumbers, $lsnPort );
                }
            }
            $connInfo->{BIND} = \@bindAddrs;

            my @remoteAddrs = keys( %{ $connInfo->{PEER} } );
            $connInfo->{PEER} = \@remoteAddrs;
            delete( $appInfo->{PROC_INFO}->{CONN_INFO} );
            $appInfo->{CONN_INFO} = $connInfo;
            if ( not defined( $appInfo->{PORTS} ) ) {
                $appInfo->{PORTS} = \@portNumbers;
            }
            push( @apps, $appInfo );
        }
    }

    print("INFO: Begin to save collected data.\n");

    #$hostInfo, $osInfo, @apps的数据
    #print Dumper ($hostInfo);
    #print Dumper ($osInfo);
    #print Dumper ( \@apps );

    #TODO: save $apps to output
    my @data = ();
    if ( $ignoreOsInfo == 0 ){
        if ( defined($hostInfo) ) {
            push( @data, $hostInfo );
        }
        if ( defined($osInfo) ) {
            push( @data, $osInfo );
        }
    }
    push( @data, @apps );

    my $out = {};
    $out->{DATA} = \@data;
    AutoExecUtils::saveOutput($out);
    print("INFO: All is completed.\n");

    if ( $isVerbose == 1 ){
        my $data = $out->{DATA};
        my $jsonData = to_json($data, {pretty=>1});
    }
}

main();
