#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;

use strict;
use POSIX qw(uname);
use ProcessFinder;
use Data::Dumper;

sub main {
    my $apps = [];

    #获取收集网络信息的实现类
    my @uname       = uname();
    my $ostype      = $uname[0];
    my $gatherClass = "ConnGather$ostype";
    require "$gatherClass.pm";
    my $connGather = $gatherClass->new();

    my $cb = sub {

        #找到进程后的callback处理
        my ( $procInfo, $matchedProcsInfo ) = @_;

        my $isMatched = 0;

        my $pid      = $procInfo->{PID};
        my $connInfo = $connGather->getConnInfo($pid);
        $procInfo->{CONN_INFO} = $connInfo;

        my $appType      = $procInfo->{APP_TYPE};
        my $appTypeClass = uc($appType) . "Collector";
        require "$appTypeClass.pm";
        my $collector = $appTypeClass->new( $procInfo, $matchedProcsInfo );
        my $appInfo = $collector->collect($procInfo);

        if ( defined($appInfo) ) {
            $isMatched = 1;

            #delete( $procInfo->{ENVRIONMENT} );
            $appInfo->{PROC_INFO} = $procInfo;
            $appInfo->{APP_TYPE}  = $appType;

            push( @$apps, $appInfo );

            #Just for DEBUG
            print Dumper($appInfo);
        }

        return $isMatched;
    };

    #这里的匹配是通过命令行加上环境变量的文本进行初步筛选判断
    #最终是否是需要的进程，还需要各个Collector进行增强性的判断。
    my $filterMap = {

        #tomcat   => [ 'java', 'org.apache.catalina.startup.Bootstrap' ],
        ActiveMQ => ['\bActiveMQ\b'],
        Apache   => ['\bhttpd\s']
    };

    my $pFinder = ProcessFinder->new( $filterMap, callback => $cb );
    $pFinder->findProcess();

    #TODO: save $apps to output
}

main();
