#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../../lib";

use strict;
use File::Basename;
use POSIX qw(uname);
use JSON;
use ProcessFinder;
use ConnGather;

#use Utils;
use Data::Dumper;

sub main {
    my $appsMap = {};

    my $collectorMapper = {};

    #获取收集网络信息的实现类
    my $connGather = ConnGather->new();

    #加载各个Collector，调用getConfig方法获取Process的filter配置
    my $processFilter = {};
    for my $collectorPmPath ( glob("$FindBin::Bin/*Collector.pm") ) {
        my $collectorName = basename($collectorPmPath);
        if ( $collectorName eq 'DEMOCollector.pm' or $collectorName eq 'BASECollector.pm' ) {
            next;
        }

        my $collectClass = substr( $collectorName, 0, -3 );

        my $subFilter = {};
        eval {
            require($collectorName);
            $subFilter = $collectClass->getConfig();
        };
        if ($@) {
            print("WARN: $@\n");
        }

        while ( my ( $appType, $filterConf ) = each(%$subFilter) ) {
            $processFilter->{$appType}   = $filterConf;
            $collectorMapper->{$appType} = $collectClass;
        }
    }

    #提供给ProcessFinder调用的回调函数，当进程信息匹配配置的过滤配置时就会调用此函数
    #此回调函数会初始化Collector类并调用其collect方法
    my $cb = sub {

        #找到进程后的callback处理
        my ( $procInfo, $matchedProcsInfo ) = @_;

        my $isMatched = 0;
        my $pid       = $procInfo->{PID};

        my $appType      = $procInfo->{APP_TYPE};
        my $appTypeClass = $collectorMapper->{$appType};

        #my $appTypeClass = uc($appType) . "Collector";
        #require "$appTypeClass.pm";
        my $collector = $appTypeClass->new( $procInfo, $matchedProcsInfo );
        my $appInfo = $collector->collect($procInfo);

        if ( defined($appInfo) ) {
            $isMatched = 1;

            $appInfo->{PROC_INFO} = $procInfo;
            $appInfo->{APP_TYPE}  = $appType;

            my $connInfo = $connGather->getConnInfo($pid);
            $procInfo->{CONN_INFO} = $connInfo;

            $appsMap->{ $procInfo->{PID} } = $appInfo;
        }

        return $isMatched;
    };

    my $pFinder = ProcessFinder->new( $processFilter, callback => $cb );
    $pFinder->findProcess();

    #处理存在父子关系的进程的连接信息，并合并到父进程
    my $pidToDel = ();
    my @apps     = ();
    foreach my $pid ( keys(%$appsMap) ) {
        my $info     = $appsMap->{$pid};
        my $procInfo = $info->{PROC_INFO};

        my $parentInfo = $appsMap->{ $procInfo->{PPID} };

        my $parentTopInfo;
        while ( defined($parentInfo) ) {
            $parentTopInfo = $parentInfo;
            $parentInfo    = $appsMap->{ $parentInfo->{PROC_INFO}->{PPID} };
        }

        if ( defined($parentTopInfo) ) {
            my $parentProc = $parentTopInfo->{PROC_INFO};

            my $parentLsnInfo = $parentProc->{CONN_INFO}->{LISTEN};
            map { $parentLsnInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{LISTEN} } );

            my $parentPeerInfo = $parentProc->{CONN_INFO}->{PEER};
            map { $parentPeerInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{PEER} } );

            $pidToDel->{$pid} = 1;
        }
    }

    #抽取所有的top层的进程，并对CONN_INFO信息进行整理，转换为数组的格式
    while ( my ( $pid, $appInfo ) = each(%$appsMap) ) {
        if ( not defined( $pidToDel->{$pid} ) ) {
            my $connInfo = $appInfo->{PROC_INFO}->{CONN_INFO};
            my @lsnPorts = keys( %{ $connInfo->{LISTEN} } );
            $connInfo->{LISTEN} = \@lsnPorts;
            my @remoteAddrs = keys( %{ $connInfo->{PEER} } );
            $connInfo->{PEER} = \@remoteAddrs;
            delete( $appInfo->{PROC_INFO}->{CONN_INFO} );
            $appInfo->{CONN_INFO} = $connInfo;
            push( @apps, $appInfo );
        }
    }

    print Dumper( \@apps );

    #TODO: save $apps to output
    #$out->{DATA} = \@apps;
    #Utils::saveOutput($out);
    #print( to_json( \@apps ) );
}

main();
