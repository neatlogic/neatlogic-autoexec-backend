#!/usr/bin/perl
use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../../lib";

use strict;
use POSIX qw(uname);
use ProcessFinder;
#use Utils;
use Data::Dumper;

sub main {
    my $appsMap = {};

    #获取收集网络信息的实现类
    my @uname       = uname();
    my $ostype      = $uname[0];
    my $gatherClass = "ConnGather$ostype";
    require "$gatherClass.pm";
    my $connGather = $gatherClass->new();

    my $cb = sub {

        #找到进程后的callback处理
        my ( $procInfo, $matchedProcsInfo ) = @_;

        $procInfo->{CONN_GATHER_CLASS} = $gatherClass;

        my $isMatched = 0;
        my $pid       = $procInfo->{PID};

        my $appType      = $procInfo->{APP_TYPE};
        my $appTypeClass = uc($appType) . "Collector";
        require "$appTypeClass.pm";
        my $collector = $appTypeClass->new( $procInfo, $matchedProcsInfo );
        my $appInfo = $collector->collect($procInfo);

        if ( defined($appInfo) ) {
            $isMatched = 1;

            $appInfo->{PROC_INFO} = $procInfo;
            $appInfo->{APP_TYPE}  = $appType;

            my $connInfo = $connGather->getConnInfo($pid);
            $procInfo->{CONN_INFO} = $connInfo;

            $appsMap->{ $procInfo->{PID} } = $appInfo;
        }

        return $isMatched;
    };

    #这里的匹配是通过命令行加上环境变量的文本进行初步筛选判断
    #最终是否是需要的进程，还需要各个Collector进行增强性的判断。
    my $filterMap = {
        ActiveMQ => {
            regExps  => ['\ActiveMQ\s'],
            psAttrs  => {},
            envAttrs => {}
        },
        Tomcat => {
            regExps  => ['\borg.apache.catalina.startup.Bootstrap\s'],
            psAttrs  => { COMM => 'java' },
            envAttrs => {}
        },
        Apache => {
            regExps  => ['\bhttpd\s'],
            psAttrs  => { COMM => 'httpd' },
            envAttrs => {}
        }
    };

    my $pFinder = ProcessFinder->new( $filterMap, callback => $cb );
    $pFinder->findProcess();

    #处理存在父子关系的进程的连接信息，并合并到父进程
    my $pidToDel = ();
    my @apps     = ();
    foreach my $pid ( keys(%$appsMap) ) {
        my $info     = $appsMap->{$pid};
        my $procInfo = $info->{PROC_INFO};

        my $parentInfo = $appsMap->{ $procInfo->{PPID} };

        my $parentTopInfo;
        while ( defined($parentInfo) ) {
            $parentTopInfo = $parentInfo;
            $parentInfo    = $appsMap->{ $parentInfo->{PROC_INFO}->{PPID} };
        }

        if ( defined($parentTopInfo) ) {
            my $parentProc = $parentTopInfo->{PROC_INFO};

            my $parentLsnInfo = $parentProc->{CONN_INFO}->{LISTEN};
            map { $parentLsnInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{LISTEN} } );

            my $parentPeerInfo = $parentProc->{CONN_INFO}->{PEER};
            map { $parentPeerInfo->{$_} = 1 } keys( %{ $procInfo->{CONN_INFO}->{PEER} } );

            $pidToDel->{$pid} = 1;
        }
    }

    #抽取所有的top层的进程，并对CONN_INFO信息进行整理，转换为数组的格式
    while ( my ( $pid, $appInfo ) = each(%$appsMap) ) {
        if ( not defined( $pidToDel->{$pid} ) ) {
            my $connInfo = $appInfo->{PROC_INFO}->{CONN_INFO};
            my @lsnPorts = keys( %{ $connInfo->{LISTEN} } );
            $connInfo->{LISTEN} = \@lsnPorts;
            my @remoteAddrs = keys( %{ $connInfo->{PEER} } );
            $connInfo->{PEER} = \@remoteAddrs;
            delete($appInfo->{PROC_INFO}->{CONN_INFO});
            $appInfo->{CONN_INFO} = $connInfo;
            push( @apps, $appInfo );
        }
    }

    #TODO: save $apps to output
    #$out->{DATA} = \@apps;
    #Utils::saveOutput($out);
    print Dumper( \@apps );
}

main();
