#!/usr/bin/python
# -*- coding:UTF-8 -*-

import re
import AutoExecUtils
import os
import stat
import traceback
import datetime
import argparse
import sys
import json
import socket
import re
import requests
from http import cookiejar
import urllib
from urllib import request, parse, error
from urllib.error import URLError
from urllib.error import HTTPError
import time
import logging
import TagentClient
import select
import paramiko
from paramiko.sftp import SFTPError
from paramiko.ssh_exception import SSHException

from ping3 import ping


def usage():
    pname = os.path.basename(__file__)
    exit(1)


def pingCheck(host, timeOut):
    second = ping3.ping(dest_addr=host, timeout=timeOut)
    if second:
        print('INFO: {} is reachable, took {} second'.format(host, second))
        return (True, None)
    else:
        loopCount = 2
        while not second and loopCount > 0:
            second = ping3.ping(dest_addr=host, timeout=5)
            loopCount = loopCount - 1
        if second:
            print('INFO: {} is reachable, took {} second'.format(host, second))
            return (True, None)
        else:
            errorMsg = 'ERROR: {} is unreachable, took {} second'.format(host, second)
            print(errorMsg)
            return (False, errorMsg)


def tcpCheck(endPoint, timeOut):
    colonPos = endPoint.rindex(':')
    if colonPos < 0:
        errorMsg = "ERROR: Malform end point format: {}".format(endPoint)
        print(errorMsg)
        return (False, errorMsg)

    try:
        host = endPoint[0:colonPos]
        port = int(endPoint[colonPos+1:])
        sock = socket.socket()
        sock.settimeout(timeOut)
        sock.connect((host, port))
    except Exception as ex:
        errorMsg = "ERROR: Can not connect {}.".format(endPoint)
        print(errorMsg)
        return (False, errorMsg)

    return (True, None)


def urlCheck(endPoint, timeOut):
    url = endPoint
    userAgent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'

    # data = urllib.parse.urlencode(params)
    # url = url + '?' + data
    req = urllib.request.Request(url)
    req.add_header('User-Agent', userAgent)

    try:
        response = urllib.request.urlopen(req, timeout=timeOut)
    except HTTPError as ex:
        errMsg = ex.code
        if ex.code > 500:
            content = ex.read()
        errorMsg = "ERROR: Request failed，status code{}, {}".format(ex.code, content)
        print(errorMsg)
        return (False, errorMsg)
    except URLError as ex:
        errorMsg = "ERROR: Request url:{} failed, {}".format(url, ex.reason)
        print(errorMsg)
        return (False, errorMsg)

    return (True, None)


def execOneHttpReq(urlConf, valuesJar, timeOut):
    url = urlConf['url']
    method = urlConf['method']
    data = urlConf['data']
    proxyStr = urlConf['proxy']
    matchKey = urlConf['matchKey']
    extractContent = urlConf['extractConf']

    dataContent = json.dumps(data, ensure_ascii=False)
    for varName, varValue in matchKey.items():
        dataContent.replace('\$\{' + varName + '\}', varValue)

    cookie = cookiejar.CookieJar()
    cookieHandler = request.HTTPCookieProcessor(cookie)
    httpHandler = request.HTTPHandler()
    httpsHandler = request.HTTPSHandler()
    proxyHandler = None
    if proxyStr is not None and proxyStr != '':
        proxyInfo = proxyStr.split('://', 1)
        proxy = {proxyInfo[0]: proxyInfo[1]}
        proxyHandler = request.ProxyHandler(proxy)

    opener = request.build_opener(httpHandler, httpsHandler, cookieHandler, proxyHandler)

    req = None
    if method == 'POST-FORM':
        formData = parse.urlencode(data).encode()
        req = request.Request(url, data=formData)
        req.add_header('Content-Type', 'application/x-www-form-urlencoded; charset=utf-8')
    elif method == 'POST-JSON':
        jsonData = json.dumps(data)
        req = request.Request(url, data=jsonData)
        req.add_header('Content-Type', 'application/json; charset=utf-8')
    else:
        formData = parse.urlencode(data).encode()
        req = request.Request(url + formData)

    userAgent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
    req.add_header('User-Agent', userAgent)

    res = opener.open(req, timeout=timeOut)
    content = res.read().decode()

    ret = True
    if matchKey is not None and matchKey != '':
        matchObj = re.search(matchKey, content)
        if matchObj is None:
            ret = False
            print("ERROR: Response content not match:" + matchKey + "\n")
            print(content)

    for line in extractContent.split("\n"):
        kv = line.split('=', 1)
        keyName = kv[0].strip()
        matchObj = re.search(kv[1].strip(), content)
        if matchObj:
            valuesJar[keyName] = matchObj.group(1)

    return ret


def urlSeqCheck(urlSeq, timeOut):
    hasError = False
    for urlConf in urlSeq:
        try:
            ret = execOneHttpReq(urlConf, timeOut)
            if not ret:
                hasError = True
                break
        except Exception as ex:
            hasError = True
            print("ERROR: " + str(ex))
            break


def _remoteExecute(nodeInfo):
    self.childPid = None

    jobId = os.gentenv('AUTOEXEC_JOBID')
    resourceId = nodeInfo['resoruceId']
    host = nodeInfo['host']
    protocol = nodeInfo['protocol']
    protocolPort = nodeInfo['protocolPort']
    username = nodeInfo['username']
    password = nodeInfo['password']

    scriptName = None
    scriptContent = None
    scriptFilePath = None
    scriptCmd = None

    remoteCmd = None
    remoteCmdHidePass = None
    killCmd = None

    ret = -1
    if protocol == 'tagent':
        scriptFile = None
        try:
            jobSubDir = 'autoexec-{}-{}'.format(jobId, resourceId)
            remoteRoot = '$TMPDIR/autoexec-{}-{}'.format(jobId, resourceId)
            remotePath = remoteRoot
            runEnv = {'AUTOEXEC_JOBID': jobId, 'AUTOEXEC_NODE': json.dumps(nodeInfo), 'HISTSIZE': '0'}
            killCmd = "kill -9 `ps aux |grep '" + remoteRoot + "'|grep -v grep|awk '{print $2}'`"

            tagent = TagentClient.TagentClient(host, protocolPort, password, readTimeout=360, writeTimeout=10)
            uploadRet = tagent.execCmd(username, 'cd $TMPDIR && mkdir ' + jobSubDir, env=None, isVerbose=0)
            uploadRet = tagent.writeFile(username, scriptContent, remotePath + '/' + scriptName)

            if uploadRet == 0:
                remoteCmd = 'cd {} && {}'.format(remotePath, scriptCmd)

                def getOutputLine(line):
                    pass

                ret = tagent.execCmd(username, remoteCmd, env=runEnv, isVerbose=0, callback=getOutputLine)

                try:
                    if ret == 0:
                        if tagent.agentOsType == 'windows':
                            tagent.execCmd(username, "rd /s /q {}".format(remoteRoot), env=runEnv)
                        else:
                            tagent.execCmd(username, "rm -rf {}".format(remoteRoot), env=runEnv)
                except Exception as ex:
                    print('ERROR: Remote remove directory {} failed {}\n'.format(remoteRoot, ex))
        except Exception as ex:
            print("ERROR: Execute remote script {} failed, {}\n".format(scriptName, ex))
            raise ex

        if ret == 0:
            print("INFO: Execute remote script by agent succeed: {}\n".format(scriptCmd))
        else:
            print("ERROR: Execute remote script by agent failed: {}\n".format(scriptCmd))

    elif protocol == 'ssh':
        logging.getLogger("paramiko").setLevel(logging.FATAL)
        remoteRoot = '/tmp/autoexec-{}-{}'.format(jobId, resourceId)
        remotePath = remoteRoot
        remoteCmd = 'cd {} && HISTSIZE=0 AUTOEXEC_JOBID={} {}'.format(remotePath, jobId, scriptName)
        self.killCmd = "kill -9 `ps aux |grep '" + remoteRoot + "'|grep -v grep|awk '{print $2}'`"
        scriptFile = None
        uploaded = False
        hasError = False
        scp = None
        sftp = None
        try:
            print("INFO: Begin to upload remote script...\n")
            # 建立连接
            scp = paramiko.Transport((host, protocolPort))
            scp.connect(username=username, password=password)

            # 建立一个sftp客户端对象，通过ssh transport操作远程文件
            sftp = paramiko.SFTPClient.from_transport(scp)
            # Copy a local file (localpath) to the SFTP server as remotepath
            try:
                try:
                    sftp.stat(remoteRoot)
                except IOError:
                    sftp.mkdir(remoteRoot)
            except SFTPError as err:
                hasError = True
                print("ERROR: mkdir {} failed: {}\n".format(remoteRoot, err))

                sftp.put(scriptFilePath, os.path.join(remotePath, scriptName))
                sftp.chmod(os.path.join(remotePath, scriptName), stat.S_IXUSR)

                remoteCmd = 'cd {} && AUTOEXEC_JOBID={} AUTOEXEC_NODE=\'{}\' {}'.format(remotePath, jobId, json.dumps(nodeInfo), scriptCmd)
            if hasError == False:
                uploaded = True

        except Exception as err:
            print('ERROR: Upload script:{} to remoteRoot:{} failed: {}\n'.format(scriptName, remoteRoot, err))

        if uploaded:
            print("INFO: Upload script success, begin to execute remote operation...\n")
            ssh = None
            try:
                ret = 0
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(host, protocolPort, username, password)
                channel = ssh.get_transport().open_session()
                channel.set_combine_stderr(True)
                channel.exec_command(remoteCmd)
                while True:
                    r, w, x = select.select([channel], [], [], 10)
                    if len(r) > 0:
                        print(channel.recv(4096))
                    if channel.exit_status_ready():
                        ret = channel.recv_exit_status()
                        break

                try:
                    if ret == 0:
                        ssh.exec_command("rm -rf {}".format(remoteRoot, remoteRoot))
                except Exception as ex:
                    print("ERROR: Remove remote directory {} failed {}\n".format(remoteRoot, ex))

            except Exception as err:
                print("ERROR: Execute remote script {} failed, {}\n".format(scriptName, err))
            finally:
                if ssh:
                    ssh.close()

            if scp:
                scp.close()

        if ret == 0:
            print("INFO: Execute remote script by ssh succeed:{}\n".format(scriptCmd))
        else:
            print("ERROR: Execute remote script by ssh failed:{}\n".format(scriptCmd))

    return ret


def executeRemoteScript(nodeInfo, scriptName, timeOut):
    pass


def saveInspectData(inspectData):
    out = {'DATA': inspectData}
    AutoExecUtils.saveOutput(out)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--node', default='', help='Execution node json')
    parser.add_argument('--timeout', default=10, help='Timeout value')
    args = parser.parse_args()
    timeOut = args.timeout
    node = args.node

    try:
        nodeInfo = {}
        hasOptError = False
        if node is None:
            node = os.getenv('AUTOEXEC_NODE')
        if node is None or node == '':
            print("ERROR: Can not find node definition.\n")
            hasOptError = True
        else:
            nodeInfo = json.loads(node)

        if hasOptError:
            usage()

        hasError = False

        ip = nodeInfo['host']
        port = nodeInfo['port']
        resourceId = nodeInfo['resourceId']
        ciAttrs = AutoExecUtils.getCmdbCiAttrs(resourceId, ['access_type', 'access_endpoint', 'remote_script'])

        accessEndPoint = None
        if 'access_endpoint' in ciAttrs:
            accessEndPoint = ciAttrs['access_endpoint']
        accessType = None
        if 'access_type' in ciAttrs:
            accessType = ciAttrs['access_type']

        if accessEndPoint is None:
            if ip is not None:
                if port is not None:
                    accessEndPoint = '{}:{}'.format(ip, port)
                else:
                    accessEndPoint = ip

        if accessType is None:
            if accessEndPoint.startswith('https://'):
                accessType = 'HTTPS'
            elif accessEndPoint.startswith('http://'):
                accessType = 'HTTP'
            elif re.match(':\d+$', accessEndPoint):
                accessType = 'TCP'
            else:
                accessType = 'PING'

        errorMsg = None
        startTime = time.time()
        if accessType in ('HTTP', 'HTTPS'):
            # url check
            (ret, errorMsg) = urlCheck(accessEndPoint, timeOut)
            if not ret:
                hasError = True
        elif accessType == 'TCP':
            # ip:port tcp
            (ret, errorMsg) = tcpCheck(accessEndPoint, timeOut)
            if not ret:
                hasError = True
        elif accessType == 'BATCH':
            inspectScript = None
            if 'remote_script' in ciAttrs:
                inspectScript = ciAttrs['remote_script']

            if inspectScript is not None:
                executeRemoteScript(nodeInfo, inspectScript, timeOut)
        else:
            # ping
            (ret, errorMsg) = pingCheck(accessEndPoint, timeOut)
            if not ret:
                hasError = True

        timeConsume = time.time() - startTime
        inspectInfo = {'_OBJ_CATEGORY': 'EMPTY',
                       '_OBJ_TYPE': 'EMPTY',
                       'ACCESS_TYPE': accessType,
                       'ACCESS_ENDPOINT': accessEndPoint}
        if hasError:
            inspectInfo['_availability'] = 0
            inspectInfo['_error_message'] = errorMsg
            inspectInfo['RESPONSE_TIME'] = timeConsume
        else:
            inspectInfo['_availability'] = 1
            inspectInfo['_error_message'] = None
            inspectInfo['RESPONSE_TIME'] = timeConsume
    except Exception as ex:
        print('ERROR: Unknow Error, {}'.format(traceback.format_exc()))
        exit(-1)
