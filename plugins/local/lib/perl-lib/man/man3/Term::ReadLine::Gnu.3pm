.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Gnu 3"
.TH Gnu 3 "2019-10-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::ReadLine::Gnu \- Perl extension for the GNU Readline/History Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Term::ReadLine;   # Do not "use Term::ReadLine::Gnu;"
\&  $term = new Term::ReadLine \*(AqProgramName\*(Aq;
\&  while ( defined ($_ = $term\->readline(\*(Aqprompt>\*(Aq)) ) {
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
This is an implementation of
Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/> using
the \s-1GNU\s0 Readline/History
Library <http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html>.
.PP
For basic functions object oriented interface is provided. These are
described in the section \*(L"Standard Methods\*(R" and
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Functions".
.PP
This package also has the interface with the almost all functions and
variables which are documented in the \s-1GNU\s0 Readline/History Library
Manual.  They are documented in the section
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Functions"
and
"\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR
Variables" briefly.  For further details of the \s-1GNU\s0 Readline/History
Library, see \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html> and
\&\s-1GNU\s0 History Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/history.html>.
.PP
There are some \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR original features.  They are
described in the section "\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Specific
Features"
.PP
The sample programs under \fIeg/\fR directory and test programs under
\&\fIt/\fR directory in the \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR distribution <http://search.cpan.org/dist/Term-ReadLine-Gnu/> include
many examples of this module.
.SS "Standard Methods"
.IX Subsection "Standard Methods"
These are standard methods defined by
Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/>.
.ie n .IP """ReadLine""" 4
.el .IP "\f(CWReadLine\fR" 4
.IX Item "ReadLine"
returns the actual package that executes the commands. If
this package is being used, \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR is returned.
.ie n .IP """new(NAME,[IN,OUT])""" 4
.el .IP "\f(CWnew(NAME,[IN,OUT])\fR" 4
.IX Item "new(NAME,[IN,OUT])"
returns the handle for subsequent calls to following functions.
Argument is the name of the application.  Optionally can be followed
by two arguments for \f(CW\*(C`IN\*(C'\fR and \f(CW\*(C`OUT\*(C'\fR file handles. These arguments
should be globs.
.ie n .IP """readline(PROMPT[,PREPUT])""" 4
.el .IP "\f(CWreadline(PROMPT[,PREPUT])\fR" 4
.IX Item "readline(PROMPT[,PREPUT])"
gets an input line, with actual \f(CW\*(C`GNU Readline\*(C'\fR support.  Trailing
newline is removed.  Returns \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`EOF\*(C'\fR.  \f(CW\*(C`PREPUT\*(C'\fR is an
optional argument meaning the initial value of input.
.Sp
The optional argument \f(CW\*(C`PREPUT\*(C'\fR is granted only if the value \f(CW\*(C`preput\*(C'\fR
is in \f(CW\*(C`Features\*(C'\fR.
.Sp
\&\f(CW\*(C`PROMPT\*(C'\fR may include some escape sequences.  Use
\&\f(CW\*(C`RL_PROMPT_START_IGNORE\*(C'\fR to begin a sequence of non-printing
characters, and \f(CW\*(C`RL_PROMPT_END_IGNORE\*(C'\fR to end the sequence.
.ie n .IP """AddHistory(LINE1, LINE2, ...)""" 4
.el .IP "\f(CWAddHistory(LINE1, LINE2, ...)\fR" 4
.IX Item "AddHistory(LINE1, LINE2, ...)"
adds the lines to the history of input, from where it can be used if
the actual \f(CW\*(C`readline\*(C'\fR is present.
.ie n .IP """IN"", ""OUT""" 4
.el .IP "\f(CWIN\fR, \f(CWOUT\fR" 4
.IX Item "IN, OUT"
return the file handles for input and output or \f(CW\*(C`undef\*(C'\fR if
\&\f(CW\*(C`readline\*(C'\fR input and output cannot be used for Perl.
.ie n .IP """MinLine([MAX])""" 4
.el .IP "\f(CWMinLine([MAX])\fR" 4
.IX Item "MinLine([MAX])"
If argument \f(CW\*(C`MAX\*(C'\fR is specified, it is an advice on minimal size of
line to be included into history.  \f(CW\*(C`undef\*(C'\fR means do not include
anything into history.  Returns the old value.
.ie n .IP """findConsole""" 4
.el .IP "\f(CWfindConsole\fR" 4
.IX Item "findConsole"
returns an array with two strings that give most appropriate names for
files for input and output using conventions \f(CW"<$in"\fR, \f(CW">$out"\fR.
.ie n .IP """Attribs""" 4
.el .IP "\f(CWAttribs\fR" 4
.IX Item "Attribs"
returns a reference to a hash which describes internal configuration
(variables) of the package.  Names of keys in this hash conform to
standard conventions with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.Sp
See section "\f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR Variables" for supported variables.
.ie n .IP """Features""" 4
.el .IP "\f(CWFeatures\fR" 4
.IX Item "Features"
Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: \f(CW\*(C`appname\*(C'\fR should be present if the first argument
to \f(CW\*(C`new\*(C'\fR is recognized, and \f(CW\*(C`minline\*(C'\fR should be present if
\&\f(CW\*(C`MinLine\*(C'\fR method is not dummy.  \f(CW\*(C`autohistory\*(C'\fR should be present if
lines are put into history automatically (maybe subject to
\&\f(CW\*(C`MinLine\*(C'\fR), and \f(CW\*(C`addHistory\*(C'\fR if \f(CW\*(C`AddHistory\*(C'\fR method is not dummy. 
\&\f(CW\*(C`preput\*(C'\fR means the second argument to \f(CW\*(C`readline\*(C'\fR method is processed.
\&\f(CW\*(C`getHistory\*(C'\fR and \f(CW\*(C`setHistory\*(C'\fR denote that the corresponding methods are 
present. \f(CW\*(C`tkRunning\*(C'\fR denotes that a Tk application may run while ReadLine
is getting input.
.ie n .IP """tkRunning""" 4
.el .IP "\f(CWtkRunning\fR" 4
.IX Item "tkRunning"
makes Tk event loop run when waiting for user input (i.e., during
\&\f(CW\*(C`readline\*(C'\fR method).
.ie n .IP """event_loop""" 4
.el .IP "\f(CWevent_loop\fR" 4
.IX Item "event_loop"
See the description of \f(CW\*(C`event_loop\*(C'\fR on
Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/>.
.ie n .IP """ornaments""" 4
.el .IP "\f(CWornaments\fR" 4
.IX Item "ornaments"
makes the command line stand out by using termcap data.  The argument
to \f(CW\*(C`ornaments\*(C'\fR should be 0, 1, or a string of a form
\&\f(CW"aa,bb,cc,dd"\fR.  Four components of this string should be names of
\&\fIterminal capacities\fR, first two will be issued to make the prompt
standout, last two to make the input line standout.
.ie n .IP """newTTY""" 4
.el .IP "\f(CWnewTTY\fR" 4
.IX Item "newTTY"
takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.
.ie n .IP """enableUTF8""" 4
.el .IP "\f(CWenableUTF8\fR" 4
.IX Item "enableUTF8"
Enables \s-1UTF\-8\s0 support.
.Sp
If \s-1STDIN\s0 is in \s-1UTF\-8\s0 by the \f(CW\*(C`\-C\*(C'\fR command-line switch or
\&\f(CW\*(C`PERL_UNICODE\*(C'\fR environment variable, or \f(CW\*(C`IN\*(C'\fR file handle has \f(CW\*(C`utf8\*(C'\fR
\&\s-1IO\s0 layer, then \s-1UTF\-8\s0 support is also enabled.  In other cases you need
this \f(CW\*(C`enableUTF8\*(C'\fR method.
.Sp
This is an original method of \f(CW\*(C`Term::ReadLine:Gnu\*(C'\fR.
.ie n .SS """Term::ReadLine::Gnu"" Functions"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Functions"
.IX Subsection "Term::ReadLine::Gnu Functions"
All these \s-1GNU\s0 Readline/History Library functions supported are callable via
method interface and have names which conform to standard conventions
with the leading \f(CW\*(C`rl_\*(C'\fR stripped.  For example \f(CW\*(C`rl_foo()\*(C'\fR
function is called as \f(CW\*(C`$term\->foo()\*(C'\fR.
.PP
The titles of the following sections are same as the titles of the
corresponding sections in the \*(L"Programming with \s-1GNU\s0 Readline\*(R" section
in the \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
Refer them for further details.
.PP
Although it is preferred to use method interface, most methods have
lower level functions in
\&\f(CW\*(C`Term::ReadLine::Gnu::XS\*(C'\fR package.  To use them a full qualified name
is required.
.PP
\fIBasic Behavior\fR
.IX Subsection "Basic Behavior"
.PP
The function \f(CW\*(C`readline()\*(C'\fR prints a prompt and then reads and returns
a single line of text from the user.
.PP
.Vb 1
\&        $_ = $term\->readline(\*(AqEnter a line: \*(Aq);
.Ve
.PP
You can change key-bindings using \f(CW\*(C`bind_key(KEY, FUNCTION [,MAP])\*(C'\fR
function.  The first argument, \f(CW\*(C`KEY\*(C'\fR, is the character that you want
bind.  The second argument, \f(CW\*(C`FUNCTION\*(C'\fR, is the function to call when
\&\f(CW\*(C`KEY\*(C'\fR is pressed.  The \f(CW\*(C`FUNCTION\*(C'\fR can be a reference to a Perl
function (see \*(L"Custom Functions\*(R") or a \*(L"named function\*(R" named by
\&\f(CW\*(C`add_defun()\*(C'\fR function or commands described in the \*(L"Bindable
Readline Commands\*(R" section in the \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
.PP
.Vb 1
\&        $term\->bind_key(ord "\eci, \*(Aqtab\-insert\*(Aq);
.Ve
.PP
The above example binds Control-I to the 'tab\-insert' command.
.PP
\fICustom Functions\fR
.IX Subsection "Custom Functions"
.PP
You can write new functions using Perl.  The calling sequence for a
command foo looks like
.PP
.Vb 1
\&        sub foo ($count, $key) { ... }
.Ve
.PP
where \f(CW$count\fR is the numeric argument (or 1 if defaulted) and
\&\f(CW$key\fR is the key that invoked this function.
.PP
Here is an example;
.PP
.Vb 2
\&        sub reverse_line {              # reverse a whole line
\&            my($count, $key) = @_;      # ignored in this sample function
\&        
\&            $t\->modifying(0, $a\->{end}); # save undo information
\&            $a\->{line_buffer} = reverse $a\->{line_buffer};
\&        }
.Ve
.PP
See the \*(L"Writing a New Function\*(R" section in the \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html> for
further details.
.PP
\fIReadline Convenience Functions\fR
.IX Subsection "Readline Convenience Functions"
.PP
Naming a Function
.IX Subsection "Naming a Function"
.ie n .IP """add_defun(NAME, FUNCTION [,KEY=\-1])""" 4
.el .IP "\f(CWadd_defun(NAME, FUNCTION [,KEY=\-1])\fR" 4
.IX Item "add_defun(NAME, FUNCTION [,KEY=-1])"
Add name to a Perl function \f(CW\*(C`FUNCTION\*(C'\fR.  If optional argument \f(CW\*(C`KEY\*(C'\fR
is specified, bind it to the \f(CW\*(C`FUNCTION\*(C'\fR.  Returns reference to
\&\f(CW\*(C`FunctionPtr\*(C'\fR.
.Sp
.Vb 4
\&  Example:
\&        # name \`reverse\-line\*(Aq to a function reverse_line(),
\&        # and bind it to "\eC\-t"
\&        $term\->add_defun(\*(Aqreverse\-line\*(Aq, \e&reverse_line, ord "\ect");
.Ve
.PP
Selecting a Keymap
.IX Subsection "Selecting a Keymap"
.ie n .IP """make_bare_keymap""" 4
.el .IP "\f(CWmake_bare_keymap\fR" 4
.IX Item "make_bare_keymap"
.Vb 1
\&        Keymap  rl_make_bare_keymap()
.Ve
.ie n .IP """copy_keymap(MAP)""" 4
.el .IP "\f(CWcopy_keymap(MAP)\fR" 4
.IX Item "copy_keymap(MAP)"
.Vb 1
\&        Keymap  rl_copy_keymap(Keymap|str map)
.Ve
.ie n .IP """make_keymap""" 4
.el .IP "\f(CWmake_keymap\fR" 4
.IX Item "make_keymap"
.Vb 1
\&        Keymap  rl_make_keymap()
.Ve
.ie n .IP """discard_keymap(MAP)""" 4
.el .IP "\f(CWdiscard_keymap(MAP)\fR" 4
.IX Item "discard_keymap(MAP)"
.Vb 1
\&        Keymap  rl_discard_keymap(Keymap|str map)
.Ve
.ie n .IP """free_keymap(MAP)""" 4
.el .IP "\f(CWfree_keymap(MAP)\fR" 4
.IX Item "free_keymap(MAP)"
.Vb 1
\&        void    rl_free_keymap(Keymap|str map)
.Ve
.ie n .IP """get_keymap""" 4
.el .IP "\f(CWget_keymap\fR" 4
.IX Item "get_keymap"
.Vb 1
\&        Keymap  rl_get_keymap()
.Ve
.ie n .IP """set_keymap(MAP)""" 4
.el .IP "\f(CWset_keymap(MAP)\fR" 4
.IX Item "set_keymap(MAP)"
.Vb 1
\&        Keymap  rl_set_keymap(Keymap|str map)
.Ve
.ie n .IP """get_keymap_by_name(NAME)""" 4
.el .IP "\f(CWget_keymap_by_name(NAME)\fR" 4
.IX Item "get_keymap_by_name(NAME)"
.Vb 1
\&        Keymap  rl_get_keymap_by_name(str name)
.Ve
.ie n .IP """get_keymap_name(MAP)""" 4
.el .IP "\f(CWget_keymap_name(MAP)\fR" 4
.IX Item "get_keymap_name(MAP)"
.Vb 1
\&        str     rl_get_keymap_name(Keymap map)
.Ve
.PP
Binding Keys
.IX Subsection "Binding Keys"
.ie n .IP """bind_key(KEY, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_key(KEY, FUNCTION [,MAP])\fR" 4
.IX Item "bind_key(KEY, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_key(int key, FunctionPtr|str function,
\&                            Keymap|str map = rl_get_keymap())
.Ve
.Sp
Bind \f(CW\*(C`KEY\*(C'\fR to the \f(CW\*(C`FUNCTION\*(C'\fR.  \f(CW\*(C`FUNCTION\*(C'\fR is the name added by the
\&\f(CW\*(C`add_defun\*(C'\fR method.  If optional argument \f(CW\*(C`MAP\*(C'\fR is specified, binds
in \f(CW\*(C`MAP\*(C'\fR.  Returns non-zero in case of error.
.ie n .IP """bind_key_if_unbound(KEY, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_key_if_unbound(KEY, FUNCTION [,MAP])\fR" 4
.IX Item "bind_key_if_unbound(KEY, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_key_if_unbound(int key, FunctionPtr|str function,
\&                                       Keymap|str map = rl_get_keymap()) # GRL 5.0
.Ve
.ie n .IP """unbind_key(KEY [,MAP])""" 4
.el .IP "\f(CWunbind_key(KEY [,MAP])\fR" 4
.IX Item "unbind_key(KEY [,MAP])"
.Vb 1
\&        int     rl_unbind_key(int key, Keymap|str map = rl_get_keymap())
.Ve
.Sp
Bind \f(CW\*(C`KEY\*(C'\fR to the null function.  Returns non-zero in case of error.
.ie n .IP """unbind_function(FUNCTION [,MAP])""" 4
.el .IP "\f(CWunbind_function(FUNCTION [,MAP])\fR" 4
.IX Item "unbind_function(FUNCTION [,MAP])"
.Vb 2
\&        int     rl_unbind_function(FunctionPtr|str function,
\&                                   Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """unbind_command(COMMAND [,MAP])""" 4
.el .IP "\f(CWunbind_command(COMMAND [,MAP])\fR" 4
.IX Item "unbind_command(COMMAND [,MAP])"
.Vb 2
\&        int     rl_unbind_command(str command,
\&                                  Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """bind_keyseq(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_keyseq(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "bind_keyseq(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_keyseq(str keyseq, FunctionPtr|str function,
\&                               Keymap|str map = rl_get_keymap()) # GRL 5.0
.Ve
.ie n .IP """set_key(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWset_key(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "set_key(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_set_key(str keyseq, FunctionPtr|str function,
\&                           Keymap|str map = rl_get_keymap())    # GRL 4.2
.Ve
.ie n .IP """bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])""" 4
.el .IP "\f(CWbind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])\fR" 4
.IX Item "bind_keyseq_if_unbound(KEYSEQ, FUNCTION [,MAP])"
.Vb 2
\&        int     rl_bind_keyseq_if_unbound(str keyseq, FunctionPtr|str function,
\&                                          Keymap|str map = rl_get_keymap()) # GRL 5.0
.Ve
.ie n .IP """generic_bind(TYPE, KEYSEQ, DATA, [,MAP])""" 4
.el .IP "\f(CWgeneric_bind(TYPE, KEYSEQ, DATA, [,MAP])\fR" 4
.IX Item "generic_bind(TYPE, KEYSEQ, DATA, [,MAP])"
.Vb 3
\&        int     rl_generic_bind(int type, str keyseq,
\&                                FunctionPtr|Keymap|str data,
\&                                Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """parse_and_bind(LINE)""" 4
.el .IP "\f(CWparse_and_bind(LINE)\fR" 4
.IX Item "parse_and_bind(LINE)"
.Vb 1
\&        void    rl_parse_and_bind(str line)
.Ve
.Sp
Parse \f(CW\*(C`LINE\*(C'\fR as if it had been read from the \fI~/.inputrc\fR file and
perform any key bindings and variable assignments found.  For further
detail see \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
.ie n .IP """read_init_file([FILENAME])""" 4
.el .IP "\f(CWread_init_file([FILENAME])\fR" 4
.IX Item "read_init_file([FILENAME])"
.Vb 1
\&        int     rl_read_init_file(str filename = \*(Aq~/.inputrc\*(Aq)
.Ve
.PP
Associating Function Names and Bindings
.IX Subsection "Associating Function Names and Bindings"
.ie n .IP """named_function(NAME)""" 4
.el .IP "\f(CWnamed_function(NAME)\fR" 4
.IX Item "named_function(NAME)"
.Vb 1
\&        FunctionPtr rl_named_function(str name)
.Ve
.ie n .IP """get_function_name(FUNCTION)""" 4
.el .IP "\f(CWget_function_name(FUNCTION)\fR" 4
.IX Item "get_function_name(FUNCTION)"
.Vb 1
\&        str     rl_get_function_name(FunctionPtr function)      # TRG original
.Ve
.ie n .IP """function_of_keyseq(KEYSEQ [,MAP])""" 4
.el .IP "\f(CWfunction_of_keyseq(KEYSEQ [,MAP])\fR" 4
.IX Item "function_of_keyseq(KEYSEQ [,MAP])"
.Vb 3
\&        (FunctionPtr|Keymap|str data, int type)
\&                rl_function_of_keyseq(str keyseq,
\&                                      Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """invoking_keyseqs(FUNCTION [,MAP])""" 4
.el .IP "\f(CWinvoking_keyseqs(FUNCTION [,MAP])\fR" 4
.IX Item "invoking_keyseqs(FUNCTION [,MAP])"
.Vb 2
\&        (@str)  rl_invoking_keyseqs(FunctionPtr|str function,
\&                                    Keymap|str map = rl_get_keymap())
.Ve
.ie n .IP """function_dumper([READABLE])""" 4
.el .IP "\f(CWfunction_dumper([READABLE])\fR" 4
.IX Item "function_dumper([READABLE])"
.Vb 1
\&        void    rl_function_dumper(int readable = 0)
.Ve
.ie n .IP """list_funmap_names""" 4
.el .IP "\f(CWlist_funmap_names\fR" 4
.IX Item "list_funmap_names"
.Vb 1
\&        void    rl_list_funmap_names()
.Ve
.ie n .IP """funmap_names""" 4
.el .IP "\f(CWfunmap_names\fR" 4
.IX Item "funmap_names"
.Vb 1
\&        (@str)  rl_funmap_names()
.Ve
.ie n .IP """add_funmap_entry(NAME, FUNCTION)""" 4
.el .IP "\f(CWadd_funmap_entry(NAME, FUNCTION)\fR" 4
.IX Item "add_funmap_entry(NAME, FUNCTION)"
.Vb 1
\&        int     rl_add_funmap_entry(char *name, FunctionPtr|str function)
.Ve
.PP
Allowing Undoing
.IX Subsection "Allowing Undoing"
.ie n .IP """begin_undo_group""" 4
.el .IP "\f(CWbegin_undo_group\fR" 4
.IX Item "begin_undo_group"
.Vb 1
\&        int     rl_begin_undo_group()
.Ve
.ie n .IP """end_undo_group""" 4
.el .IP "\f(CWend_undo_group\fR" 4
.IX Item "end_undo_group"
.Vb 1
\&        int     rl_end_undo_group()
.Ve
.ie n .IP """add_undo(WHAT, START, END, TEXT)""" 4
.el .IP "\f(CWadd_undo(WHAT, START, END, TEXT)\fR" 4
.IX Item "add_undo(WHAT, START, END, TEXT)"
.Vb 1
\&        int     rl_add_undo(int what, int start, int end, str text)
.Ve
.ie n .IP """free_undo_list""" 4
.el .IP "\f(CWfree_undo_list\fR" 4
.IX Item "free_undo_list"
.Vb 1
\&        void    rl_free_undo_list()
.Ve
.ie n .IP """do_undo""" 4
.el .IP "\f(CWdo_undo\fR" 4
.IX Item "do_undo"
.Vb 1
\&        int     rl_do_undo()
.Ve
.ie n .IP """modifying([START [,END]])""" 4
.el .IP "\f(CWmodifying([START [,END]])\fR" 4
.IX Item "modifying([START [,END]])"
.Vb 1
\&        int     rl_modifying(int start = 0, int end = rl_end)
.Ve
.PP
Redisplay
.IX Subsection "Redisplay"
.ie n .IP """redisplay""" 4
.el .IP "\f(CWredisplay\fR" 4
.IX Item "redisplay"
.Vb 1
\&        void    rl_redisplay()
.Ve
.ie n .IP """forced_update_display""" 4
.el .IP "\f(CWforced_update_display\fR" 4
.IX Item "forced_update_display"
.Vb 1
\&        int     rl_forced_update_display()
.Ve
.ie n .IP """on_new_line""" 4
.el .IP "\f(CWon_new_line\fR" 4
.IX Item "on_new_line"
.Vb 1
\&        int     rl_on_new_line()
.Ve
.ie n .IP """on_new_line_with_prompt""" 4
.el .IP "\f(CWon_new_line_with_prompt\fR" 4
.IX Item "on_new_line_with_prompt"
.Vb 1
\&        int     rl_on_new_line_with_prompt()                    # GRL 4.1
.Ve
.ie n .IP """clear_visible_line()""" 4
.el .IP "\f(CWclear_visible_line()\fR" 4
.IX Item "clear_visible_line()"
.Vb 1
\&        int     rl_clear_visible_line()                         # GRL 7.0
.Ve
.ie n .IP """reset_line_state""" 4
.el .IP "\f(CWreset_line_state\fR" 4
.IX Item "reset_line_state"
.Vb 1
\&        int     rl_reset_line_state()
.Ve
.ie n .IP """crlf""" 4
.el .IP "\f(CWcrlf\fR" 4
.IX Item "crlf"
.Vb 1
\&        int     rl_crlf()
.Ve
.ie n .IP "show_char(C)" 4
.el .IP "\f(CWshow_char(C)\fR" 4
.IX Item "show_char(C)"
.Vb 1
\&        int     rl_show_char(int c)
.Ve
.ie n .IP """message(FMT[, ...])""" 4
.el .IP "\f(CWmessage(FMT[, ...])\fR" 4
.IX Item "message(FMT[, ...])"
.Vb 1
\&        int     rl_message(str fmt, ...)
.Ve
.ie n .IP """clear_message""" 4
.el .IP "\f(CWclear_message\fR" 4
.IX Item "clear_message"
.Vb 1
\&        int     rl_clear_message()
.Ve
.ie n .IP """save_prompt""" 4
.el .IP "\f(CWsave_prompt\fR" 4
.IX Item "save_prompt"
.Vb 1
\&        void    rl_save_prompt()
.Ve
.ie n .IP """restore_prompt""" 4
.el .IP "\f(CWrestore_prompt\fR" 4
.IX Item "restore_prompt"
.Vb 1
\&        void    rl_restore_prompt()
.Ve
.ie n .IP """expand_prompt(PROMPT)""" 4
.el .IP "\f(CWexpand_prompt(PROMPT)\fR" 4
.IX Item "expand_prompt(PROMPT)"
.Vb 1
\&        int     rl_expand_prompt(str prompt)
.Ve
.ie n .IP """set_prompt(PROMPT)""" 4
.el .IP "\f(CWset_prompt(PROMPT)\fR" 4
.IX Item "set_prompt(PROMPT)"
.Vb 1
\&        int     rl_set_prompt(const str prompt)                 # GRL 4.2
.Ve
.PP
Modifying Text
.IX Subsection "Modifying Text"
.ie n .IP """insert_text(TEXT)""" 4
.el .IP "\f(CWinsert_text(TEXT)\fR" 4
.IX Item "insert_text(TEXT)"
.Vb 1
\&        int     rl_insert_text(str text)
.Ve
.ie n .IP """delete_text([START [,END]])""" 4
.el .IP "\f(CWdelete_text([START [,END]])\fR" 4
.IX Item "delete_text([START [,END]])"
.Vb 1
\&        int     rl_delete_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """copy_text([START [,END]])""" 4
.el .IP "\f(CWcopy_text([START [,END]])\fR" 4
.IX Item "copy_text([START [,END]])"
.Vb 1
\&        str     rl_copy_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """kill_text([START [,END]])""" 4
.el .IP "\f(CWkill_text([START [,END]])\fR" 4
.IX Item "kill_text([START [,END]])"
.Vb 1
\&        int     rl_kill_text(int start = 0, int end = rl_end)
.Ve
.ie n .IP """push_macro_input(MACRO)""" 4
.el .IP "\f(CWpush_macro_input(MACRO)\fR" 4
.IX Item "push_macro_input(MACRO)"
.Vb 1
\&        int     rl_push_macro_input(str macro)
.Ve
.PP
Character Input
.IX Subsection "Character Input"
.ie n .IP """read_key""" 4
.el .IP "\f(CWread_key\fR" 4
.IX Item "read_key"
.Vb 1
\&        int     rl_read_key()
.Ve
.ie n .IP """getc(STREAM)""" 4
.el .IP "\f(CWgetc(STREAM)\fR" 4
.IX Item "getc(STREAM)"
.Vb 1
\&        int     rl_getc(FILE *STREAM)
.Ve
.ie n .IP "stuff_char(C)" 4
.el .IP "\f(CWstuff_char(C)\fR" 4
.IX Item "stuff_char(C)"
.Vb 1
\&        int     rl_stuff_char(int c)
.Ve
.ie n .IP "execute_next(C)" 4
.el .IP "\f(CWexecute_next(C)\fR" 4
.IX Item "execute_next(C)"
.Vb 1
\&        int     rl_execute_next(int c)
.Ve
.ie n .IP """clear_pending_input()""" 4
.el .IP "\f(CWclear_pending_input()\fR" 4
.IX Item "clear_pending_input()"
.Vb 1
\&        int     rl_clear_pending_input()                        # GRL 4.2
.Ve
.ie n .IP """set_keyboard_input_timeout(uSEC)""" 4
.el .IP "\f(CWset_keyboard_input_timeout(uSEC)\fR" 4
.IX Item "set_keyboard_input_timeout(uSEC)"
.Vb 1
\&        int     rl_set_keyboard_input_timeout(int usec)         # GRL 4.2
.Ve
.PP
Terminal Management
.IX Subsection "Terminal Management"
.ie n .IP """prep_terminal(META_FLAG)""" 4
.el .IP "\f(CWprep_terminal(META_FLAG)\fR" 4
.IX Item "prep_terminal(META_FLAG)"
.Vb 1
\&        void    rl_prep_terminal(int META_FLAG)
.Ve
.ie n .IP """deprep_terminal()""" 4
.el .IP "\f(CWdeprep_terminal()\fR" 4
.IX Item "deprep_terminal()"
.Vb 1
\&        void    rl_deprep_terminal()
.Ve
.ie n .IP """tty_set_default_bindings([MAP])""" 4
.el .IP "\f(CWtty_set_default_bindings([MAP])\fR" 4
.IX Item "tty_set_default_bindings([MAP])"
.Vb 1
\&        void    rl_tty_set_default_bindings([Keymap|str map = rl_get_keymap()]) # GRL 4.0
.Ve
.ie n .IP """tty_unset_default_bindings([MAP])""" 4
.el .IP "\f(CWtty_unset_default_bindings([MAP])\fR" 4
.IX Item "tty_unset_default_bindings([MAP])"
.Vb 1
\&        void    rl_tty_unset_default_bindings([Keymap|str map = rl_get_keymap()]) # GRL 5.0
.Ve
.ie n .IP """tty_set_echoing(VALUE)""" 4
.el .IP "\f(CWtty_set_echoing(VALUE)\fR" 4
.IX Item "tty_set_echoing(VALUE)"
.Vb 1
\&        int     rl_tty_set_echoing(int value)                   # GRL 7.0
.Ve
.ie n .IP """reset_terminal([TERMINAL_NAME])""" 4
.el .IP "\f(CWreset_terminal([TERMINAL_NAME])\fR" 4
.IX Item "reset_terminal([TERMINAL_NAME])"
.Vb 1
\&        int     rl_reset_terminal(str terminal_name = getenv($TERM))
.Ve
.PP
Utility Functions
.IX Subsection "Utility Functions"
.ie n .IP """save_state(READLINE_STATE)""" 4
.el .IP "\f(CWsave_state(READLINE_STATE)\fR" 4
.IX Item "save_state(READLINE_STATE)"
.Vb 1
\&        READLINE_STATE  rl_save_state()                         # GRL 6.0
.Ve
.ie n .IP """restore_state(READLINE_STATE)""" 4
.el .IP "\f(CWrestore_state(READLINE_STATE)\fR" 4
.IX Item "restore_state(READLINE_STATE)"
.Vb 1
\&        int     rl_restore_state(READLINE_STATE)                # GRL 6.0
.Ve
.ie n .IP """free(MEM)""" 4
.el .IP "\f(CWfree(MEM)\fR" 4
.IX Item "free(MEM)"
.Vb 2
\&        Not implemented since not required for Perl.
\&        int     rl_free(void *mem)                              # GRL 6.0
.Ve
.ie n .IP """replace_line(TEXT [,CLEAR_UNDO])""" 4
.el .IP "\f(CWreplace_line(TEXT [,CLEAR_UNDO])\fR" 4
.IX Item "replace_line(TEXT [,CLEAR_UNDO])"
.Vb 1
\&        int     rl_replace_line(str text, int clear_undo = 0)   # GRL 4.3
.Ve
.ie n .IP """extend_line_buffer(LEN)""" 4
.el .IP "\f(CWextend_line_buffer(LEN)\fR" 4
.IX Item "extend_line_buffer(LEN)"
.Vb 2
\&        Not implemented since not required for Perl.
\&        int     rl_extend_line_buffer(int len)
.Ve
.ie n .IP """initialize""" 4
.el .IP "\f(CWinitialize\fR" 4
.IX Item "initialize"
.Vb 1
\&        int     rl_initialize()
.Ve
.ie n .IP """ding""" 4
.el .IP "\f(CWding\fR" 4
.IX Item "ding"
.Vb 1
\&        int     rl_ding()
.Ve
.ie n .IP "alphabetic(C)" 4
.el .IP "\f(CWalphabetic(C)\fR" 4
.IX Item "alphabetic(C)"
.Vb 1
\&        int     rl_alphabetic(int C)                            # GRL 4.2
.Ve
.ie n .IP """display_match_list(MATCHES [,LEN [,MAX]])""" 4
.el .IP "\f(CWdisplay_match_list(MATCHES [,LEN [,MAX]])\fR" 4
.IX Item "display_match_list(MATCHES [,LEN [,MAX]])"
.Vb 1
\&        void    rl_display_match_list(\e@matches, len = $#maches, max) # GRL 4.0
.Ve
.Sp
Since the first element of an array \f(CW@matches\fR as treated as a possible
completion, it is not displayed.  See the descriptions of
\&\f(CW\*(C`completion_matches()\*(C'\fR.
When \f(CW\*(C`MAX\*(C'\fR is omitted, the max length of an item in \f(CW@matches\fR is used.
.PP
Miscellaneous Functions
.IX Subsection "Miscellaneous Functions"
.ie n .IP """macro_bind(KEYSEQ, MACRO [,MAP])""" 4
.el .IP "\f(CWmacro_bind(KEYSEQ, MACRO [,MAP])\fR" 4
.IX Item "macro_bind(KEYSEQ, MACRO [,MAP])"
.Vb 1
\&        int     rl_macro_bind(const str keyseq, const str macro, Keymap map)
.Ve
.ie n .IP """macro_dumper(READABLE)""" 4
.el .IP "\f(CWmacro_dumper(READABLE)\fR" 4
.IX Item "macro_dumper(READABLE)"
.Vb 1
\&        int     rl_macro_dumper(int readline)
.Ve
.ie n .IP """variable_bind(VARIABLE, VALUE)""" 4
.el .IP "\f(CWvariable_bind(VARIABLE, VALUE)\fR" 4
.IX Item "variable_bind(VARIABLE, VALUE)"
.Vb 1
\&        int     rl_variable_bind(const str variable, const str value)
.Ve
.ie n .IP """variable_value(VARIABLE)""" 4
.el .IP "\f(CWvariable_value(VARIABLE)\fR" 4
.IX Item "variable_value(VARIABLE)"
.Vb 1
\&        str     rl_variable_value(const str variable)           # GRL 5.1
.Ve
.ie n .IP """variable_dumper(READABLE)""" 4
.el .IP "\f(CWvariable_dumper(READABLE)\fR" 4
.IX Item "variable_dumper(READABLE)"
.Vb 1
\&        int     rl_variable_dumper(int readline)
.Ve
.ie n .IP """set_paren_blink_timeout(uSEC)""" 4
.el .IP "\f(CWset_paren_blink_timeout(uSEC)\fR" 4
.IX Item "set_paren_blink_timeout(uSEC)"
.Vb 1
\&        int     rl_set_paren_blink_timeout(usec)                # GRL 4.2
.Ve
.ie n .IP """get_termcap(cap)""" 4
.el .IP "\f(CWget_termcap(cap)\fR" 4
.IX Item "get_termcap(cap)"
.Vb 1
\&        str     rl_get_termcap(cap)
.Ve
.ie n .IP """clear_history""" 4
.el .IP "\f(CWclear_history\fR" 4
.IX Item "clear_history"
.Vb 1
\&    void        rl_clear_history()                              # GRL 6.3
.Ve
.PP
Alternate Interface
.IX Subsection "Alternate Interface"
.ie n .IP """callback_handler_install(PROMPT, LHANDLER)""" 4
.el .IP "\f(CWcallback_handler_install(PROMPT, LHANDLER)\fR" 4
.IX Item "callback_handler_install(PROMPT, LHANDLER)"
.Vb 1
\&        void    rl_callback_handler_install(str prompt, pfunc lhandler)
.Ve
.ie n .IP """callback_read_char""" 4
.el .IP "\f(CWcallback_read_char\fR" 4
.IX Item "callback_read_char"
.Vb 1
\&        void    rl_callback_read_char()
.Ve
.ie n .IP """callback_sigcleanup""					# \s-1GRL 7.0\s0" 4
.el .IP "\f(CWcallback_sigcleanup\fR					# \s-1GRL 7.0\s0" 4
.IX Item "callback_sigcleanup # GRL 7.0"
.Vb 1
\&        void    rl_callback_sigcleanup()
.Ve
.ie n .IP """callback_handler_remove""" 4
.el .IP "\f(CWcallback_handler_remove\fR" 4
.IX Item "callback_handler_remove"
.Vb 1
\&        void    rl_callback_handler_remove()
.Ve
.PP
\fIReadline Signal Handling\fR
.IX Subsection "Readline Signal Handling"
.ie n .IP """pending_signal()""" 4
.el .IP "\f(CWpending_signal()\fR" 4
.IX Item "pending_signal()"
.Vb 1
\&        int     rl_pending_signal()                             # GRL 7.0
.Ve
.ie n .IP """cleanup_after_signal""" 4
.el .IP "\f(CWcleanup_after_signal\fR" 4
.IX Item "cleanup_after_signal"
.Vb 1
\&        void    rl_cleanup_after_signal()                       # GRL 4.0
.Ve
.ie n .IP """free_line_state""" 4
.el .IP "\f(CWfree_line_state\fR" 4
.IX Item "free_line_state"
.Vb 1
\&        void    rl_free_line_state()                            # GRL 4.0
.Ve
.ie n .IP """reset_after_signal""" 4
.el .IP "\f(CWreset_after_signal\fR" 4
.IX Item "reset_after_signal"
.Vb 1
\&        void    rl_reset_after_signal()                         # GRL 4.0
.Ve
.ie n .IP """echo_signal_char""" 4
.el .IP "\f(CWecho_signal_char\fR" 4
.IX Item "echo_signal_char"
.Vb 1
\&        void    rl_echo_signal_char(int sig)                    # GRL 6.0
.Ve
.ie n .IP """resize_terminal""" 4
.el .IP "\f(CWresize_terminal\fR" 4
.IX Item "resize_terminal"
.Vb 1
\&        void    rl_resize_terminal()                            # GRL 4.0
.Ve
.ie n .IP """set_screen_size(ROWS, COLS)""" 4
.el .IP "\f(CWset_screen_size(ROWS, COLS)\fR" 4
.IX Item "set_screen_size(ROWS, COLS)"
.Vb 1
\&        void    rl_set_screen_size(int ROWS, int COLS)          # GRL 4.2
.Ve
.ie n .IP """get_screen_size()""" 4
.el .IP "\f(CWget_screen_size()\fR" 4
.IX Item "get_screen_size()"
.Vb 1
\&        (int rows, int cols)    rl_get_screen_size()            # GRL 4.2
.Ve
.ie n .IP """reset_screen_size()""" 4
.el .IP "\f(CWreset_screen_size()\fR" 4
.IX Item "reset_screen_size()"
.Vb 1
\&        void    rl_reset_screen_size()                          # GRL 5.1
.Ve
.ie n .IP """set_signals""" 4
.el .IP "\f(CWset_signals\fR" 4
.IX Item "set_signals"
.Vb 1
\&        int     rl_set_signals()                                # GRL 4.0
.Ve
.ie n .IP """clear_signals""" 4
.el .IP "\f(CWclear_signals\fR" 4
.IX Item "clear_signals"
.Vb 1
\&        int     rl_clear_signals()                              # GRL 4.0
.Ve
.PP
\fICompletion Functions\fR
.IX Subsection "Completion Functions"
.ie n .IP """complete_internal([WHAT_TO_DO])""" 4
.el .IP "\f(CWcomplete_internal([WHAT_TO_DO])\fR" 4
.IX Item "complete_internal([WHAT_TO_DO])"
.Vb 1
\&        int     rl_complete_internal(int what_to_do = TAB)
.Ve
.ie n .IP """completion_mode(FUNCTION)""" 4
.el .IP "\f(CWcompletion_mode(FUNCTION)\fR" 4
.IX Item "completion_mode(FUNCTION)"
.Vb 1
\&        int     rl_completion_mode(FunctionPtr|str function)    # GRL 4.3
.Ve
.ie n .IP """completion_matches(TEXT [,FUNC])""" 4
.el .IP "\f(CWcompletion_matches(TEXT [,FUNC])\fR" 4
.IX Item "completion_matches(TEXT [,FUNC])"
.Vb 2
\&        (@str)  rl_completion_matches(str text,
\&                                      pfunc func = filename_completion_function)
.Ve
.ie n .IP """filename_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWfilename_completion_function(TEXT, STATE)\fR" 4
.IX Item "filename_completion_function(TEXT, STATE)"
.Vb 1
\&        str     rl_filename_completion_function(str text, int state)
.Ve
.ie n .IP """username_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWusername_completion_function(TEXT, STATE)\fR" 4
.IX Item "username_completion_function(TEXT, STATE)"
.Vb 1
\&        str     rl_username_completion_function(str text, int state)
.Ve
.ie n .IP """list_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWlist_completion_function(TEXT, STATE)\fR" 4
.IX Item "list_completion_function(TEXT, STATE)"
.Vb 1
\&        str     list_completion_function(str text, int state)   # TRG original
.Ve
.PP
\fIHistory Functions\fR
.IX Subsection "History Functions"
.PP
Initializing History and State Management
.IX Subsection "Initializing History and State Management"
.ie n .IP """using_history""" 4
.el .IP "\f(CWusing_history\fR" 4
.IX Item "using_history"
.Vb 1
\&        void    using_history()
.Ve
.ie n .IP """history_get_history_state""" 4
.el .IP "\f(CWhistory_get_history_state\fR" 4
.IX Item "history_get_history_state"
.Vb 1
\&        HISTORY_STATE   history_get_hitory_state()              # GRL 6.3
.Ve
.ie n .IP """history_set_history_state""" 4
.el .IP "\f(CWhistory_set_history_state\fR" 4
.IX Item "history_set_history_state"
.Vb 1
\&        void    history_set_hitory_state(HISTORY_STATE)         # GRL 6.3
.Ve
.PP
History List Management
.IX Subsection "History List Management"
.ie n .IP """add_history(STRING)""" 4
.el .IP "\f(CWadd_history(STRING)\fR" 4
.IX Item "add_history(STRING)"
.Vb 1
\&        void    add_history(str string)
.Ve
.ie n .IP """add_history_time(STRING)""" 4
.el .IP "\f(CWadd_history_time(STRING)\fR" 4
.IX Item "add_history_time(STRING)"
.Vb 1
\&        void    add_history_time(str string)                    # GRL 5.0
.Ve
.ie n .IP """remove_history(WHICH)""" 4
.el .IP "\f(CWremove_history(WHICH)\fR" 4
.IX Item "remove_history(WHICH)"
.Vb 1
\&        str     remove_history(int which)
.Ve
.ie n .IP """free_history(HISTENT)""" 4
.el .IP "\f(CWfree_history(HISTENT)\fR" 4
.IX Item "free_history(HISTENT)"
.Vb 4
\&        Not implemented since Term::ReadLine::Gnu does not support the
\&        member \*(Aqdata\*(Aq of HIST_ENTRY structure. remove_history() frees
\&        the memory.
\&        histdata_t      free_history_entry(HIST_ENTRY *histent) # GRL 5.0
.Ve
.ie n .IP """replace_history_entry(WHICH, STRING)""" 4
.el .IP "\f(CWreplace_history_entry(WHICH, STRING)\fR" 4
.IX Item "replace_history_entry(WHICH, STRING)"
.Vb 1
\&        str     replace_history_entry(int which, str string)
.Ve
.ie n .IP """clear_history""" 4
.el .IP "\f(CWclear_history\fR" 4
.IX Item "clear_history"
.Vb 1
\&        void    clear_history()
.Ve
.ie n .IP """StifleHistory(MAX)""" 4
.el .IP "\f(CWStifleHistory(MAX)\fR" 4
.IX Item "StifleHistory(MAX)"
.Vb 1
\&        int     stifle_history(int max|undef)
.Ve
.Sp
stifles the history list, remembering only the last \f(CW\*(C`MAX\*(C'\fR entries.
If \f(CW\*(C`MAX\*(C'\fR is undef, remembers all entries.  This is a replacement
of \f(CW\*(C`unstifle_history()\*(C'\fR.
.ie n .IP """unstifle_history""" 4
.el .IP "\f(CWunstifle_history\fR" 4
.IX Item "unstifle_history"
.Vb 1
\&        int     unstifle_history()
.Ve
.Sp
This is equivalent with \f(CW\*(C`stifle_history(undef)\*(C'\fR.
.ie n .IP """history_is_stifled""" 4
.el .IP "\f(CWhistory_is_stifled\fR" 4
.IX Item "history_is_stifled"
.Vb 1
\&        int     history_is_stifled()
.Ve
.ie n .IP """SetHistory(LINE1 [, LINE2, ...])""" 4
.el .IP "\f(CWSetHistory(LINE1 [, LINE2, ...])\fR" 4
.IX Item "SetHistory(LINE1 [, LINE2, ...])"
sets the history of input, from where it can be used if the actual
\&\f(CW\*(C`readline\*(C'\fR is present.
.PP
Information About the History List
.IX Subsection "Information About the History List"
.ie n .IP """history_list""" 4
.el .IP "\f(CWhistory_list\fR" 4
.IX Item "history_list"
.Vb 2
\&        Not implemented since not required for Perl.
\&        HIST_ENTRY **history_list()
.Ve
.ie n .IP """where_history""" 4
.el .IP "\f(CWwhere_history\fR" 4
.IX Item "where_history"
.Vb 1
\&        int     where_history()
.Ve
.ie n .IP """current_history""" 4
.el .IP "\f(CWcurrent_history\fR" 4
.IX Item "current_history"
.Vb 1
\&        str     current_history()
.Ve
.ie n .IP """history_get(OFFSET)""" 4
.el .IP "\f(CWhistory_get(OFFSET)\fR" 4
.IX Item "history_get(OFFSET)"
.Vb 1
\&        str     history_get(offset)
.Ve
.ie n .IP """history_get_time(OFFSET)""" 4
.el .IP "\f(CWhistory_get_time(OFFSET)\fR" 4
.IX Item "history_get_time(OFFSET)"
.Vb 1
\&        time_t  history_get_time(offset)                        # GRL 5.0
.Ve
.ie n .IP """history_total_bytes""" 4
.el .IP "\f(CWhistory_total_bytes\fR" 4
.IX Item "history_total_bytes"
.Vb 1
\&        int     history_total_bytes()
.Ve
.ie n .IP """GetHistory""" 4
.el .IP "\f(CWGetHistory\fR" 4
.IX Item "GetHistory"
returns the history of input as a list, if actual \f(CW\*(C`readline\*(C'\fR is present.
.PP
Moving Around the History List
.IX Subsection "Moving Around the History List"
.ie n .IP """history_set_pos(POS)""" 4
.el .IP "\f(CWhistory_set_pos(POS)\fR" 4
.IX Item "history_set_pos(POS)"
.Vb 1
\&        int     history_set_pos(int pos)
.Ve
.ie n .IP """previous_history""" 4
.el .IP "\f(CWprevious_history\fR" 4
.IX Item "previous_history"
.Vb 1
\&        str     previous_history()
.Ve
.ie n .IP """next_history""" 4
.el .IP "\f(CWnext_history\fR" 4
.IX Item "next_history"
.Vb 1
\&        str     next_history()
.Ve
.PP
Searching the History List
.IX Subsection "Searching the History List"
.ie n .IP """history_search(STRING [,DIRECTION])""" 4
.el .IP "\f(CWhistory_search(STRING [,DIRECTION])\fR" 4
.IX Item "history_search(STRING [,DIRECTION])"
.Vb 1
\&        int     history_search(str string, int direction = \-1)
.Ve
.ie n .IP """history_search_prefix(STRING [,DIRECTION])""" 4
.el .IP "\f(CWhistory_search_prefix(STRING [,DIRECTION])\fR" 4
.IX Item "history_search_prefix(STRING [,DIRECTION])"
.Vb 1
\&        int     history_search_prefix(str string, int direction = \-1)
.Ve
.ie n .IP """history_search_pos(STRING [,DIRECTION [,POS]])""" 4
.el .IP "\f(CWhistory_search_pos(STRING [,DIRECTION [,POS]])\fR" 4
.IX Item "history_search_pos(STRING [,DIRECTION [,POS]])"
.Vb 3
\&        int     history_search_pos(str string,
\&                                   int direction = \-1,
\&                                   int pos = where_history())
.Ve
.PP
Managing the History File
.IX Subsection "Managing the History File"
.ie n .IP """ReadHistory([FILENAME [,FROM [,TO]]])""" 4
.el .IP "\f(CWReadHistory([FILENAME [,FROM [,TO]]])\fR" 4
.IX Item "ReadHistory([FILENAME [,FROM [,TO]]])"
.Vb 2
\&        int     read_history(str filename = \*(Aq~/.history\*(Aq,
\&                             int from = 0, int to = \-1)
\&
\&        int     read_history_range(str filename = \*(Aq~/.history\*(Aq,
\&                                   int from = 0, int to = \-1)
.Ve
.Sp
adds the contents of \f(CW\*(C`FILENAME\*(C'\fR to the history list, a line at a
time.  If \f(CW\*(C`FILENAME\*(C'\fR is false, then read from \fI~/.history\fR.  Start
reading at line \f(CW\*(C`FROM\*(C'\fR and end at \f(CW\*(C`TO\*(C'\fR.  If \f(CW\*(C`FROM\*(C'\fR is omitted or
zero, start at the beginning.  If \f(CW\*(C`TO\*(C'\fR is omitted or less than
\&\f(CW\*(C`FROM\*(C'\fR, then read until the end of the file.  Returns true if
successful, or false if not.  \f(CW\*(C`read_history()\*(C'\fR is an alias of
\&\f(CW\*(C`read_history_range()\*(C'\fR.
.ie n .IP """WriteHistory([FILENAME])""" 4
.el .IP "\f(CWWriteHistory([FILENAME])\fR" 4
.IX Item "WriteHistory([FILENAME])"
.Vb 1
\&        int     write_history(str filename = \*(Aq~/.history\*(Aq)
.Ve
.Sp
writes the current history to \f(CW\*(C`FILENAME\*(C'\fR, overwriting \f(CW\*(C`FILENAME\*(C'\fR if
necessary.  If \f(CW\*(C`FILENAME\*(C'\fR is false, then write the history list to
\&\fI~/.history\fR.  Returns true if successful, or false if not.
.ie n .IP """append_history(NELEMENTS [,FILENAME])""" 4
.el .IP "\f(CWappend_history(NELEMENTS [,FILENAME])\fR" 4
.IX Item "append_history(NELEMENTS [,FILENAME])"
.Vb 1
\&        int     append_history(int nelements, str filename = \*(Aq~/.history\*(Aq)
.Ve
.ie n .IP """history_truncate_file([FILENAME [,NLINES]])""" 4
.el .IP "\f(CWhistory_truncate_file([FILENAME [,NLINES]])\fR" 4
.IX Item "history_truncate_file([FILENAME [,NLINES]])"
.Vb 2
\&        int     history_truncate_file(str filename = \*(Aq~/.history\*(Aq,
\&                                      int nlines = 0)
.Ve
.PP
History Expansion
.IX Subsection "History Expansion"
.ie n .IP """history_expand(STRING)""" 4
.el .IP "\f(CWhistory_expand(STRING)\fR" 4
.IX Item "history_expand(STRING)"
.Vb 1
\&        (int result, str expansion) history_expand(str string)
.Ve
.Sp
Note that this function returns \f(CW\*(C`expansion\*(C'\fR in the scalar context.
.ie n .IP """get_history_event(STRING, CINDEX [,QCHAR])""" 4
.el .IP "\f(CWget_history_event(STRING, CINDEX [,QCHAR])\fR" 4
.IX Item "get_history_event(STRING, CINDEX [,QCHAR])"
.Vb 3
\&        (str text, int cindex) = get_history_event(str  string,
\&                                                   int  cindex,
\&                                                   char qchar = \*(Aq\e0\*(Aq)
.Ve
.ie n .IP """history_tokenize(STRING)""" 4
.el .IP "\f(CWhistory_tokenize(STRING)\fR" 4
.IX Item "history_tokenize(STRING)"
.Vb 1
\&        (@str)  history_tokenize(str string)
.Ve
.ie n .IP """history_arg_extract(STRING, [FIRST [,LAST]])""" 4
.el .IP "\f(CWhistory_arg_extract(STRING, [FIRST [,LAST]])\fR" 4
.IX Item "history_arg_extract(STRING, [FIRST [,LAST]])"
.Vb 1
\&        str history_arg_extract(str string, int first = 0, int last = \*(Aq$\*(Aq)
.Ve
.ie n .SS """Term::ReadLine::Gnu"" Variables"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Variables"
.IX Subsection "Term::ReadLine::Gnu Variables"
Following \s-1GNU\s0 Readline/History Library variables can be accessed by a
Perl program.  See \s-1GNU\s0 Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html> and
\&\s-1GNU\s0 History Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/history.html> for
details of each variable.  You can access them by using \f(CW\*(C`Attribs\*(C'\fR
methods.  Names of keys in this hash conform to standard conventions
with the leading \f(CW\*(C`rl_\*(C'\fR stripped.
.PP
Examples:
.PP
.Vb 3
\&    $attribs = $term\->Attribs;
\&    $v = $attribs\->{library_version};   # rl_library_version
\&    $v = $attribs\->{history_base};      # history_base
.Ve
.PP
\fIReadline Variables\fR
.IX Subsection "Readline Variables"
.PP
.Vb 10
\&        str rl_line_buffer
\&        int rl_point
\&        int rl_end
\&        int rl_mark
\&        int rl_done
\&        int rl_num_chars_to_read (GRL 4.1)
\&        int rl_pending_input
\&        int rl_dispatching
\&        int rl_erase_empty_line (GRL 4.0)
\&        str rl_prompt (read only)
\&        str rl_display_prompt
\&        int rl_already_prompted (GRL 4.1)
\&        str rl_library_version (read only)
\&        int rl_readline_version (read only)
\&        int rl_gnu_readline_p (GRL 4.1, read only)
\&        str rl_terminal_name
\&        str rl_readline_name
\&        filehandle rl_instream
\&        filehandle rl_outstream
\&        int rl_prefer_env_winsize (GRL 5.1)
\&        pfunc rl_last_func (GRL 4.2, read only)
\&        pfunc rl_startup_hook
\&        pfunc rl_pre_input_hook (GRL 4.0)
\&        pfunc rl_event_hook
\&        pfunc rl_getc_function
\&        pfunc rl_signal_event_hook (GRL 6.3)
\&        pfunc rl_input_available_hook (GRL 6.3)
\&        pfunc rl_redisplay_function
\&        pfunc rl_prep_term_function (GRL 2.1)
\&        pfunc rl_deprep_term_function (GRL 2.1)
\&        Keymap rl_executing_keymap (read only)
\&        Keymap rl_binding_keymap (read only)
\&        str rl_executing_macro (GRL 4.2, read only)
\&        int rl_executing_key (GRL 6.3, read only)
\&        str rl_executing_keyseq (GRL 6.3, read only)
\&        int rl_key_sequence_length (read only)
\&        int rl_readline_state (GRL 4.2)
\&        int rl_explicit_arg (read only)
\&        int rl_numeric_arg (read only)
\&        int rl_editing_mode (read only)
.Ve
.PP
\fISignal Handling Variables\fR
.IX Subsection "Signal Handling Variables"
.PP
.Vb 4
\&        int rl_catch_signals (GRL 4.0)
\&        int rl_catch_sigwinch (GRL 4.0)
\&        int rl_persistent_signal_handlers (GRL 7.0)
\&        int rl_change_environment (GRL 6.3)
.Ve
.PP
\fICompletion Variables\fR
.IX Subsection "Completion Variables"
.PP
.Vb 10
\&        pfunc rl_completion_entry_function
\&        pfunc rl_attempted_completion_function
\&        pfunc rl_filename_quoting_function
\&        pfunc rl_filename_dequoting_function
\&        pfunc rl_char_is_quoted_p
\&        pfunc rl_ignore_some_completions_function
\&        pfunc rl_directory_completion_hook
\&        pfunc rl_directory_rewrite_hook (GRL 4.2)
\&        pfunc rl_filename_stat_hook (GRL 6.3)
\&        pfunc rl_filename_rewrite_hook (GRL 6.1)
\&        pfunc rl_completion_display_matches_hook (GRL 4.0)
\&        str rl_basic_word_break_characters
\&        str rl_basic_quote_characters
\&        str rl_completer_word_break_characters
\&        pfunc rl_completion_word_break_hook (GRL 5.0)
\&        str rl_completer_quote_characters
\&        str rl_filename_quote_characters
\&        str rl_special_prefixes
\&        int rl_completion_query_items
\&        int rl_completion_append_character
\&        int rl_completion_suppress_append (GRL 4.3)
\&        int rl_completion_quote_character (GRL 5.0, read only)
\&        int rl_completion_suppress_quote (GRL 5.0)
\&        int rl_completion_found_quote (GRL 5.0, read only)
\&        int rl_completion_mark_symlink_dirs (GRL 4.3)
\&        int rl_ignore_completion_duplicates
\&        int rl_filename_completion_desired
\&        int rl_filename_quoting_desired
\&        int rl_attempted_completion_over
\&        int rl_sort_completion_matches (GRL 6.0)
\&        int rl_completion_type (read only)
\&        int rl_completion_invoking_key (GRL 6.0, read only)
\&        int rl_inhibit_completion
.Ve
.PP
\fIHistory Variables\fR
.IX Subsection "History Variables"
.PP
.Vb 12
\&        int history_base
\&        int history_length
\&        int history_max_entries (called \`max_input_history\*(Aq, read only)
\&        int history_write_timestamps (GRL 5.0)
\&        char history_expansion_char
\&        char history_subst_char
\&        char history_comment_char
\&        str history_word_delimiters (GRL 4.2)
\&        str history_search_delimiter_chars
\&        str history_no_expand_chars
\&        int history_quotes_inhibit_expansion
\&        pfunc history_inhibit_expansion_function
.Ve
.PP
\fIFunction References\fR
.IX Subsection "Function References"
.PP
.Vb 9
\&        rl_getc
\&        rl_redisplay
\&        rl_callback_read_char
\&        rl_display_match_list
\&        rl_filename_completion_function
\&        rl_username_completion_function
\&        list_completion_function
\&        shadow_redisplay
\&        Tk_getc
.Ve
.SS "Custom Completion"
.IX Subsection "Custom Completion"
In this section variables and functions for custom completion are
described along with examples.
.PP
Most of descriptions in this section came from \s-1GNU\s0 Readline
Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>.
.ie n .IP """completion_entry_function""" 4
.el .IP "\f(CWcompletion_entry_function\fR" 4
.IX Item "completion_entry_function"
This variable holds reference refers to a generator function for
\&\f(CW\*(C`completion_matches()\*(C'\fR.
.Sp
A generator function is called repeatedly from
\&\f(CW\*(C`completion_matches()\*(C'\fR, returning a string each time.  The arguments
to the generator function are \f(CW\*(C`TEXT\*(C'\fR and \f(CW\*(C`STATE\*(C'\fR.  \f(CW\*(C`TEXT\*(C'\fR is the
partial word to be completed.  \f(CW\*(C`STATE\*(C'\fR is zero the first time the
function is called, allowing the generator to perform any necessary
initialization, and a positive non-zero integer for each subsequent
call.  When the generator function returns \f(CW\*(C`undef\*(C'\fR this signals
\&\f(CW\*(C`completion_matches()\*(C'\fR that there are no more possibilities left.
.Sp
If this variable set to undef, built-in \f(CW\*(C`filename_completion_function\*(C'\fR is
used.
.Sp
A sample generator function, \f(CW\*(C`list_completion_function\*(C'\fR, is defined
in Gnu.pm.  You can use it as follows;
.Sp
.Vb 11
\&    use Term::ReadLine;
\&    ...
\&    my $term = new Term::ReadLine \*(Aqsample\*(Aq;
\&    my $attribs = $term\->Attribs;
\&    ...
\&    $attribs\->{completion_entry_function} =
\&        $attribs\->{list_completion_function};
\&    ...
\&    $attribs\->{completion_word} =
\&        [qw(reference to a list of words which you want to use for completion)];
\&    $term\->readline("custom completion>");
.Ve
.Sp
See also \f(CW\*(C`completion_matches\*(C'\fR.
.ie n .IP """attempted_completion_function""" 4
.el .IP "\f(CWattempted_completion_function\fR" 4
.IX Item "attempted_completion_function"
A reference to an alternative function to create matches.
.Sp
The function is called with \f(CW\*(C`TEXT\*(C'\fR, \f(CW\*(C`LINE_BUFFER\*(C'\fR, \f(CW\*(C`START\*(C'\fR, and
\&\f(CW\*(C`END\*(C'\fR.  \f(CW\*(C`LINE_BUFFER\*(C'\fR is a current input buffer string.  \f(CW\*(C`START\*(C'\fR
and \f(CW\*(C`END\*(C'\fR are indices in \f(CW\*(C`LINE_BUFFER\*(C'\fR saying what the boundaries of
\&\f(CW\*(C`TEXT\*(C'\fR are.
.Sp
If this function exists and returns null list or \f(CW\*(C`undef\*(C'\fR, or if this
variable is set to \f(CW\*(C`undef\*(C'\fR, then an internal function
\&\f(CW\*(C`rl_complete()\*(C'\fR will call the value of
\&\f(CW\*(C`completion_entry_function\*(C'\fR to generate matches, otherwise the
array of strings returned will be used.
.Sp
The default value of this variable is \f(CW\*(C`undef\*(C'\fR.  You can use it as follows;
.Sp
.Vb 10
\&    use Term::ReadLine;
\&    ...
\&    my $term = new Term::ReadLine \*(Aqsample\*(Aq;
\&    my $attribs = $term\->Attribs;
\&    ...
\&    sub sample_completion {
\&        my ($text, $line, $start, $end) = @_;
\&        # If first word then username completion, else filename completion
\&        if (substr($line, 0, $start) =~ /^\es*$/) {
\&            return $term\->completion_matches($text,
\&                                             $attribs\->{\*(Aqusername_completion_function\*(Aq});
\&        } else {
\&            return ();
\&        }
\&    }
\&    ...
\&    $attribs\->{attempted_completion_function} = \e&sample_completion;
.Ve
.ie n .IP """completion_matches(TEXT, ENTRY_FUNC)""" 4
.el .IP "\f(CWcompletion_matches(TEXT, ENTRY_FUNC)\fR" 4
.IX Item "completion_matches(TEXT, ENTRY_FUNC)"
Returns an array of strings which is a list of completions for
\&\f(CW\*(C`TEXT\*(C'\fR.  If there are no completions, returns \f(CW\*(C`undef\*(C'\fR.  The first
entry in the returned array is the substitution for \f(CW\*(C`TEXT\*(C'\fR.  The
remaining entries are the possible completions.
.Sp
\&\f(CW\*(C`ENTRY_FUNC\*(C'\fR is a generator function which has two arguments, and
returns a string.  The first argument is \f(CW\*(C`TEXT\*(C'\fR.  The second is a
state argument; it is zero on the first call, and non-zero on
subsequent calls.  \f(CW\*(C`ENTRY_FUNC\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR to the caller when
there are no more matches.
.Sp
If the value of \f(CW\*(C`ENTRY_FUNC\*(C'\fR is undef, built-in
\&\f(CW\*(C`filename_completion_function\*(C'\fR is used.
.Sp
\&\f(CW\*(C`completion_matches\*(C'\fR is a Perl wrapper function of an internal
function \f(CW\*(C`completion_matches()\*(C'\fR.  See also
\&\f(CW\*(C`completion_entry_function\*(C'\fR.
.ie n .IP """completion_function""" 4
.el .IP "\f(CWcompletion_function\fR" 4
.IX Item "completion_function"
A variable whose content is a reference to a function which returns a
list of candidates to complete.
.Sp
This variable is compatible with Term::ReadLine::Perl <http://search.cpan.org/dist/Term-ReadLine-Perl/> and very easy
to use.
.Sp
.Vb 9
\&    use Term::ReadLine;
\&    ...
\&    my $term = new Term::ReadLine \*(Aqsample\*(Aq;
\&    my $attribs = $term\->Attribs;
\&    ...
\&    $attribs\->{completion_function} = sub {
\&        my ($text, $line, $start) = @_;
\&        return qw(a list of candidates to complete);
\&    };
.Ve
.ie n .IP """list_completion_function(TEXT, STATE)""" 4
.el .IP "\f(CWlist_completion_function(TEXT, STATE)\fR" 4
.IX Item "list_completion_function(TEXT, STATE)"
A sample generator function defined by \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR.
Example code at \f(CW\*(C`completion_entry_function\*(C'\fR shows how to use this
function.
.ie n .SS """Term::ReadLine::Gnu"" Specific Features"
.el .SS "\f(CWTerm::ReadLine::Gnu\fP Specific Features"
.IX Subsection "Term::ReadLine::Gnu Specific Features"
\fI\f(CI\*(C`Term::ReadLine::Gnu\*(C'\fI Specific Functions\fR
.IX Subsection "Term::ReadLine::Gnu Specific Functions"
.ie n .IP """CallbackHandlerInstall(PROMPT, LHANDLER)""" 4
.el .IP "\f(CWCallbackHandlerInstall(PROMPT, LHANDLER)\fR" 4
.IX Item "CallbackHandlerInstall(PROMPT, LHANDLER)"
This method provides the function \f(CW\*(C`rl_callback_handler_install()\*(C'\fR
with the following additional feature compatible with \f(CW\*(C`readline\*(C'\fR
method; ornament feature, Term::ReadLine::Perl <http://search.cpan.org/dist/Term-ReadLine-Perl/> compatible
completion function, history expansion, and addition to history
buffer.
.ie n .IP """call_function(FUNCTION, [COUNT [,KEY]])""" 4
.el .IP "\f(CWcall_function(FUNCTION, [COUNT [,KEY]])\fR" 4
.IX Item "call_function(FUNCTION, [COUNT [,KEY]])"
.Vb 1
\&        int     rl_call_function(FunctionPtr|str function, count = 1, key = \-1)
.Ve
.ie n .IP """get_all_function_names""" 4
.el .IP "\f(CWget_all_function_names\fR" 4
.IX Item "get_all_function_names"
Returns a list of all function names.
.ie n .IP """shadow_redisplay""" 4
.el .IP "\f(CWshadow_redisplay\fR" 4
.IX Item "shadow_redisplay"
A redisplay function for password input.  You can use it as follows;
.Sp
.Vb 2
\&        $attribs\->{redisplay_function} = $attribs\->{shadow_redisplay};
\&        $line = $term\->readline("password> ");
.Ve
.ie n .IP """filename_list""" 4
.el .IP "\f(CWfilename_list\fR" 4
.IX Item "filename_list"
Returns candidates of filenames to complete.  This function can be used
with \f(CW\*(C`completion_function\*(C'\fR and is implemented for the compatibility
with Term::ReadLine::Perl <http://search.cpan.org/dist/Term-ReadLine-Perl/>.
.ie n .IP """list_completion_function""" 4
.el .IP "\f(CWlist_completion_function\fR" 4
.IX Item "list_completion_function"
See the description of section \*(L"Custom Completion\*(R".
.PP
\fI\f(CI\*(C`Term::ReadLine::Gnu\*(C'\fI Specific Variables\fR
.IX Subsection "Term::ReadLine::Gnu Specific Variables"
.ie n .IP """do_expand""" 4
.el .IP "\f(CWdo_expand\fR" 4
.IX Item "do_expand"
When true, the history expansion is enabled.  By default false.
.ie n .IP """completion_function""" 4
.el .IP "\f(CWcompletion_function\fR" 4
.IX Item "completion_function"
See the description of section \*(L"Custom Completion\*(R".
.ie n .IP """completion_word""" 4
.el .IP "\f(CWcompletion_word\fR" 4
.IX Item "completion_word"
A reference to a list of candidates to complete for
\&\f(CW\*(C`list_completion_function\*(C'\fR.
.PP
\fI\f(CI\*(C`Term::ReadLine::Gnu\*(C'\fI Specific Commands\fR
.IX Subsection "Term::ReadLine::Gnu Specific Commands"
.ie n .IP """history\-expand\-line""" 4
.el .IP "\f(CWhistory\-expand\-line\fR" 4
.IX Item "history-expand-line"
The equivalent of the Bash \f(CW\*(C`history\-expand\-line\*(C'\fR editing command.
.ie n .IP """operate\-and\-get\-next""" 4
.el .IP "\f(CWoperate\-and\-get\-next\fR" 4
.IX Item "operate-and-get-next"
The equivalent of the Korn shell \f(CW\*(C`operate\-and\-get\-next\-history\-line\*(C'\fR
editing command and the Bash \f(CW\*(C`operate\-and\-get\-next\*(C'\fR.
.Sp
This command is bound to \f(CW\*(C`\eC\-o\*(C'\fR by default for the compatibility with
the Bash and Term::ReadLine::Perl <http://search.cpan.org/dist/Term-ReadLine-Perl/>.
.ie n .IP """display\-readline\-version""" 4
.el .IP "\f(CWdisplay\-readline\-version\fR" 4
.IX Item "display-readline-version"
Shows the version of \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR and the one of the \s-1GNU\s0
Readline Library.
.ie n .IP """change\-ornaments""" 4
.el .IP "\f(CWchange\-ornaments\fR" 4
.IX Item "change-ornaments"
Change ornaments interactively.
.SH "FILES"
.IX Header "FILES"
.IP "\fI~/.inputrc\fR" 4
.IX Item "~/.inputrc"
Readline init file.  Using this file it is possible that you would
like to use a different set of key bindings.  When a program which
uses the \s-1GNU\s0 Readline library starts up, the init file is read, and
the key bindings are set.
.Sp
The conditional init constructs is supported.  The program name which is
specified by the first argument of \f(CW\*(C`new\*(C'\fR method is used as the
application construct.
.Sp
For example, when your program calls \f(CW\*(C`new\*(C'\fR method as follows;
.Sp
.Vb 3
\&        ...
\&        $term = new Term::ReadLine \*(AqPerlSh\*(Aq;
\&        ...
.Ve
.Sp
your \fI~/.inputrc\fR can define key bindings only for the program as
follows;
.Sp
.Vb 7
\&        ...
\&        $if PerlSh
\&        Meta\-Rubout: backward\-kill\-word
\&        "\eC\-x\eC\-r": re\-read\-init\-file
\&        "\ee[11~": "Function Key 1"
\&        $endif
\&        ...
.Ve
.Sp
For further details, see the section \*(L"Readline Init File\*(R" in the \s-1GNU\s0
Readline Library
Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>
.SH "EXPORTS"
.IX Header "EXPORTS"
No symbols are exported by default.
The following tags are defined and their symbols can be exported.
.IP "prompt" 4
.IX Item "prompt"
\&\s-1RL_PROMPT_START_IGNORE RL_PROMPT_END_IGNORE\s0
.IP "match_type" 4
.IX Item "match_type"
\&\s-1NO_MATCH SINGLE_MATCH MULT_MATCH\s0
.IP "keymap_type" 4
.IX Item "keymap_type"
\&\s-1ISFUNC ISKMAP ISMACR\s0
.IP "undo_code" 4
.IX Item "undo_code"
\&\s-1UNDO_DELETE UNDO_INSERT UNDO_BEGIN UNDO_END\s0
.IP "rl_state" 4
.IX Item "rl_state"
\&\s-1RL_STATE_NONE RL_STATE_INITIALIZING
RL_STATE_INITIALIZED RL_STATE_TERMPREPPED
RL_STATE_READCMD RL_STATE_METANEXT
RL_STATE_DISPATCHING RL_STATE_MOREINPUT
RL_STATE_ISEARCH RL_STATE_NSEARCH
RL_STATE_SEARCH RL_STATE_NUMERICARG
RL_STATE_MACROINPUT RL_STATE_MACRODEF
RL_STATE_OVERWRITE RL_STATE_COMPLETING
RL_STATE_SIGHANDLER RL_STATE_UNDOING
RL_STATE_INPUTPENDING RL_STATE_TTYCSAVED
RL_STATE_CALLBACK RL_STATE_VIMOTION
RL_STATE_MULTIKEY RL_STATE_VICMDONCE
RL_STATE_CHARSEARCH RL_STATE_REDISPLAYING
RL_STATE_DONE\s0
.PP
They can be exported as follows;
.PP
.Vb 4
\&        use Term::ReadLine;
\&        BEGIN {
\&            import Term::ReadLine::Gnu qw(:keymap_type RL_STATE_INITIALIZED);
\&        }
.Ve
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The environment variable \f(CW\*(C`PERL_RL\*(C'\fR governs which ReadLine clone is
loaded.  See the \s-1ENVIRONMENT\s0 section on
Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/> for
further details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Term::ReadLine::Gnu Project Home Page <http://sourceforge.net/projects/perl-trg/>" 4
.IX Item "Term::ReadLine::Gnu Project Home Page <http://sourceforge.net/projects/perl-trg/>"
.PD 0
.IP "\s-1GNU\s0 Readline Library Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>" 4
.IX Item "GNU Readline Library Manual <http://cnswww.cns.cwru.edu/php/chet/readline/readline.html>"
.IP "\s-1GNU\s0 History Library Manual <http://cnswww.cns.cwru.edu/php/chet/readline/history.html>" 4
.IX Item "GNU History Library Manual <http://cnswww.cns.cwru.edu/php/chet/readline/history.html>"
.ie n .IP "Sample and test programs (\fIeg/*\fR and \fIt/*\fR) in the ""Term::ReadLine::Gnu"" distribution <http://search.cpan.org/dist/Term-ReadLine-Gnu/>" 4
.el .IP "Sample and test programs (\fIeg/*\fR and \fIt/*\fR) in the \f(CWTerm::ReadLine::Gnu\fR distribution <http://search.cpan.org/dist/Term-ReadLine-Gnu/>" 4
.IX Item "Sample and test programs (eg/* and t/*) in the Term::ReadLine::Gnu distribution <http://search.cpan.org/dist/Term-ReadLine-Gnu/>"
.IP "Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/>" 4
.IX Item "Term::ReadLine <http://search.cpan.org/dist/Term-ReadLine/>"
.IP "Works which use Term::ReadLine::Gnu" 4
.IX Item "Works which use Term::ReadLine::Gnu"
.RS 4
.IP "Distributions which depend on Term::ReadLine::Gnu on \s-1CPAN\s0 <http://www.cpan.org/>" 4
.IX Item "Distributions which depend on Term::ReadLine::Gnu on CPAN <http://www.cpan.org/>"
.PD
<https://metacpan.org/requires/distribution/Term\-ReadLine\-Gnu>
.IP "Perl Debugger <http://perldoc.perl.org/perldebug.html>" 4
.IX Item "Perl Debugger <http://perldoc.perl.org/perldebug.html>"
.Vb 1
\&        perl \-d
.Ve
.IP "Perl Shell (psh) <http://gnp.github.io/psh/>" 4
.IX Item "Perl Shell (psh) <http://gnp.github.io/psh/>"
The Perl Shell is a shell that combines the interactive nature of a
Unix shell with the power of Perl.
.Sp
A programmable completion feature compatible with bash is implemented.
.IP "\s-1SPP \s0(Synopsys Plus Perl) <http://vlsiweb.stanford.edu/~jsolomon/SPP/>" 4
.IX Item "SPP (Synopsys Plus Perl) <http://vlsiweb.stanford.edu/~jsolomon/SPP/>"
\&\s-1SPP \s0(Synopsys Plus Perl) is a Perl module that wraps around Synopsys'
shell programs.  \s-1SPP\s0 is inspired by the original dc_perl written by
Steve Golson, but it's an entirely new implementation.  Why is it
called \s-1SPP\s0 and not dc_perl?  Well, \s-1SPP\s0 was written to wrap around any
of Synopsys' shells.
.IP "\s-1PFM \s0(Personal File Manager for Unix/Linux) <http://p-f-m.sourceforge.net/>" 4
.IX Item "PFM (Personal File Manager for Unix/Linux) <http://p-f-m.sourceforge.net/>"
Pfm is a terminal-based file manager written in Perl, based on \s-1PFM.COM\s0
for MS-DOS (originally by Paul Culley and Henk de Heer).
.IP "The soundgrab <http://brittonkerin.com/soundgrab/soundgrab.html>" 4
.IX Item "The soundgrab <http://brittonkerin.com/soundgrab/soundgrab.html>"
soundgrab is designed to help you slice up a big long raw audio file
(by default 44.1 kHz 2 channel signed sixteen bit little endian) and
save your favorite sections to other files. It does this by providing
you with a cassette player like command line interface.
.IP "\s-1PDL \s0(The Perl Data Language) <http://pdl.perl.org/>" 4
.IX Item "PDL (The Perl Data Language) <http://pdl.perl.org/>"
\&\s-1PDL \s0(``Perl Data Language'') gives standard Perl the ability to
compactly store and speedily manipulate the large N\-dimensional data
arrays which are the bread and butter of scientific computing.
.IP "\s-1PIQT \s0(Perl Interactive \s-1DBI\s0 Query Tool) <http://piqt.sourceforge.net/>" 4
.IX Item "PIQT (Perl Interactive DBI Query Tool) <http://piqt.sourceforge.net/>"
\&\s-1PIQT\s0 is an interactive query tool using the Perl \s-1DBI\s0 database
interface. It supports ReadLine, provides a built in scripting language
with a Lisp like syntax, an online help system, and uses wrappers to
interface to the \s-1DBD\s0 modules.
.IP "vshnu (the New Visual Shell) <http://www.cs.indiana.edu/~kinzler/vshnu/>" 4
.IX Item "vshnu (the New Visual Shell) <http://www.cs.indiana.edu/~kinzler/vshnu/>"
A visual shell and \s-1CLI\s0 shell supplement.
.RE
.RS 4
.Sp
If you know any other works you recommend, please let me know.
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Hiroo Hayashi \f(CW\*(C`<hiroo.hayashi@computer.org>\*(C'\fR
.PP
<http://search.cpan.org/~hayashi/>
.SH "TODO"
.IX Header "TODO"
\&\s-1GTK+\s0 support in addition to Tk.
.SH "BUGS"
.IX Header "BUGS"
.IP "Submit a bug report to rt.cpan.org <https://rt.cpan.org/Dist/Display.html?Name=Term-ReadLine-Gnu>." 4
.IX Item "Submit a bug report to rt.cpan.org <https://rt.cpan.org/Dist/Display.html?Name=Term-ReadLine-Gnu>."
.PD 0
.ie n .IP """add_defun()"" can define up to 16 functions." 4
.el .IP "\f(CWadd_defun()\fR can define up to 16 functions." 4
.IX Item "add_defun() can define up to 16 functions."
.IP "Some functions and variables do not have test code yet.  Your contribution is welcome.  See \fIt/readline.t\fR for details." 4
.IX Item "Some functions and variables do not have test code yet. Your contribution is welcome. See t/readline.t for details."
.IP "If the pager command (| or ||) in Perl debugger causes segmentation fault, you need to fix \fIperl5db.pl\fR.  See <https://rt.perl.org/Public/Bug/Display.html?id=121456> for details." 4
.IX Item "If the pager command (| or ||) in Perl debugger causes segmentation fault, you need to fix perl5db.pl. See <https://rt.perl.org/Public/Bug/Display.html?id=121456> for details."
.PD
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1996\-2016 Hiroo Hayashi.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
