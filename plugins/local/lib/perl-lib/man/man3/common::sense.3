.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "sense 3"
.TH sense 3 "2021-02-09" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
common::sense \- save a tree AND a kitten, use common::sense!
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use common::sense;
\&
\&   # Supposed to be mostly the same, with much lower memory usage, as:
\&  
\&   # use utf8;
\&   # use strict qw(vars subs);
\&   # use feature qw(say state switch);
\&   # use feature qw(unicode_strings unicode_eval current_sub fc evalbytes);
\&   # no feature qw(array_base);
\&   # no warnings;
\&   # use warnings qw(FATAL closed threads internal debugging pack
\&   #                 portable prototype inplace io pipe unpack malloc
\&   #                 glob digit printf layer reserved taint closure
\&   #                 semicolon);
\&   # no warnings qw(exec newline unopened);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 2
\&   “Nothing is more fairly distributed than common sense: no one thinks
\&   he needs more of it than he already has.”
\&
\&   – René Descartes
.Ve
.PP
This module implements some sane defaults for Perl programs, as defined by
two typical (or not so typical \- use your common sense) specimens of Perl
coders. In fact, after working out details on which warnings and strict
modes to enable and make fatal, we found that we (and our code written so
far, and others) fully agree on every option, even though we never used
warnings before, so it seems this module indeed reflects a \*(L"common\*(R" sense
among some long-time Perl coders.
.PP
The basic philosophy behind the choices made in common::sense can be
summarised as: \*(L"enforcing strict policies to catch as many bugs as
possible, while at the same time, not limiting the expressive power
available to the programmer\*(R".
.PP
Two typical examples of how this philosophy is applied in practise is the
handling of uninitialised and malloc warnings:
.IP "\fIuninitialised\fR" 4
.IX Item "uninitialised"
\&\f(CW\*(C`undef\*(C'\fR is a well-defined feature of perl, and enabling warnings for
using it rarely catches any bugs, but considerably limits you in what you
can do, so uninitialised warnings are disabled.
.IP "\fImalloc\fR" 4
.IX Item "malloc"
Freeing something twice on the C level is a serious bug, usually causing
memory corruption. It often leads to side effects much later in the
program and there are no advantages to not reporting this, so malloc
warnings are fatal by default.
.PP
Unfortunately, there is no fine-grained warning control in perl, so often
whole groups of useful warnings had to be excluded because of a single
useless warning (for example, perl puts an arbitrary limit on the length
of text you can match with some regexes before emitting a warning, making
the whole \f(CW\*(C`regexp\*(C'\fR category useless).
.PP
What follows is a more thorough discussion of what this module does,
and why it does it, and what the advantages (and disadvantages) of this
approach are.
.SH "RATIONALE"
.IX Header "RATIONALE"
.IP "use utf8" 4
.IX Item "use utf8"
While it's not common sense to write your programs in \s-1UTF\-8,\s0 it's quickly
becoming the most common encoding, is the designated future default
encoding for perl sources, and the most convenient encoding available
(you can do really nice quoting tricks...). Experience has shown that our
programs were either all pure ascii or utf\-8, both of which will stay the
same.
.Sp
There are few drawbacks to enabling \s-1UTF\-8\s0 source code by default (mainly
some speed hits due to bugs in older versions of perl), so this module
enables \s-1UTF\-8\s0 source code encoding by default.
.IP "use strict qw(subs vars)" 4
.IX Item "use strict qw(subs vars)"
Using \f(CW\*(C`use strict\*(C'\fR is definitely common sense, but \f(CW\*(C`use strict
\&\*(Aqrefs\*(Aq\*(C'\fR definitely overshoots its usefulness. After almost two
decades of Perl hacking, we decided that it does more harm than being
useful. Specifically, constructs like these:
.Sp
.Vb 1
\&   @{ $var\->[0] }
.Ve
.Sp
Must be written like this (or similarly), when \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR is in
scope, and \f(CW$var\fR can legally be \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 1
\&   @{ $var\->[0] || [] }
.Ve
.Sp
This is annoying, and doesn't shield against obvious mistakes such as
using \f(CW""\fR, so one would even have to write (at least for the time
being):
.Sp
.Vb 1
\&   @{ defined $var\->[0] ? $var\->[0] : [] }
.Ve
.Sp
\&... which nobody with a bit of common sense would consider
writing: clear code is clearly something else.
.Sp
Curiously enough, sometimes perl is not so strict, as this works even with
\&\f(CW\*(C`use strict\*(C'\fR in scope:
.Sp
.Vb 1
\&   for (@{ $var\->[0] }) { ...
.Ve
.Sp
If that isn't hypocrisy! And all that from a mere program!
.IP "use feature qw(say state given ...)" 4
.IX Item "use feature qw(say state given ...)"
We found it annoying that we always have to enable extra features. If
something breaks because it didn't anticipate future changes, so be
it. 5.10 broke almost all our \s-1XS\s0 modules and nobody cared either (or at
least I know of nobody who really complained about gratuitous changes \-
as opposed to bugs).
.Sp
Few modules that are not actively maintained work with newer versions of
Perl, regardless of use feature or not, so a new major perl release means
changes to many modules \- new keywords are just the tip of the iceberg.
.Sp
If your code isn't alive, it's dead, Jim \- be an active maintainer.
.Sp
But nobody forces you to use those extra features in modules meant for
older versions of perl \- common::sense of course works there as well.
There is also an important other mode where having additional features by
default is useful: commandline hacks and internal use scripts: See \*(L"much
reduced typing\*(R", below.
.Sp
There is one notable exception: \f(CW\*(C`unicode_eval\*(C'\fR is not enabled by
default. In our opinion, \f(CW\*(C`use feature\*(C'\fR had one main effect \- newer perl
versions don't value backwards compatibility and the ability to write
modules for multiple perl versions much, after all, you can use feature.
.Sp
\&\f(CW\*(C`unicode_eval\*(C'\fR doesn't add a new feature, it breaks an existing function.
.IP "no warnings, but a lot of new errors" 4
.IX Item "no warnings, but a lot of new errors"
Ah, the dreaded warnings. Even worse, the horribly dreaded \f(CW\*(C`\-w\*(C'\fR
switch: Even though we don't care if other people use warnings (and
certainly there are useful ones), a lot of warnings simply go against the
spirit of Perl.
.Sp
Most prominently, the warnings related to \f(CW\*(C`undef\*(C'\fR. There is nothing wrong
with \f(CW\*(C`undef\*(C'\fR: it has well-defined semantics, it is useful, and spitting
out warnings you never asked for is just evil.
.Sp
The result was that every one of our modules did \f(CW\*(C`no warnings\*(C'\fR in the
past, to avoid somebody accidentally using and forcing his bad standards
on our code. Of course, this switched off all warnings, even the useful
ones. Not a good situation. Really, the \f(CW\*(C`\-w\*(C'\fR switch should only enable
warnings for the main program only.
.Sp
Funnily enough, perllexwarn explicitly mentions \f(CW\*(C`\-w\*(C'\fR (and not in a
favourable way, calling it outright \*(L"wrong\*(R"), but standard utilities, such
as prove, or MakeMaker when running \f(CW\*(C`make test\*(C'\fR, still enable them
blindly.
.Sp
For version 2 of common::sense, we finally sat down a few hours and went
through \fIevery single warning message\fR, identifying \- according to
common sense \- all the useful ones.
.Sp
This resulted in the rather impressive list in the \s-1SYNOPSIS.\s0 When we
weren't sure, we didn't include the warning, so the list might grow in
the future (we might have made a mistake, too, so the list might shrink
as well).
.Sp
Note the presence of \f(CW\*(C`FATAL\*(C'\fR in the list: we do not think that the
conditions caught by these warnings are worthy of a warning, we \fIinsist\fR
that they are worthy of \fIstopping\fR your program, \fIinstantly\fR. They are
\&\fIbugs\fR!
.Sp
Therefore we consider \f(CW\*(C`common::sense\*(C'\fR to be much stricter than \f(CW\*(C`use
warnings\*(C'\fR, which is good if you are into strict things (we are not,
actually, but these things tend to be subjective).
.Sp
After deciding on the list, we ran the module against all of our code that
uses \f(CW\*(C`common::sense\*(C'\fR (that is almost all of our code), and found only one
occurrence where one of them caused a problem: one of elmex's (unreleased)
modules contained:
.Sp
.Vb 1
\&   $fmt =~ s/([^\es\e[]*)\e[( [^\e]]* )\e]/\ex0$1\ex1$2\ex0/xgo;
.Ve
.Sp
We quickly agreed that indeed the code should be changed, even though it
happened to do the right thing when the warning was switched off.
.IP "much reduced typing" 4
.IX Item "much reduced typing"
Especially with version 2.0 of common::sense, the amount of boilerplate
code you need to add to get \fIthis\fR policy is daunting. Nobody would write
this out in throwaway scripts, commandline hacks or in quick internal-use
scripts.
.Sp
By using common::sense you get a defined set of policies (ours, but maybe
yours, too, if you accept them), and they are easy to apply to your
scripts: typing \f(CW\*(C`use common::sense;\*(C'\fR is even shorter than \f(CW\*(C`use warnings;
use strict; use feature ...\*(C'\fR.
.Sp
And you can immediately use the features of your installed perl, which
is more difficult in code you release, but not usually an issue for
internal-use code (downgrades of your production perl should be rare,
right?).
.IP "mucho reduced memory usage" 4
.IX Item "mucho reduced memory usage"
Just using all those pragmas mentioned in the \s-1SYNOPSIS\s0 together wastes
<blink>\fI\f(BI776\fI kilobytes\fR</blink> of precious memory in my perl, for
\&\fIevery single perl process using our code\fR, which on our machines, is a
lot. In comparison, this module only uses \fI\f(BIfour\fI\fR kilobytes (I even
had to write it out so it looks like more) of memory on the same platform.
.Sp
The money/time/effort/electricity invested in these gigabytes (probably
petabytes globally!) of wasted memory could easily save 42 trees, and a
kitten!
.Sp
Unfortunately, until everybody applies more common sense, there will still
often be modules that pull in the monster pragmas. But one can hope...
.SH "THERE IS NO 'no common::sense'!!!! !!!! !!"
.IX Header "THERE IS NO 'no common::sense'!!!! !!!! !!"
This module doesn't offer an unimport. First of all, it wastes even more
memory, second, and more importantly, who with even a bit of common sense
would want no common sense?
.SH "STABILITY AND FUTURE VERSIONS"
.IX Header "STABILITY AND FUTURE VERSIONS"
Future versions might change just about everything in this module. We
might test our modules and upload new ones working with newer versions of
this module, and leave you standing in the rain because we didn't tell
you. In fact, we did so when switching from 1.0 to 2.0, which enabled gobs
of warnings, and made them \s-1FATAL\s0 on top.
.PP
Maybe we will load some nifty modules that try to emulate \f(CW\*(C`say\*(C'\fR or so
with perls older than 5.10 (this module, of course, should work with older
perl versions \- supporting 5.8 for example is just common sense at this
time. Maybe not in the future, but of course you can trust our common
sense to be consistent with, uhm, our opinion).
.SH "WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE"
.IX Header "WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE"
apeiron
.PP
.Vb 2
\&   "... wow"
\&   "I hope common::sense is a joke."
.Ve
.PP
crab
.PP
.Vb 1
\&   "i wonder how it would be if joerg schilling wrote perl modules."
.Ve
.PP
Adam Kennedy
.PP
.Vb 3
\&   "Very interesting, efficient, and potentially something I\*(Aqd use all the time."
\&   [...]
\&   "So no common::sense for me, alas."
.Ve
.PP
H.Merijn Brand
.PP
.Vb 1
\&   "Just one more reason to drop JSON::XS from my distribution list"
.Ve
.PP
Pista Palo
.PP
.Vb 1
\&   "Something in short supply these days..."
.Ve
.PP
Steffen Schwigon
.PP
.Vb 4
\&   "This module is quite for sure *not* just a repetition of all the other
\&   \*(Aquse strict, use warnings\*(Aq\-approaches, and it\*(Aqs also not the opposite.
\&   [...] And for its chosen middle\-way it\*(Aqs also not the worst name ever.
\&   And everything is documented."
.Ve
.PP
\&\s-1BKB\s0
.PP
.Vb 2
\&   "[Deleted \- thanks to Steffen Schwigon for pointing out this review was
\&   in error.]"
.Ve
.PP
Somni
.PP
.Vb 3
\&   "the arrogance of the guy"
\&   "I swear he tacked somenoe else\*(Aqs name onto the module
\&   just so he could use the royal \*(Aqwe\*(Aq in the documentation"
.Ve
.PP
Anonymous Monk
.PP
.Vb 1
\&   "You just gotta love this thing, its got META.json!!!"
.Ve
.PP
dngor
.PP
.Vb 2
\&   "Heh.  \*(Aq"<elmex at ta\-sa.org>"\*(Aq  The quotes are semantic
\&   distancing from that e\-mail address."
.Ve
.PP
Jerad Pierce
.PP
.Vb 3
\&   "Awful name (not a proper pragma), and the SYNOPSIS doesn\*(Aqt tell you
\&   anything either. Nor is it clear what features have to do with "common
\&   sense" or discipline."
.Ve
.PP
acme
.PP
.Vb 1
\&   "THERE IS NO \*(Aqno common::sense\*(Aq!!!! !!!! !!"
.Ve
.PP
apeiron (meta-comment about us commenting^Wquoting his comment)
.PP
.Vb 1
\&   "How about quoting this: get a clue, you fucktarded amoeba."
.Ve
.PP
quanth
.PP
.Vb 2
\&   "common sense is beautiful, json::xs is fast, Anyevent, EV are fast and
\&   furious. I love mlehmannware ;)"
.Ve
.PP
apeiron
.PP
.Vb 3
\&   "... it\*(Aqs mlehmann\*(Aqs view of what common sense is. His view of common
\&   sense is certainly uncommon, insofar as anyone with a clue disagrees
\&   with him."
.Ve
.PP
apeiron (another meta-comment)
.PP
.Vb 1
\&   "apeiron wonders if his little informant is here to steal more quotes"
.Ve
.PP
ew73
.PP
.Vb 3
\&   "... I never got past the SYNOPSIS before calling it shit."
\&   [...]
\&   How come no one ever quotes me. :("
.Ve
.PP
chip (not willing to explain his cryptic questions about links in Changes files)
.PP
.Vb 3
\&   "I\*(Aqm willing to ask the question I\*(Aqve asked. I\*(Aqm not willing to go
\&   through the whole dance you apparently have choreographed. Either
\&   answer the completely obvious question, or tell me to fuck off again."
.Ve
.SH "FREQUENTLY ASKED QUESTIONS"
.IX Header "FREQUENTLY ASKED QUESTIONS"
Or frequently-come-up confusions.
.IP "Is this module meant to be serious?" 4
.IX Item "Is this module meant to be serious?"
Yes, we would have put it under the \f(CW\*(C`Acme::\*(C'\fR namespace otherwise.
.IP "But the manpage is written in a funny/stupid/... way?" 4
.IX Item "But the manpage is written in a funny/stupid/... way?"
This was meant to make it clear that our common sense is a subjective
thing and other people can use their own notions, taking the steam out
of anybody who might be offended (as some people are always offended no
matter what you do).
.Sp
This was a failure.
.Sp
But we hope the manpage still is somewhat entertaining even though it
explains boring rationale.
.IP "Why do you impose your conventions on my code?" 4
.IX Item "Why do you impose your conventions on my code?"
For some reason people keep thinking that \f(CW\*(C`common::sense\*(C'\fR imposes
process-wide limits, even though the \s-1SYNOPSIS\s0 makes it clear that it works
like other similar modules \- i.e. only within the scope that \f(CW\*(C`use\*(C'\fRs them.
.Sp
So, no, we don't \- nobody is forced to use this module, and using a module
that relies on common::sense does not impose anything on you.
.IP "Why do you think only your notion of common::sense is valid?" 4
.IX Item "Why do you think only your notion of common::sense is valid?"
Well, we don't, and have clearly written this in the documentation to
every single release. We were just faster than anybody else w.r.t. to
grabbing the namespace.
.IP "But everybody knows that you have to use strict and use warnings, why do you disable them?" 4
.IX Item "But everybody knows that you have to use strict and use warnings, why do you disable them?"
Well, we don't do this either \- we selectively disagree with the
usefulness of some warnings over others. This module is aimed at
experienced Perl programmers, not people migrating from other languages
who might be surprised about stuff such as \f(CW\*(C`undef\*(C'\fR. On the other hand,
this does not exclude the usefulness of this module for total newbies, due
to its strictness in enforcing policy, while at the same time not limiting
the expressive power of perl.
.Sp
This module is considerably \fImore\fR strict than the canonical \f(CW\*(C`use
strict; use warnings\*(C'\fR, as it makes all its warnings fatal in nature, so
you can not get away with as many things as with the canonical approach.
.Sp
This was not implemented in version 1.0 because of the daunting number
of warning categories and the difficulty in getting exactly the set of
warnings you wish (i.e. look at the \s-1SYNOPSIS\s0 in how complicated it is to
get a specific set of warnings \- it is not reasonable to put this into
every module, the maintenance effort would be enormous).
.ie n .IP "But many modules ""use strict"" or ""use warnings"", so the memory savings do not apply?" 4
.el .IP "But many modules \f(CWuse strict\fR or \f(CWuse warnings\fR, so the memory savings do not apply?" 4
.IX Item "But many modules use strict or use warnings, so the memory savings do not apply?"
I suddenly feel sad...
.Sp
But yes, that's true. Fortunately \f(CW\*(C`common::sense\*(C'\fR still uses only a
miniscule amount of \s-1RAM.\s0
.IP "But it adds another dependency to your modules!" 4
.IX Item "But it adds another dependency to your modules!"
It's a fact, yeah. But it's trivial to install, most popular modules have
many more dependencies. And we consider dependencies a good thing \- it
leads to better APIs, more thought about interworking of modules and so
on.
.IP "Why do you use \s-1JSON\s0 and not \s-1YAML\s0 for your \s-1META\s0.yml?" 4
.IX Item "Why do you use JSON and not YAML for your META.yml?"
This is not true \- \s-1YAML\s0 supports a large subset of \s-1JSON,\s0 and this subset
is what \s-1META\s0.yml is written in, so it would be correct to say \*(L"the
\&\s-1META\s0.yml is written in a common subset of \s-1YAML\s0 and \s-1JSON\*(R".\s0
.Sp
The \s-1META\s0.yml follows the \s-1YAML, JSON\s0 and \s-1META\s0.yml specifications, and is
correctly parsed by \s-1CPAN,\s0 so if you have trouble with it, the problem is
likely on your side.
.IP "But! But!" 4
.IX Item "But! But!"
Yeah, we know.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
\&
\& Robin Redeker, "<elmex at ta\-sa.org>".
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 25:" 4
.IX Item "Around line 25:"
Non-ASCII character seen before =encoding in '“Nothing'. Assuming \s-1UTF\-8\s0
