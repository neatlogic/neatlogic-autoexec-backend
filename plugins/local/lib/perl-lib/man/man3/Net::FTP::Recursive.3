.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Recursive 3"
.TH Recursive 3 "2021-05-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::FTP::Recursive \- Recursive FTP Client class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::FTP::Recursive;
\&
\&    $ftp = Net::FTP::Recursive\->new("some.host.name", Debug => 0);
\&    $ftp\->login("anonymous",\*(Aqme@here.there\*(Aq);
\&    $ftp\->cwd(\*(Aq/pub\*(Aq);
\&    $ftp\->rget( ParseSub => \e&yoursub );
\&    $ftp\->quit;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::FTP::Recursive\*(C'\fR is a class built on top of the Net::FTP package
that implements recursive get and put methods for the retrieval and
sending of entire directory structures.
.PP
This module's default behavior is such that the remote ftp
server should understand the \*(L"dir\*(R" command and return
UNIX-style directory listings.  If you'd like to provide
your own function for parsing the data retrieved from this
command (in case the ftp server does not understand the
\&\*(L"dir\*(R" command), all you need do is provide a function to one
of the Recursive method calls.  This function will take the
output from the \*(L"dir\*(R" command (as a list of lines) and
should return a list of Net::FTP::Recursive::File objects.
This module is described below.
.PP
All of the methods also take an optional \f(CW\*(C`KeepFirstLine\*(C'\fR
argument which is passed on to the default parsing routine.
This argument supresses the discarding of the first line of
output from the dir command.  wuftpd servers provide a
total line, the default behavior is to throw that total line
away.  If yours does not provide the total line,
\&\f(CW\*(C`KeepFirstLine\*(C'\fR is for you.  This argument is used like the
others, you provide the argument as the key in a key value
pair where the value is true (ie, KeepFirstLine => 1).
.PP
When the \f(CW\*(C`Debug\*(C'\fR flag is used with the \f(CW\*(C`Net::FTP\*(C'\fR object, the
\&\f(CW\*(C`Recursive\*(C'\fR package will print some messages to \f(CW\*(C`STDERR\*(C'\fR.
.PP
All of the methods should return false ('') if they are
successful, and a true value if unsuccessful.  The true
value will be a string of the concatenations of all of the
error messages (with newlines).  Note that this might be the
opposite of the more intuitive return code.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new (\s-1HOST\s0 [,OPTIONS])" 4
.IX Item "new (HOST [,OPTIONS])"
A call to the new method to create a new
\&\f(CW\*(C`Net::FTP::Recursive\*(C'\fR object just calls the \f(CW\*(C`Net::FTP\*(C'\fR new
method.  Please refer to the \f(CW\*(C`Net::FTP\*(C'\fR documentation for
more information.
.SH "METHODS"
.IX Header "METHODS"
.IP "rget ( [ParseSub =>\e&yoursub] [,FlattenTree => 1] [,RemoveRemoteFiles => 1] )" 4
.IX Item "rget ( [ParseSub =>&yoursub] [,FlattenTree => 1] [,RemoveRemoteFiles => 1] )"
The recursive get method call.  This will recursively
retrieve the ftp object's current working directory and its
contents into the local current working directory.
.Sp
This will also take an optional argument that will control what
happens when a symbolic link is encountered on the ftp
server.  The default is to ignore the symlink, but you can
control the behavior by passing one of these arguments to
the rget call (ie, \f(CW$ftp\fR\->rget(SymlinkIgnore => 1)):
.RS 4
.IP "SymlinkIgnore \- disregards symlinks (default)" 12
.IX Item "SymlinkIgnore - disregards symlinks (default)"
.PD 0
.ie n .IP "SymlinkCopy \- copies the link target from the server to the client (if accessible).  Works on files other than a directory.  For directories, see the ""SymlinkFollow"" option." 12
.el .IP "SymlinkCopy \- copies the link target from the server to the client (if accessible).  Works on files other than a directory.  For directories, see the \f(CWSymlinkFollow\fR option." 12
.IX Item "SymlinkCopy - copies the link target from the server to the client (if accessible). Works on files other than a directory. For directories, see the SymlinkFollow option."
.IP "SymlinkFollow \- will recurse into a symlink if it points to a directory.  This option may be given along with one of the others above." 12
.IX Item "SymlinkFollow - will recurse into a symlink if it points to a directory. This option may be given along with one of the others above."
.IP "SymlinkLink \- creates the link on the client.  This is superceded by each of the previous options." 12
.IX Item "SymlinkLink - creates the link on the client. This is superceded by each of the previous options."
.RE
.RS 4
.PD
.Sp
The \f(CW\*(C`SymlinkFollow\*(C'\fR option, as of v1.6, does more
sophisticated handling of symlinks.  It will detect and
avoid cycles, on all client platforms.  Also, if on a \s-1UNIX\s0
(tm) platform, if it detects a cycle, it will create a
symlink to the location where it downloaded the directory
(or will download it subsequently, if it is in the subtree
under where the recursing started).  On Windows, it will
call symlink just as on \s-1UNIX\s0 (tm), but that's probably not
gonna do much for you.  :)
.Sp
The \f(CW\*(C`FlattenTree\*(C'\fR optional argument will retrieve all of
the files from the remote directory structure and place them
in the current local directory.  This option will resolve
filename conflicts by retrieving files with the same name
and renaming them in a \*(L"$filename.$i\*(R" fashion, where \f(CW$i\fR is
the number of times it has retrieved a file with that name.
.Sp
The optional \f(CW\*(C`RemoveRemoteFiles\*(C'\fR argument to the function
will allow the client to delete files from the server after
it retrieves them.  The default behavior is to leave all
files and directories intact.  The default behavior for this
is to check the return code from the \s-1FTP GET\s0 call.  If that
is successful, it will delete the file.  \f(CW\*(C`CheckSizes\*(C'\fR is an
additional argument that will check the filesize of the
local file against the file size of the remote file, and
only if they are the same will it delete the file.  You must
l provide the \f(CW\*(C`RemoveRemoteFiles\*(C'\fR option in order for
option to affect the behavior of the code.  This check will
only be performed for regular files, not directories or
symlinks.
.Sp
For the v1.6 release, I have also added some additional
functionality that will allow the client to be more specific
in choosing those files that are retrieved.  All of these
options take a regex object (made using the \f(CW\*(C`qr\*(C'\fR operator)
as their value.  You may choose to use one or more of these
options, they are applied in the order that they are
listed.  They are:
.IP "MatchAll \- Will process file that matches this regex, regardless of whether it is a plainish file, directory, or a symlink.  This behavior can be overridden with the previous options." 4
.IX Item "MatchAll - Will process file that matches this regex, regardless of whether it is a plainish file, directory, or a symlink. This behavior can be overridden with the previous options."
.PD 0
.IP "OmitAll \- Do not process file that matches this regex. Also may be overridden with the previous options." 4
.IX Item "OmitAll - Do not process file that matches this regex. Also may be overridden with the previous options."
.IP "MatchFiles \- Only transfer plainish (not a directory or a symlink) files that match this pattern." 4
.IX Item "MatchFiles - Only transfer plainish (not a directory or a symlink) files that match this pattern."
.IP "OmitFiles \- Omit those plainish files that match this pattern." 4
.IX Item "OmitFiles - Omit those plainish files that match this pattern."
.IP "MatchDirs \- Only recurse into directories that match this pattern." 4
.IX Item "MatchDirs - Only recurse into directories that match this pattern."
.IP "OmitDirs \- Do not recurse into directories that match this pattern." 4
.IX Item "OmitDirs - Do not recurse into directories that match this pattern."
.IP "MatchLinks \- Only deal with those links that match this pattern (based on your symlink option, above)." 4
.IX Item "MatchLinks - Only deal with those links that match this pattern (based on your symlink option, above)."
.IP "OmitLinks \- Do not deal with links that match this pattern." 4
.IX Item "OmitLinks - Do not deal with links that match this pattern."
.RE
.RS 4
.PD
.Sp
Currently, some of the added functionality given to the rget method
is not implemented for the rput method.
.RE
.IP "rput ( [FlattenTree => 1] [,RemoveLocalFiles => 1] )" 4
.IX Item "rput ( [FlattenTree => 1] [,RemoveLocalFiles => 1] )"
The recursive put method call.  This will recursively send the local
current working directory and its contents to the ftp object's current
working directory.
.Sp
This will take an optional argument that will control what
happens when a symbolic link is encountered on the ftp
server.  The default is to ignore the symlink, but you can
control the behavior by passing one of these arguments to
the rput call (ie, \f(CW$ftp\fR\->rput(SymlinkIgnore => 1)):
.RS 4
.IP "SymlinkIgnore \- disregards symlinks" 4
.IX Item "SymlinkIgnore - disregards symlinks"
.PD 0
.IP "SymlinkCopy \- will copy the link target from the client to the server." 4
.IX Item "SymlinkCopy - will copy the link target from the client to the server."
.IP "SymLinkFollow \- will recurse into a symlink if it points to a directory.  This does not do cycle checking, use with \s-1EXTREME\s0 caution.  This option may be given along with one of the others above." 4
.IX Item "SymLinkFollow - will recurse into a symlink if it points to a directory. This does not do cycle checking, use with EXTREME caution. This option may be given along with one of the others above."
.RE
.RS 4
.PD
.Sp
The \f(CW\*(C`FlattenTree\*(C'\fR optional argument will send all of the
files from the local directory structure and place them in
the current remote directory.  This option will resolve
filename conflicts by sending files with the same name
and renaming them in a \*(L"$filename.$i\*(R" fashion, where \f(CW$i\fR is
the number of times it has retrieved a file with that name.
.Sp
The optional \f(CW\*(C`RemoveLocalFiles\*(C'\fR argument to the function
will allow the client to delete files from the client after
it sends them.  The default behavior is to leave all files
and directories intact.  This option is very unintelligent,
it does a delete no matter what.
.Sp
As of v1.11, there is a \f(CW\*(C`CheckSizes\*(C'\fR option that can be
used in conjunction with the \f(CW\*(C`RemoveLocalFiles\*(C'\fR that will
check the filesize of the file locally against the remote
filesize and only delete if the two are the same.  This
option only affects regular files, not symlinks or
directories.  This option does not affect the normal
behavior of \f(CW\*(C`RemoveRemoteFiles\*(C'\fR option (ie, it will try to
delete symlinks and directories no matter what).
.RE
.ie n .IP "rdir ( Filehandle => $fh [, FilenameOnly => 1 [, PrintType => 1] ] [, ParseSub => \e&yoursub ] )" 4
.el .IP "rdir ( Filehandle => \f(CW$fh\fR [, FilenameOnly => 1 [, PrintType => 1] ] [, ParseSub => \e&yoursub ] )" 4
.IX Item "rdir ( Filehandle => $fh [, FilenameOnly => 1 [, PrintType => 1] ] [, ParseSub => &yoursub ] )"
The recursive dir method call.  This will recursively retrieve
directory contents from the server in a breadth-first fashion.
.Sp
The method needs to be passed a filehandle to print to.  The method
call just does a \f(CW\*(C`print $fh\*(C'\fR, so as long as this call can succeed
with whatever you pass to this function, it'll work.
.Sp
The second, optional argument, is to retrieve only the filenames
(including path information).  The default is to display all of the
information returned from the \f(CW$ftp\fR\-dir call.
.Sp
This method \fB\s-1WILL\s0\fR follow symlinks.  It has the same basic
cycle-checking code that is in rget, so it should not infinitely
loop.
.Sp
The \f(CW\*(C`PrintType\*(C'\fR argument will print either an 's', an 'f',
or a 'd' after the filename when printed, to tell you what
kind of file it thinks it is.  This argument must be given
along with the FilenameOnly argument.  (Submitted by Arturas
Slajus).
.ie n .IP "rls ( Filehandle => $fh [, PrintType => 1 ] [, ParseSub => \e&yoursub] )" 4
.el .IP "rls ( Filehandle => \f(CW$fh\fR [, PrintType => 1 ] [, ParseSub => \e&yoursub] )" 4
.IX Item "rls ( Filehandle => $fh [, PrintType => 1 ] [, ParseSub => &yoursub] )"
The recursive ls method call.  This will recursively
retrieve directory contents from the server in a
breadth-first fashion.  This is equivalent to calling
\&\f(CW\*(C`$ftp\-\*(C'\fRrdir( Filehandle => \f(CW$fh\fR, FilenameOnly => 1 )>.
.Sp
There is also a new argument to this, the \f(CW\*(C`PrintType\*(C'\fR
referenced in the rdir part of the documentation.  For rls,
the FilenameOnly argument is automatically passed.
.IP "rdelete ( [ ParseSub => \e&yoursub ] )" 4
.IX Item "rdelete ( [ ParseSub => &yoursub ] )"
The recursive delete method call.  This will recursively
delete everything in the directory structure.  This
disregards the \f(CW\*(C`SymlinkFollow\*(C'\fR option and does not recurse
into symlinks that refer to directories.
.SH "Net::FTP::Recursive::File"
.IX Header "Net::FTP::Recursive::File"
This is a helper class that encapsulates the data
representing one file in a directory listing.
.SH "METHODS"
.IX Header "METHODS"
.IP "new ( )" 4
.IX Item "new ( )"
This method creates the File object.  It should be passed
several parameters.  It should always be passed:
.RS 4
.ie n .IP "OriginalLine => $line" 4
.el .IP "OriginalLine => \f(CW$line\fR" 4
.IX Item "OriginalLine => $line"
.PD 0
.IP "Fields => \e@fields" 4
.IX Item "Fields => @fields"
.RE
.RS 4
.PD
.Sp
And it should also be passed at least one (but only one a
true value) of:
.IP "IsPlainFile => 1" 4
.IX Item "IsPlainFile => 1"
.PD 0
.IP "IsDirectory => 1" 4
.IX Item "IsDirectory => 1"
.IP "IsSymlink => 1" 4
.IX Item "IsSymlink => 1"
.RE
.RS 4
.PD
.Sp
OriginalLine should provide the original line from the
output of a directory listing.
.Sp
Fields should provide an 8 element list that supplies
information about the file.  The fields, in order, should
be:
.IP "Permissions" 4
.IX Item "Permissions"
.PD 0
.IP "Link Count" 4
.IX Item "Link Count"
.IP "User Owner" 4
.IX Item "User Owner"
.IP "Group Owner" 4
.IX Item "Group Owner"
.IP "Size" 4
.IX Item "Size"
.IP "Last Modification Date/Time" 4
.IX Item "Last Modification Date/Time"
.IP "Filename" 4
.IX Item "Filename"
.IP "Link Target" 4
.IX Item "Link Target"
.RE
.RS 4
.PD
.Sp
The \f(CW\*(C`IsPlainFile\*(C'\fR, \f(CW\*(C`IsDirectory\*(C'\fR, and \f(CW\*(C`IsSymlink\*(C'\fR fields
need to be supplied so that for the output on your
particular system, your code (in the ParseSub) can determine
which type of file it is so that the Recursive calls can
take the appropriate action for that file.  Only one of
these three fields should be set to a \*(L"true\*(R" value.
.RE
.SH "TODO LIST"
.IX Header "TODO LIST"
.IP "Allow for formats to be given for output on rdir/rls." 4
.IX Item "Allow for formats to be given for output on rdir/rls."
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
When reporting bugs, please provide as much information as possible.
A script that exhibits the bug would also be helpful, as well as
output with the \*(L"Debug => 1\*(R" flag turned on in the \s-1FTP\s0 object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeremiah Lee <texasjdl_AT_yahoo.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::FTP
.PP
Net::Cmd
.PP
\&\fBftp\fR\|(1), \fBftpd\fR\|(8), \s-1RFC 959\s0
.SH "CREDITS"
.IX Header "CREDITS"
Thanks to everyone who has submitted bugs over the years.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2009 Jeremiah Lee.
.PP
This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
