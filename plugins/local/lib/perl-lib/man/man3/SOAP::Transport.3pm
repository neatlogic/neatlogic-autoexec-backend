.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SOAP::Transport 3"
.TH SOAP::Transport 3 "2019-10-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SOAP::Transport \- an abstract class extended by more specialized transport modules
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects of the SOAP::Transport class manage two roles: they manage both the parameters related to transport as set through the containing SOAP::Lite object, and they abstract the selection and loading of an appropriate transport module. This is done with an \s-1AUTOLOAD\s0 function within the class that intercepts all methods beyond the two defined next and reroutes them to the underlying transport implementation code.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&    $trans = SOAP::Transport\->new;
.Ve
.Sp
This is the constructor, which isn't usually called by an application directly. An application can use this to create a fresh new SOAP::Transport object, which may be installed using the SOAP::Lite\->transport method defined earlier. No arguments are recognized.
.IP "proxy(optional \s-1URL\s0 string)" 4
.IX Item "proxy(optional URL string)"
.Vb 1
\&    $trans\->proxy(\*(Aqhttp://www.blackperl.com/SOAP\*(Aq);
.Ve
.Sp
Gets or sets the proxy (endpoint). This method must be called before any other methods are called. The proper transport code is loaded based on the scheme specified by the \s-1URL\s0 itself (http, jabber, etc.). Until this method is called the first time with a \s-1URL\s0 string, the underlying code has yet to be loaded, and the methods aren't available. When getting the current proxy (calling with no parameters), the returned value is a reference to the client object created from the protocol class that matched the endpoint, not the endpoint itself.
.SH "SOAP Transport Sub-Classes"
.IX Header "SOAP Transport Sub-Classes"
Because the bulk of the work is done within the \f(CW\*(C`SOAP::Lite\*(C'\fR module itself, many of the transport-level modules are very simple in their implementations. Transport modules are expected to define both client and server classes within their files. If a module defines only one of the types, it is assumed that the transport protocol itself supports only that side of the conversation. An example is SOAP::Transport::FTP, which provides only a \f(CW\*(C`SOAP::Transport::FTP::Client\*(C'\fR class.
.PP
\&\*(L"SOAP::Transport::FTP\*(R" \- Client class only
.PP
\&\*(L"SOAP::Transport::HTTP\*(R" \- Client, and server classes for \s-1CGI, FCGI,\s0 Daemon and mod_perl
.PP
\&\*(L"SOAP::Transport::IO\*(R" \- Server class only
.PP
\&\*(L"SOAP::Transport::JABBER\*(R" \- Server and Client classes
.PP
\&\*(L"SOAP::Transport::LOCAL\*(R" \- Client class only
.PP
\&\*(L"SOAP::Transport::MAILTO\*(R" \- Client class only
.PP
\&\*(L"SOAP::Transport::MQ\*(R" \- Server and Client classes
.PP
\&\*(L"SOAP::Transport::POP3\*(R" \- Server class only
.PP
\&\*(L"SOAP::Transport::TCP\*(R" \- Server and Client classes
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
Each SOAP::Transport sub-class is expected to define (or inherit, if it is subclassing another transport class) at least two methods. Any newly developed transport classes are also expected to adhere to this interface. Clients are expected to implement the \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`send_receive\*(C'\fR methods, and servers are expected to implement the \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`handle\*(C'\fR methods. Here they are:
.IP "new(optional key/value pairs)" 4
.IX Item "new(optional key/value pairs)"
.Vb 1
\&    $object = $class\->new(%params);
.Ve
.Sp
Creates a new object instance and returns it. Like the constructors for both \f(CW\*(C`SOAP::Lite\*(C'\fR and SOAP::Server classes, all arguments passed in are treated as key/value pairs, where the key is expected to be one of the methods the class supports, and the value is the argument (or list reference of arguments) to the method.
.IP "send_receive(key/value pairs)" 4
.IX Item "send_receive(key/value pairs)"
.Vb 1
\&    $client\->send_recieve(%hash_table);
.Ve
.Sp
(Required for client classes only) When the SOAP::Lite objects attempt to send out requests, the means for doing so is to attempt to call this method on the object held within the SOAP::Transport object contained within the client itself. All clients are expected to provide this, and the call to this method always passes four values for the hash keys:
.RS 4
.IP "action" 4
.IX Item "action"
The \s-1URI\s0 specifying the action being performed, usually the result from the on_action hook on the client object.
.IP "encoding" 4
.IX Item "encoding"
The \s-1URI\s0 of the encoding scheme that governs the message being sent.
.IP "endpoint" 4
.IX Item "endpoint"
The \s-1URI\s0 specifying the endpoint to which the message is being sent.
.IP "envelope" 4
.IX Item "envelope"
The \s-1XML\s0 content of the message to be sent. It is generally the return value of the envelope method from the SOAP::Serializer object instance that the client object maintains.
.IP "parts" 4
.IX Item "parts"
Attachments to add to the request. Currently this only supports an array of MIME::Entity objects, but in theory could support attachments of any format.
.RE
.RS 4
.RE
.IP "handle" 4
.IX Item "handle"
.Vb 1
\&    $server\->handle;
.Ve
.Sp
(Required for server classes only.) This method is the central point for the various server classes to provide an interface to handling requests. The exact set and nature of parameters generally varies based on the classes themselves.
.SS "SOAP::Transport::HTTP"
.IX Subsection "SOAP::Transport::HTTP"
The most commonly used transport module is the \s-1HTTP\s0 implementation. This is loaded whenever an endpoint is given that starts with the characters, http:// or https://. This is also the most involved of the transport modules, defining not only a client class but several different server classes as well.
.PP
\fI\s-1HTTP PROXY SETTINGS\s0\fR
.IX Subsection "HTTP PROXY SETTINGS"
.PP
Because \f(CW\*(C`SOAP::Client\*(C'\fR inherits from \f(CW\*(C`LWP::UserAgent\*(C'\fR, you can use any of \f(CW\*(C`LWP::UserAgent\*(C'\fR's proxy settings. For example:
.PP
.Vb 2
\&   SOAP::Lite\->proxy("http://endpoint.server/",
\&                     proxy => ["http" => "http://my.proxy.server"]);
.Ve
.PP
or
.PP
.Vb 1
\&   $soap\->transport\->proxy("http" => "http://my.proxy.server");
.Ve
.PP
The above code samples should specify a proxy server for you. And should you use \f(CW\*(C`HTTP_proxy_user\*(C'\fR
and \f(CW\*(C`HTTP_proxy_pass\*(C'\fR for proxy authorization, \f(CW\*(C`SOAP::Lite\*(C'\fR will handle it properly.
.PP
\fI\s-1HTTP BASIC AUTHENTICATION\s0\fR
.IX Subsection "HTTP BASIC AUTHENTICATION"
.PP
\&\s-1HTTP\s0 Basic authentication is accomplished by overriding the get_basic_credentials subroutine in \f(CW\*(C`LWP::UserAgent\*(C'\fR (which \f(CW\*(C`SOAP::Transport::HTTP::Client\*(C'\fR is a subclass):
.PP
.Vb 5
\&  BEGIN {
\&    sub SOAP::Transport::HTTP::Client::get_basic_credentials {
\&      return \*(Aqusername\*(Aq => \*(Aqpassword\*(Aq;
\&    }
\&  }
.Ve
.PP
\fICOOKIE-BASED \s-1AUTHENTICATION\s0\fR
.IX Subsection "COOKIE-BASED AUTHENTICATION"
.PP
.Vb 5
\&    use HTTP::Cookies;
\&    my $cookies = HTTP::Cookies\->new(ignore_discard => 1);
\&    # you may also add \*(Aqfile\*(Aq if you want to keep them between sessions
\&    my $soap = SOAP::Lite\->proxy(\*(Aqhttp://localhost/\*(Aq);
\&    $soap\->transport\->cookie_jar($cookies);
.Ve
.PP
Or, alternatively, you can do the above on a single line:
.PP
.Vb 2
\&  $soap\->proxy(\*(Aqhttp://localhost/\*(Aq,
\&               cookie_jar => HTTP::Cookies\->new(ignore_discard => 1));
.Ve
.PP
Cookies will be taken from the response and provided to the request. You may access and manipulate cookies received, as well as add cookies of your own by using the \f(CW\*(C`HTTP::Cookies\*(C'\fR interfaces.
.PP
\fI\s-1SSL CERTIFICATE AUTHENTICATION\s0\fR
.IX Subsection "SSL CERTIFICATE AUTHENTICATION"
.PP
The default \s-1SSL\s0 implementation for the \s-1HTTP\s0 client library LWP::UserAgent used by SOAP::Lite is IO::Socket::SSL.
.PP
To enable certificate based authentication, you'll have to pass your certificate and key as additional options to the
\&\fIproxy()\fR method like this:
.PP
.Vb 4
\&    $soap\->proxy( $url, ssl_opts => {
\&        SSL_cert_file => \*(Aqclient\-cert.pem\*(Aq,
\&        SSL_key_file  => \*(Aqclient\-key.pem\*(Aq
\&    });
.Ve
.PP
Or you can set them later like this:
.PP
.Vb 4
\&    $soap\->transport\->ssl_opts(
\&        SSL_cert_file => \*(Aqclient\-cert.pem\*(Aq,
\&        SSL_key_file  => \*(Aqclient\-key.pem\*(Aq
\&    );
.Ve
.PP
If you're using Crypt::SSLeay, the following applies:
.PP
To get certificate authentication working you need to set three environment variables: \f(CW\*(C`HTTPS_CERT_FILE\*(C'\fR, \f(CW\*(C`HTTPS_KEY_FILE\*(C'\fR, and optionally \f(CW\*(C`HTTPS_CERT_PASS\*(C'\fR. This can be done either through the command line, or directly within your Perl script using the \f(CW$ENV\fR variable:
.PP
.Vb 2
\&  $ENV{HTTPS_CERT_FILE} = \*(Aqclient\-cert.pem\*(Aq;
\&  $ENV{HTTPS_KEY_FILE}  = \*(Aqclient\-key.pem\*(Aq;
.Ve
.PP
These settings are referenced by \f(CW\*(C`Crypt::SSLeay\*(C'\fR. Other options (e.g. \s-1CA\s0 peer verification) can be specified in a similar way. See Crypt::SSLeay documentation for more information.
.PP
Please note that you probably should not be using Crypt::SSLeay because it does not perform hostname verification; LWP::UserAgent uses IO::Socket::SSL by default. See also <https://metacpan.org/pod/Crypt::SSLeay#DO\-YOU\-NEED\-Crypt::SSLeay>.
.PP
Those who would like to use encrypted keys may find the following thread in the SOAP::Lite newsgroup helpful:
.PP
http://groups.yahoo.com/group/soaplite/message/729
.PP
\fI\s-1COMPRESSION\s0\fR
.IX Subsection "COMPRESSION"
.PP
SOAP::Lite provides you with the option for enabling compression over the wire using \s-1HTTP \s0\fIonly\fR in both the server and client contexts, provided that you have Compress::Zlib installed. Compression and decompression is done transparently to your application.
.PP
A server will respond with an encoded/compressed message only if the client has asserted that it can accept it (indicated by client sending an \f(CW\*(C`Accept\-Encoding\*(C'\fR \s-1HTTP\s0 header with a 'deflate' or '*' value).
.PP
\&\f(CW\*(C`SOAP::Lite\*(C'\fR clients all have fallback logic implemented so that if a server doesn't understand the specified encoding (i.e. \*(L"Content-Encoding: deflate\*(R") and returns the proper \s-1HTTP\s0 status code (415 \s-1NOT ACCEPTABLE\s0), the client will repeat the request without using encoding/compression. The client will then store this server in a per-session cache, so that all subsequent requests to that server will be transmitted without encoding.
.PP
Compression is enabled on the client side by specifying the \f(CW\*(C`compress_threshold\*(C'\fR option, and if the size of the current request exceeds that threshold.
.PP
\&\fBClient Code Sample\fR
.PP
.Vb 5
\&  print SOAP::Lite
\&    \->uri(\*(Aqhttp://localhost/My/Parameters\*(Aq)
\&    \->proxy(\*(Aqhttp://localhost/\*(Aq, options => {compress_threshold => 10000})
\&    \->echo(1 x 10000)
\&    \->result;
.Ve
.PP
Servers will respond with a compressed message if the \f(CW\*(C`compress_threshold\*(C'\fR option has been specified, if the size of the current response exceeds that threshold, and if the calling client transmitted the proper \f(CW\*(C`Accept\-Encoding\*(C'\fR \s-1HTTP\s0 Header.
.PP
\&\fBServer Code Sample\fR
.PP
.Vb 4
\&  my $server = SOAP::Transport::HTTP::CGI
\&    \->dispatch_to(\*(AqMy::Parameters\*(Aq)
\&    \->options({compress_threshold => 10000})
\&    \->handle;
.Ve
.PP
See also: Compress::Zlib
.PP
\fISOAP::Transport::HTTP::Client\fR
.IX Subsection "SOAP::Transport::HTTP::Client"
.PP
Inherits from: SOAP::Client, LWP::UserAgent (from the \s-1LWP\s0 package).
.PP
With this class, clients are able to use \s-1HTTP\s0 for sending messages. This class provides just the basic new and send_receive methods. Objects of this class understand the compress_threshold option and use it if the server being communicated to also understands it.
.PP
\s-1CHANGING THE DEFAULT USERAGENT CLASS\s0
.IX Subsection "CHANGING THE DEFAULT USERAGENT CLASS"
.PP
By default, \f(CW\*(C`SOAP::Transport::HTTP::Client\*(C'\fR extends \f(CW\*(C`LWP::UserAgent\*(C'\fR.
But under some circumstances, a user may wish to change the default
UserAgent class with their in order to better handle persist connections, or
to \f(CW\*(C`LWP::UserAgent::ProxyAny\*(C'\fR, for example, which has better Win32/Internet
Explorer interoperability.
.PP
One can use the code below as an example of how to change the default UserAgent class.
.PP
.Vb 5
\&  use SOAP::Lite;
\&  use SOAP::Transport::HTTP;
\&  $SOAP::Transport::HTTP::Client::USERAGENT_CLASS = "My::UserAgent";
\&  my $client = SOAP::Lite\->proxy(..)\->uri(..);
\&  my $som = $client\->myMethod();
.Ve
.PP
There is one caveat, however. The UserAgent class you use, \fI\s-1MUST\s0\fR also be a subclass of \f(CW\*(C`LWP::UserAgent\*(C'\fR. If it is not, then \f(CW\*(C`SOAP::Lite\*(C'\fR will issue the following error: \*(L"Could not load UserAgent class <\s-1USERAGENT CLASS\s0>.\*(R"
.PP
HTTP-KEEP-ALIVE, \s-1TIMEOUTS, AND MORE\s0
.IX Subsection "HTTP-KEEP-ALIVE, TIMEOUTS, AND MORE"
.PP
Because \f(CW\*(C`SOAP::Transport::HTTP::Client\*(C'\fR extends \f(CW\*(C`LWP::UserAgent\*(C'\fR, all methods available \f(CW\*(C`LWP::UserAgent\*(C'\fR are also available to your \s-1SOAP\s0 Clients. For example, using \f(CW\*(C`LWP::UserAgent\*(C'\fR \s-1HTTP\s0 keep alive's are accomplished using the following code:
.PP
.Vb 4
\&  my $ua = LWP::UserAgent\->new(
\&        keep_alive => 1,
\&        timeout    => 30
\&  );
.Ve
.PP
Therefore, the same initialization parameters you would pass to \f(CW\*(C`LWP::UserAgent\*(C'\fR can also be passed to your SOAP::Lite client's \f(CW\*(C`proxy\*(C'\fR subroutine like so:
.PP
.Vb 6
\&    my $soap = SOAP::Lite
\&       \->uri($uri)
\&       \->proxy($proxyUrl,
\&           timeout => 30,
\&           keep_alive => 1,
\&         );
.Ve
.PP
This is true for all initialization parameters and methods of \f(CW\*(C`LWP::UserAgent\*(C'\fR.
.PP
\s-1METHODS\s0
.IX Subsection "METHODS"
.IP "http_request" 4
.IX Item "http_request"
This method gives you access to a prototype of the \s-1HTTP\s0 Request object that
will be transmitted to a SOAP::Server. The actual request used is a copy of
that object.
.Sp
Do not use this method for anything else than setting prototypic behaviour for
the client object.
.IP "http_response" 4
.IX Item "http_response"
This method gives you access to the \s-1HTTP\s0 Response object that will be, or was
transmitted to a \s-1SOAP\s0 Server. It returns a HTTP::Response object.
.PP
\fISOAP::Transport::HTTP::Server\fR
.IX Subsection "SOAP::Transport::HTTP::Server"
.PP
Inherits from: SOAP::Server.
.PP
This is the most basic of the \s-1HTTP\s0 server implementations. It provides the
 basic methods, new and handle. The handle method's behavior is defined here,
 along with other methods specific to this class. The role of this class is
 primarily to act as a superclass for the other HTTP-based server classes.
.IP "handle" 4
.IX Item "handle"
.Vb 1
\&    $server\->handle;
.Ve
.Sp
Expects the request method to have been used to associate a HTTP::Request
object with the server object prior to being called. This method retrieves
that object reference to get at the request being handled.
.IP "request(\fIoptional value\fR)" 4
.IX Item "request(optional value)"
.Vb 1
\&    $server\->request($req_object)
.Ve
.Sp
Gets or sets the HTTP::Request object reference that the server will process within the handle method.
.IP "response(\fIoptional value\fR)" 4
.IX Item "response(optional value)"
.Vb 1
\&    $server\->response(HTTP::Response\->new(...));
.Ve
.Sp
Gets or sets the HTTP::Response object reference that the server has prepared for sending back to the client.
.IP "make_response(\fIcode\fR, \fIbody\fR)" 4
.IX Item "make_response(code, body)"
.Vb 1
\&    $server\->make_response(200, $body_xml);
.Ve
.Sp
Constructs and returns an object of the HTTP::Response class, using the response code and content provided.
.IP "make_fault(\fIfault arguments\fR)" 4
.IX Item "make_fault(fault arguments)"
.Vb 1
\&    $server\->response($server\->make_fault(@data));
.Ve
.Sp
Creates a HTTP::Response object reference using a predefined \s-1HTTP\s0 response code to signify that a fault has occurred. The arguments are the same as those for the make_fault method of the SOAP::Server class.
.IP "product_tokens" 4
.IX Item "product_tokens"
This method takes no arguments and simply returns a string identifying the elements of the server class itself. It is similar to the product_tokens methods in the HTTP::Daemon and Apache classes.
.PP
\fISOAP::Transport::HTTP::CGI\fR
.IX Subsection "SOAP::Transport::HTTP::CGI"
.PP
Inherits from: SOAP::Transport::HTTP::Server.
.PP
This class is a direct subclass of SOAP::Transport::HTTP::Server and defines no additional methods. It includes logic in its implementation of the handle method that deals with the request headers and parameters specific to a \s-1CGI\s0 environment.
.PP
\s-1EXAMPLE CGI\s0
.IX Subsection "EXAMPLE CGI"
.PP
The following code sample is a \s-1CGI\s0 based Web Service that converts celsius to fahrenheit:
.PP
.Vb 10
\&    #!/usr/bin/perl
\&    use SOAP::Transport::HTTP;
\&    SOAP::Transport::HTTP::CGI
\&      \->dispatch_to(\*(AqC2FService\*(Aq)
\&      \->handle;
\&    BEGIN {
\&      package C2FService;
\&      use vars qw(@ISA);
\&      @ISA = qw(Exporter SOAP::Server::Parameters);
\&      use SOAP::Lite;
\&      sub c2f {
\&        my $self = shift;
\&        my $envelope = pop;
\&        my $temp = $envelope\->dataof("//c2f/temperature");
\&        return SOAP::Data\->name(\*(AqconvertedTemp\*(Aq => (((9/5)*($temp\->value)) + 32));
\&      }
\&    }
.Ve
.PP
\s-1EXAMPLE APACHE::REGISTRY USAGE\s0
.IX Subsection "EXAMPLE APACHE::REGISTRY USAGE"
.PP
Using a strictly \s-1CGI\s0 based Web Service has certain performance drawbacks. Running the same \s-1CGI\s0 under the Apache::Registery system has certain performance gains.
.PP
\&\fBhttpd.conf\fR
.PP
.Vb 7
\&  Alias /mod_perl/ "/Your/Path/To/Deployed/Modules"
\&  <Location /mod_perl>
\&    SetHandler perl\-script
\&    PerlHandler Apache::Registry
\&    PerlSendHeader On
\&    Options +ExecCGI
\&  </Location>
.Ve
.PP
\&\fBsoap.cgi\fR
.PP
.Vb 1
\&  use SOAP::Transport::HTTP;
\&
\&  SOAP::Transport::HTTP::CGI
\&    \->dispatch_to(\*(Aq/Your/Path/To/Deployed/Modules\*(Aq, \*(AqModule::Name\*(Aq, \*(AqModule::method\*(Aq)
\&    \->handle;
.Ve
.PP
\&\fI\s-1WARNING:\s0 Dynamic deployments with \f(CI\*(C`Apache::Registry\*(C'\fI will fail because the module will be only loaded dynamically the first time. Subsequent calls will produce \*(L"denied access\*(R" errors because once the module is already in memory \f(CI\*(C`SOAP::Lite\*(C'\fI will bypass dynamic deployment. To work around this, simply specify both the full \s-1PATH\s0 and \s-1MODULE\s0 name in \f(CI\*(C`dispatch_to()\*(C'\fI and the module will be loaded dynamically, but will then work as if under static deployment. See \fIexamples/server/soap.mod_cgi\fI as an example.\fR
.PP
\fISOAP::Transport::HTTP::Daemon\fR
.IX Subsection "SOAP::Transport::HTTP::Daemon"
.PP
Inherits from: SOAP::Transport::HTTP::Server.
.PP
The SOAP::Transport::HTTP::Daemon class encapsulates a reference to an object of the HTTP::Daemon class (from the \s-1LWP\s0 package). The class catches methods that aren't provided locally or by the superclass and attempts to call them on the HTTP::Daemon object. Thus, all methods defined in the documentation for that class are available to this class as well. Any that conflict with methods in SOAP::Transport::HTTP::Server (such as product_tokens) go to the superclass. Additionally, the behavior of the handle method is specific to this class:
.IP "handle" 4
.IX Item "handle"
When invoked, this method enters into the typical accept loop in which it waits for a request on the socket that the daemon object maintains and deals with the content of the request. When all requests from the connection returned by the accept method of the HTTP::Daemon object have been processed, this method returns.
.PP
\s-1REUSING SOCKETS ON RESTART\s0
.IX Subsection "REUSING SOCKETS ON RESTART"
.PP
Often when implementing an \s-1HTTP\s0 daemon, sockets will get tied up when you try to restart the daemon server. This prevents the server from restarting. Often users will see an error like \*(L"Cannot start server: port already in use.\*(R" To circumvent this, instruct SOAP::Lite to reuse open sockets using \f(CW\*(C`Reuse => 1\*(C'\fR:
.PP
.Vb 2
\&  my $daemon = SOAP::Transport::HTTP::Daemon
\&                  \-> new (LocalPort => 80000, Reuse => 1)
.Ve
.PP
\s-1EXAMPLE DAEMON SERVER\s0
.IX Subsection "EXAMPLE DAEMON SERVER"
.PP
.Vb 11
\&  use SOAP::Transport::HTTP;
\&  # change LocalPort to 81 if you want to test it with soapmark.pl
\&  my $daemon = SOAP::Transport::HTTP::Daemon
\&    \-> new (LocalAddr => \*(Aqlocalhost\*(Aq, LocalPort => 80)
\&    # specify list of objects\-by\-reference here
\&    \-> objects_by_reference(qw(My::PersistentIterator My::SessionIterator My::Chat))
\&    # specify path to My/Examples.pm here
\&    \-> dispatch_to(\*(Aq/Your/Path/To/Deployed/Modules\*(Aq, \*(AqModule::Name\*(Aq, \*(AqModule::method\*(Aq)
\&  ;
\&  print "Contact to SOAP server at ", $daemon\->url, "\en";
\&  $daemon\->handle;
.Ve
.PP
\fISOAP::Transport::HTTP::Apache\fR
.IX Subsection "SOAP::Transport::HTTP::Apache"
.PP
Inherits from: SOAP::Transport::HTTP::Server.
.PP
This class provides an integration of the SOAP::Server base class with the mod_perl extension for Apache. To work as a location handler, the package provides a method called handler, for which handle is made an alias. The new method isn't functionally different from the superclass. Here are the other methods provided by this class:
.IP "handler(\fIApache request\fR)" 4
.IX Item "handler(Apache request)"
.Vb 1
\&    $server\->handler($r)
.Ve
.Sp
Defines the basis for a location handler in the mod_perl fashion. The method expects an Apache request object as the parameter, from which it pulls the body of the request and calls the superclass handle method.
.Sp
Note that in this class, the local method named handle is aliased to this method.
.IP "configure(\fIApache request\fR)" 4
.IX Item "configure(Apache request)"
.Vb 1
\&    $server\->configure(Apache\->request);
.Ve
.Sp
Per-location configuration information can be provided to the server object using the Apache DirConfig directive and calling this method on the object itself. When invoked, the method reads the directory configuration information from Apache and looks for lines of the form:
.Sp
.Vb 1
\&    method => param
.Ve
.Sp
Each line that matches the pattern is regarded as a potential method to call on the server object, with the remaining token taken as the parameter to the method. Methods that take hash references as arguments may be specified as:
.Sp
.Vb 1
\&    method => key => param, key => param
.Ve
.Sp
The key/value pairs will be made into a hash reference on demand. If the server object doesn't recognize the named method as valid, it ignores the line.
.PP
\s-1EXAMPLE APACHE MOD_PERL SERVER\s0
.IX Subsection "EXAMPLE APACHE MOD_PERL SERVER"
.PP
See \fIexamples/server/Apache.pm\fR and Apache::SOAP for more information.
.PP
\&\fBhttpd.conf\fR
.PP
.Vb 5
\&  <Location /soap>
\&    SetHandler perl\-script
\&    PerlHandler SOAP::Apache
\&    PerlSetVar options "compress_threshold => 10000"
\&  </Location>
.Ve
.PP
\&\fBSOAP::Apache.pm\fR
.PP
.Vb 6
\&  package SOAP::Apache;
\&  use SOAP::Transport::HTTP;
\&  my $server = SOAP::Transport::HTTP::Apache
\&    \->dispatch_to(\*(Aq/Your/Path/To/Deployed/Modules\*(Aq, \*(AqModule::Name\*(Aq, \*(AqModule::method\*(Aq);
\&  sub handler { $server\->handler(@_) }
\&  1;
.Ve
.PP
See also Apache::SOAP.
.PP
\fISOAP::Transport::HTTP::FCGI\fR
.IX Subsection "SOAP::Transport::HTTP::FCGI"
.PP
Inherits from: SOAP::Transport::HTTP::CGI.
.PP
This is an extension of the SOAP::Transport::HTTP::CGI that implements the differences needed for the FastCGI protocol. None of the methods are functionally different.
.SS "SOAP::Transport::IO"
.IX Subsection "SOAP::Transport::IO"
The SOAP::Transport::IO\-based class allows for a sort of I/O proxying by allowing the application to configure what files or filehandles are used. This module supplies only a server class.
.PP
\fISOAP::Transport::IO::Server\fR
.IX Subsection "SOAP::Transport::IO::Server"
.PP
Inherits from: SOAP::Server.
.PP
The server class defined here inherits all methods from SOAP::Server, and adds two additional methods specific to the nature of the class:
.IP "in" 4
.IX Item "in"
.Vb 1
\&    $server\->in(IO::File\->new($file));
.Ve
.Sp
Gets or sets the current filehandle being used as the input source.
.IP "out" 4
.IX Item "out"
.Vb 1
\&    $server\->out(\e*STDERR);
.Ve
.Sp
Gets or sets the filehandle being used as the output destination.
.SS "SOAP::Transport::LOCAL"
.IX Subsection "SOAP::Transport::LOCAL"
The SOAP::Transport::LOCAL module is designed to provide a no-transport client class for tracing and debugging communications traffic. It links SOAP::Client and SOAP::Server so that the same object that \*(L"sends\*(R" the request also \*(L"receives\*(R" it.
.PP
\fISOAP::Transport::LOCAL::Client\fR
.IX Subsection "SOAP::Transport::LOCAL::Client"
.PP
Inherits from: SOAP::Client, SOAP::Server.
The implementations of the new and send_receive methods aren't noticeably different in their interface. Their behavior warrants description, however:
.IP "new" 4
.IX Item "new"
When the constructor creates a new object of this class, it sets up a few things beyond the usual SOAP::Client layout. The is_success method is set to a default value of 1. The dispatch_to method inherited from SOAP::Server is called with the current value of the global array \f(CW@INC\fR, allowing the client to call any methods that can be found in the  current valid search path. And as with most of the constructors in this module, the optional key/value pairs are treated as method names and parameters.
.IP "send_receive" 4
.IX Item "send_receive"
The implementation of this method simply passes the envelope portion of the input data to the handle method of SOAP::Server. While no network traffic results (directly) from this, it allows for debug signals to be sent through the SOAP::Trace facility.
.SS "SOAP::Transport::MAILTO"
.IX Subsection "SOAP::Transport::MAILTO"
This transport class manages SMTP-based sending of messages from a client perspective. It doesn't provide a server class. The class gets selected when a client object passes a \s-1URI\s0 to proxy or endpoint that starts with the characters, mailto:.
.PP
\fISOAP::Transport::MAILTO::Client\fR
.IX Subsection "SOAP::Transport::MAILTO::Client"
.PP
Inherits from: SOAP::Client.
.PP
The client class for this protocol doesn't define any new methods. The constructor functions in the same style as the others class constructors. The functionality of the send_receive method is slightly different from other classes, however.
.PP
When invoked, the send_receive method uses the MIME::Lite package to encapsulate and transmit the message. Because mail messages are one-way communications (the reply being a separate process), there is no response message to be returned by the method. Instead, all the status-related attributes (code, message, status, is_success) are set, and no value is explicitly returned.
.SS "SOAP::Transport::POP3"
.IX Subsection "SOAP::Transport::POP3"
\&\s-1POP3\s0 support is limited to a server implementation. Just as the \s-1MAILTO\s0 class detailed earlier operates by sending requests without expecting to process a response, the server described here accepts request messages and dispatches them without regard for sending a response other than that which \s-1POP3\s0 defines for successful delivery of a message.
.PP
\fISOAP::Transport::POP3::Server\fR
.IX Subsection "SOAP::Transport::POP3::Server"
.PP
Inherits from: SOAP::Server.
.PP
The new method of this class creates an object of the Net::POP3 class to use internally for polling a specified \s-1POP3\s0 server for incoming messages. When an object of this class is created, it expects an endpoint to be specified with a \s-1URI\s0 that begins with the characters pop:// and includes user \s-1ID\s0 and password information as well as the hostname itself.
.PP
The handle method takes the messages present in the remote mailbox and passes them (one at a time) to the superclass handle method. Each message is deleted after being routed. All messages in the \s-1POP3\s0 mailbox are presumed to be \s-1SOAP\s0 messages.
.PP
Methods for the Net::POP3 object are detected and properly routed, allowing operations such as \f(CW$server\fR\->ping( ).
.PP
This means that the endpoint string doesn't need to provide the user \s-1ID\s0 and password because the login method from the \s-1POP3 API\s0 may be used directly.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Special thanks to O'Reilly publishing which has graciously allowed SOAP::Lite to republish and redistribute large excerpts from \fIProgramming Web Services with Perl\fR, mainly the SOAP::Lite reference found in Appendix B.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2004 Paul Kulchenko. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Kulchenko (paulclinger@yahoo.com)
.PP
Randy J. Ray (rjray@blackperl.com)
.PP
Byrne Reese (byrne@majordojo.com)
