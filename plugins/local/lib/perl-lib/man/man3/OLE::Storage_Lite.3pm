.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OLE::Storage_Lite 3"
.TH OLE::Storage_Lite 3 "2019-10-08" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OLE::Storage_Lite \- Simple Class for OLE document interface.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use OLE::Storage_Lite;
\&
\&    # Initialize.
\&
\&    # From a file
\&    my $oOl = OLE::Storage_Lite\->new("some.xls");
\&
\&    # From a filehandle object
\&    use IO::File;
\&    my $oIo = new IO::File;
\&    $oIo\->open("<iofile.xls");
\&    binmode($oIo);
\&    my $oOl = OLE::Storage_Lite\->new($oFile);
\&
\&    # Read data
\&    my $oPps = $oOl\->getPpsTree(1);
\&
\&    # Save Data
\&    # To a File
\&    $oPps\->save("kaba.xls"); #kaba.xls
\&    $oPps\->save(\*(Aq\-\*(Aq);        #STDOUT
\&
\&    # To a filehandle object
\&    my $oIo = new IO::File;
\&    $oIo\->open(">iofile.xls");
\&    bimode($oIo);
\&    $oPps\->save($oIo);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OLE::Storage_Lite allows you to read and write an \s-1OLE\s0 structured file.
.PP
OLE::Storage_Lite::PPS is a class representing \s-1PPS.\s0 OLE::Storage_Lite::PPS::Root, OLE::Storage_Lite::PPS::File and OLE::Storage_Lite::PPS::Dir
are subclasses of OLE::Storage_Lite::PPS.
.SS "\fInew()\fP"
.IX Subsection "new()"
Constructor.
.PP
.Vb 1
\&    $oOle = OLE::Storage_Lite\->new($sFile);
.Ve
.PP
Creates a OLE::Storage_Lite object for \f(CW$sFile\fR. \f(CW$sFile\fR must be a correct file name.
.PP
The \f(CW\*(C`new()\*(C'\fR constructor also accepts a valid filehandle. Remember to \f(CW\*(C`binmode()\*(C'\fR the filehandle first.
.SS "\fIgetPpsTree()\fP"
.IX Subsection "getPpsTree()"
.Vb 1
\&    $oPpsRoot = $oOle\->getPpsTree([$bData]);
.Ve
.PP
Returns \s-1PPS\s0 as an OLE::Storage_Lite::PPS::Root object.
Other \s-1PPS\s0 objects will be included as its children.
.PP
If \f(CW$bData\fR is true, the objects will have data in the file.
.SS "\fIgetPpsSearch()\fP"
.IX Subsection "getPpsSearch()"
.Vb 1
\&    $oPpsRoot = $oOle\->getPpsTree($raName [, $bData][, $iCase] );
.Ve
.PP
Returns PPSs as OLE::Storage_Lite::PPS objects that has the name specified in \f(CW$raName\fR array.
.PP
If \f(CW$bData\fR is true, the objects will have data in the file.
If \f(CW$iCase\fR is true, search is case insensitive.
.SS "\fIgetNthPps()\fP"
.IX Subsection "getNthPps()"
.Vb 1
\&    $oPpsRoot = $oOle\->getNthPps($iNth [, $bData]);
.Ve
.PP
Returns \s-1PPS\s0 as \f(CW\*(C`OLE::Storage_Lite::PPS\*(C'\fR object specified number \f(CW$iNth\fR.
.PP
If \f(CW$bData\fR is true, the objects will have data in the file.
.SS "\fIAsc2Ucs()\fP"
.IX Subsection "Asc2Ucs()"
.Vb 1
\&    $sUcs2 = OLE::Storage_Lite::Asc2Ucs($sAsc>);
.Ve
.PP
Utility function. Just adds 0x00 after every characters in \f(CW$sAsc\fR.
.SS "\fIUcs2Asc()\fP"
.IX Subsection "Ucs2Asc()"
.Vb 1
\&    $sAsc = OLE::Storage_Lite::Ucs2Asc($sUcs2);
.Ve
.PP
Utility function. Just deletes 0x00 after words in \f(CW$sUcs\fR.
.SH "OLE::Storage_Lite::PPS"
.IX Header "OLE::Storage_Lite::PPS"
OLE::Storage_Lite::PPS has these properties:
.IP "No" 4
.IX Item "No"
Order number in saving.
.IP "Name" 4
.IX Item "Name"
Its name in \s-1UCS2 \s0(a.k.a Unicode).
.IP "Type" 4
.IX Item "Type"
Its type (1:Dir, 2:File (Data), 5: Root)
.IP "PrevPps" 4
.IX Item "PrevPps"
Previous pps (as No)
.IP "NextPps" 4
.IX Item "NextPps"
Next pps (as No)
.IP "DirPps" 4
.IX Item "DirPps"
Dir pps (as No).
.IP "Time1st" 4
.IX Item "Time1st"
Timestamp 1st in array ref as similar fomat of localtime.
.IP "Time2nd" 4
.IX Item "Time2nd"
Timestamp 2nd in array ref as similar fomat of localtime.
.IP "StartBlock" 4
.IX Item "StartBlock"
Start block number
.IP "Size" 4
.IX Item "Size"
Size of the pps
.IP "Data" 4
.IX Item "Data"
Its data
.IP "Child" 4
.IX Item "Child"
Its child PPSs in array ref
.SH "OLE::Storage_Lite::PPS::Root"
.IX Header "OLE::Storage_Lite::PPS::Root"
OLE::Storage_Lite::PPS::Root has 2 methods.
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 4
\&    $oRoot = OLE::Storage_Lite::PPS::Root\->new(
\&                    $raTime1st,
\&                    $raTime2nd,
\&                    $raChild);
.Ve
.PP
Constructor.
.PP
\&\f(CW$raTime1st\fR, \f(CW$raTime2nd\fR are array refs with ($iSec, \f(CW$iMin\fR, \f(CW$iHour\fR, \f(CW$iDay\fR, \f(CW$iMon\fR, \f(CW$iYear\fR).
\&\f(CW$iSec\fR means seconds, \f(CW$iMin\fR means minutes. \f(CW$iHour\fR means hours.
\&\f(CW$iDay\fR means day. \f(CW$iMon\fR is month \-1. \f(CW$iYear\fR is year \- 1900.
.PP
\&\f(CW$raChild\fR is a array ref of children PPSs.
.SS "\fIsave()\fP"
.IX Subsection "save()"
.Vb 3
\&    $oRoot = $oRoot>\->save(
\&                    $sFile,
\&                    $bNoAs);
.Ve
.PP
Saves information into \f(CW$sFile\fR. If \f(CW$sFile\fR is '\-', this will use \s-1STDOUT.\s0
.PP
The \f(CW\*(C`new()\*(C'\fR constructor also accepts a valid filehandle. Remember to \f(CW\*(C`binmode()\*(C'\fR the filehandle first.
.PP
If \f(CW$bNoAs\fR is defined, this function will use the No of PPSs for saving order.
If \f(CW$bNoAs\fR is undefined, this will calculate \s-1PPS\s0 saving order.
.SH "OLE::Storage_Lite::PPS::Dir"
.IX Header "OLE::Storage_Lite::PPS::Dir"
OLE::Storage_Lite::PPS::Dir has 1 method.
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 5
\&    $oRoot = OLE::Storage_Lite::PPS::Dir\->new(
\&                    $sName,
\&                  [, $raTime1st]
\&                  [, $raTime2nd]
\&                  [, $raChild>]);
.Ve
.PP
Constructor.
.PP
\&\f(CW$sName\fR is a name of the \s-1PPS.\s0
.PP
\&\f(CW$raTime1st\fR, \f(CW$raTime2nd\fR is a array ref as
($iSec, \f(CW$iMin\fR, \f(CW$iHour\fR, \f(CW$iDay\fR, \f(CW$iMon\fR, \f(CW$iYear\fR).
\&\f(CW$iSec\fR means seconds, \f(CW$iMin\fR means minutes. \f(CW$iHour\fR means hours.
\&\f(CW$iDay\fR means day. \f(CW$iMon\fR is month \-1. \f(CW$iYear\fR is year \- 1900.
.PP
\&\f(CW$raChild\fR is a array ref of children PPSs.
.SH "OLE::Storage_Lite::PPS::File"
.IX Header "OLE::Storage_Lite::PPS::File"
OLE::Storage_Lite::PPS::File has 3 method.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $oRoot = OLE::Storage_Lite::PPS::File\->new($sName, $sData);
.Ve
.PP
\&\f(CW$sName\fR is name of the \s-1PPS.\s0
.PP
\&\f(CW$sData\fR is data of the \s-1PPS.\s0
.SS "\fInewFile()\fP"
.IX Subsection "newFile()"
.Vb 1
\&    $oRoot = OLE::Storage_Lite::PPS::File\->newFile($sName, $sFile);
.Ve
.PP
This function makes to use file handle for geting and storing data.
.PP
\&\f(CW$sName\fR is name of the \s-1PPS.\s0
.PP
If \f(CW$sFile\fR is scalar, it assumes that is a filename.
If \f(CW$sFile\fR is an IO::Handle object, it uses that specified handle.
If \f(CW$sFile\fR is undef or '', it uses temporary file.
.PP
\&\s-1CAUTION:\s0 Take care \f(CW$sFile\fR will be updated by \f(CW\*(C`append\*(C'\fR method.
So if you want to use IO::Handle and append a data to it,
you should open the handle with \*(L"r+\*(R".
.SS "\fIappend()\fP"
.IX Subsection "append()"
.Vb 1
\&    $oRoot = $oPps\->append($sData);
.Ve
.PP
appends specified data to that \s-1PPS.\s0
.PP
\&\f(CW$sData\fR is appending data for that \s-1PPS.\s0
.SH "CAUTION"
.IX Header "CAUTION"
A saved file with \s-1VBA \s0(a.k.a Macros) by this module will not work correctly.
However modules can get the same information from the file,
the file occurs a error in application(Word, Excel ...).
.SH "DEPRECATED FEATURES"
.IX Header "DEPRECATED FEATURES"
Older version of \f(CW\*(C`OLE::Storage_Lite\*(C'\fR autovivified a scalar ref in the \f(CW\*(C`new()\*(C'\fR constructors into a scalar filehandle. This functionality is still there for backwards compatibility but it is highly recommended that you do not use it. Instead create a filehandle (scalar or otherwise) and pass that in.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The OLE::Storage_Lite module is Copyright (c) 2000,2001 Kawai Takanori. Japan.
All rights reserved.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public
License or the Artistic License, as specified in the Perl \s-1README\s0 file.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
First of all, I would like to acknowledge to Martin Schwartz and his module OLE::Storage.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kawai Takanori kwitknr@cpan.org
.PP
This module is currently maintained by John McNamara jmcnamara@cpan.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
OLE::Storage
.PP
Documentation for the \s-1OLE\s0 Compound document has been released by Microsoft under the \fIOpen Specification Promise\fR. See http://www.microsoft.com/interop/docs/supportingtechnologies.mspx
.PP
The Digital Imaging Group have also detailed the \s-1OLE\s0 format in the \s-1JPEG2000\s0 specification: see Appendix A of http://www.i3a.org/pdf/wg1n1017.pdf
