.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Spreadsheet::ParseExcel 3"
.TH Spreadsheet::ParseExcel 3 "2021-07-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Spreadsheet::ParseExcel \- Read information from an Excel file.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    use strict;
\&    use Spreadsheet::ParseExcel;
\&
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
\&
\&    if ( !defined $workbook ) {
\&        die $parser\->error(), ".\en";
\&    }
\&
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&
\&        my ( $row_min, $row_max ) = $worksheet\->row_range();
\&        my ( $col_min, $col_max ) = $worksheet\->col_range();
\&
\&        for my $row ( $row_min .. $row_max ) {
\&            for my $col ( $col_min .. $col_max ) {
\&
\&                my $cell = $worksheet\->get_cell( $row, $col );
\&                next unless $cell;
\&
\&                print "Row, Col    = ($row, $col)\en";
\&                print "Value       = ", $cell\->value(),       "\en";
\&                print "Unformatted = ", $cell\->unformatted(), "\en";
\&                print "\en";
\&            }
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Spreadsheet::ParseExcel module can be used to read information from Excel 95\-2003 binary files.
.PP
The module cannot read files in the Excel 2007 Open \s-1XML XLSX\s0 format. See the Spreadsheet::XLSX module instead.
.SH "Parser"
.IX Header "Parser"
.SS "\fInew()\fP"
.IX Subsection "new()"
The \f(CW\*(C`new()\*(C'\fR method is used to create a new \f(CW\*(C`Spreadsheet::ParseExcel\*(C'\fR parser object.
.PP
.Vb 1
\&    my $parser = Spreadsheet::ParseExcel\->new();
.Ve
.PP
It is possible to pass a password to decrypt an encrypted file:
.PP
.Vb 1
\&    $parser = Spreadsheet::ParseExcel\->new( Password => \*(Aqsecret\*(Aq );
.Ve
.PP
Only the default Excel encryption scheme is currently supported. See \*(L"Decryption\*(R".
.PP
As an advanced feature it is also possible to pass a call-back handler to the parser to control the parsing of the spreadsheet.
.PP
.Vb 4
\&    $parser = Spreadsheet::ParseExcel\->new(
\&        CellHandler => \e&cell_handler,
\&        NotSetCell  => 1,
\&    );
.Ve
.PP
The call-back can be used to ignore certain cells or to reduce memory usage. See the section \*(L"Reducing the memory usage of Spreadsheet::ParseExcel\*(R" for more information.
.ie n .SS "parse($filename, $formatter)"
.el .SS "parse($filename, \f(CW$formatter\fP)"
.IX Subsection "parse($filename, $formatter)"
The Parser \f(CW\*(C`parse()\*(C'\fR method returns a \*(L"Workbook\*(R" object.
.PP
.Vb 2
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
.Ve
.PP
If an error occurs \f(CW\*(C`parse()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR. In general, programs should contain a test for failed parsing as follows:
.PP
.Vb 2
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
\&
\&    if ( !defined $workbook ) {
\&        die $parser\->error(), ".\en";
\&    }
.Ve
.PP
The \f(CW$filename\fR parameter is generally the file to be parsed. However, it can also be a filehandle or a scalar reference.
.PP
The optional \f(CW$formatter\fR parameter can be an reference to a \*(L"Formatter Class\*(R" to format the value of cells. This is useful for parsing workbooks with Unicode or Asian characters:
.PP
.Vb 3
\&    my $parser    = Spreadsheet::ParseExcel\->new();
\&    my $formatter = Spreadsheet::ParseExcel::FmtJapan\->new();
\&    my $workbook  = $parser\->parse( \*(AqBook1.xls\*(Aq, $formatter );
.Ve
.PP
The Spreadsheet::ParseExcel::FmtJapan formatter also supports Unicode. If you encounter any encoding problems with the default formatter try that instead.
.SS "\fIerror()\fP"
.IX Subsection "error()"
The Parser \f(CW\*(C`error()\*(C'\fR method returns an error string if a \f(CW\*(C`parse()\*(C'\fR fails:
.PP
.Vb 2
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
\&
\&    if ( !defined $workbook ) {
\&        die $parser\->error(), ".\en";
\&    }
.Ve
.PP
If you wish to generate you own error string you can use the \f(CW\*(C`error_code()\*(C'\fR method instead (see below). The \f(CW\*(C`error()\*(C'\fR and \f(CW\*(C`error_code()\*(C'\fR values are as follows:
.PP
.Vb 6
\&    error()                         error_code()
\&    =======                         ============
\&    \*(Aq\*(Aq                              0
\&    \*(AqFile not found\*(Aq                1
\&    \*(AqNo Excel data found in file\*(Aq   2
\&    \*(AqFile is encrypted\*(Aq             3
.Ve
.PP
The \f(CW\*(C`error_code()\*(C'\fR method is explained below.
.PP
Spreadsheet::ParseExcel will try to decrypt an encrypted Excel file using the default password or a user supplied password passed to \f(CW\*(C`new()\*(C'\fR, see above. If these fail the module will return the \f(CW\*(AqFile is encrypted\*(Aq\fR error. Only the default Excel encryption scheme is currently supported, see \*(L"Decryption\*(R".
.SS "\fIerror_code()\fP"
.IX Subsection "error_code()"
The Parser \f(CW\*(C`error_code()\*(C'\fR method returns an error code if a \f(CW\*(C`parse()\*(C'\fR fails:
.PP
.Vb 2
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
\&
\&    if ( !defined $workbook ) {
\&        die "Got error code ", $parser\->error_code, ".\en";
\&    }
.Ve
.PP
This can be useful if you wish to employ you own error strings or error handling methods.
.SH "Workbook"
.IX Header "Workbook"
A \f(CW\*(C`Spreadsheet::ParseExcel::Workbook\*(C'\fR is created via the \f(CW\*(C`Spreadsheet::ParseExcel\*(C'\fR \f(CW\*(C`parse()\*(C'\fR method:
.PP
.Vb 2
\&    my $parser   = Spreadsheet::ParseExcel\->new();
\&    my $workbook = $parser\->parse(\*(AqBook1.xls\*(Aq);
.Ve
.PP
The main methods of the Workbook class are:
.PP
.Vb 4
\&    $workbook\->worksheets()
\&    $workbook\->worksheet()
\&    $workbook\->worksheet_count()
\&    $workbook\->get_filename()
.Ve
.PP
These more commonly used methods of the Workbook class are outlined below. The other, less commonly used, methods are documented in Spreadsheet::ParseExcel::Worksheet.
.SS "\fIworksheets()\fP"
.IX Subsection "worksheets()"
Returns an array of \*(L"Worksheet\*(R" objects. This was most commonly used to iterate over the worksheets in a workbook:
.PP
.Vb 3
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        ...
\&    }
.Ve
.SS "\fIworksheet()\fP"
.IX Subsection "worksheet()"
The \f(CW\*(C`worksheet()\*(C'\fR method returns a single \f(CW\*(C`Worksheet\*(C'\fR object using either its name or index:
.PP
.Vb 2
\&    $worksheet = $workbook\->worksheet(\*(AqSheet1\*(Aq);
\&    $worksheet = $workbook\->worksheet(0);
.Ve
.PP
Returns \f(CW\*(C`undef\*(C'\fR if the sheet name or index doesn't exist.
.SS "\fIworksheet_count()\fP"
.IX Subsection "worksheet_count()"
The \f(CW\*(C`worksheet_count()\*(C'\fR method returns the number of Worksheet objects in the Workbook.
.PP
.Vb 1
\&    my $worksheet_count = $workbook\->worksheet_count();
.Ve
.SS "\fIget_filename()\fP"
.IX Subsection "get_filename()"
The \f(CW\*(C`get_filename()\*(C'\fR method returns the name of the Excel file of \f(CW\*(C`undef\*(C'\fR if the data was read from a filehandle rather than a file.
.PP
.Vb 1
\&    my $filename = $workbook\->get_filename();
.Ve
.SS "Other Workbook Methods"
.IX Subsection "Other Workbook Methods"
For full documentation of the methods available via a Workbook object see Spreadsheet::ParseExcel::Workbook.
.SH "Worksheet"
.IX Header "Worksheet"
The \f(CW\*(C`Spreadsheet::ParseExcel::Worksheet\*(C'\fR class encapsulates the properties of an Excel worksheet.
.PP
A Worksheet object is obtained via the \*(L"\fIworksheets()\fR\*(R" or \*(L"\fIworksheet()\fR\*(R" methods.
.PP
.Vb 3
\&    for my $worksheet ( $workbook\->worksheets() ) {
\&        ...
\&    }
\&
\&    # Or:
\&
\&    $worksheet = $workbook\->worksheet(\*(AqSheet1\*(Aq);
\&    $worksheet = $workbook\->worksheet(0);
.Ve
.PP
The most commonly used methods of the Worksheet class are:
.PP
.Vb 4
\&    $worksheet\->get_cell()
\&    $worksheet\->row_range()
\&    $worksheet\->col_range()
\&    $worksheet\->get_name()
.Ve
.PP
The Spreadsheet::ParseExcel::Worksheet class exposes a lot of methods but in general very few are required unless you are writing an advanced filter.
.PP
The most commonly used methods are detailed below. The others are documented in Spreadsheet::ParseExcel::Worksheet.
.ie n .SS "get_cell($row, $col)"
.el .SS "get_cell($row, \f(CW$col\fP)"
.IX Subsection "get_cell($row, $col)"
Return the \*(L"Cell\*(R" object at row \f(CW$row\fR and column \f(CW$col\fR if it is defined. Otherwise returns undef.
.PP
.Vb 1
\&    my $cell = $worksheet\->get_cell($row, $col);
.Ve
.SS "\fIrow_range()\fP"
.IX Subsection "row_range()"
Returns a two-element list \f(CW\*(C`($min, $max)\*(C'\fR containing the minimum and maximum defined rows in the worksheet. If there is no row defined \f(CW$max\fR is smaller than \f(CW$min\fR.
.PP
.Vb 1
\&    my ( $row_min, $row_max ) = $worksheet\->row_range();
.Ve
.SS "\fIcol_range()\fP"
.IX Subsection "col_range()"
Returns a two-element list \f(CW\*(C`($min, $max)\*(C'\fR containing the minimum and maximum of defined columns in the worksheet. If there is no column defined \f(CW$max\fR is smaller than \f(CW$min\fR.
.PP
.Vb 1
\&    my ( $col_min, $col_max ) = $worksheet\->col_range();
.Ve
.SS "\fIget_name()\fP"
.IX Subsection "get_name()"
The \f(CW\*(C`get_name()\*(C'\fR method returns the name of the worksheet, such as 'Sheet1'.
.PP
.Vb 1
\&    my $name = $worksheet\->get_name();
.Ve
.SS "Other Worksheet Methods"
.IX Subsection "Other Worksheet Methods"
For other, less commonly used, Worksheet methods see Spreadsheet::ParseExcel::Worksheet.
.SH "Cell"
.IX Header "Cell"
The \f(CW\*(C`Spreadsheet::ParseExcel::Cell\*(C'\fR class has the following main methods.
.PP
.Vb 2
\&    $cell\->value()
\&    $cell\->unformatted()
.Ve
.SS "\fIvalue()\fP"
.IX Subsection "value()"
The \f(CW\*(C`value()\*(C'\fR method returns the formatted value of the cell.
.PP
.Vb 1
\&    my $value = $cell\->value();
.Ve
.PP
Formatted in this sense refers to the numeric format of the cell value. For example a number such as 40177 might be formatted as 40,117, 40117.000 or even as the date 2009/12/30.
.PP
If the cell doesn't contain a numeric format then the formatted and unformatted cell values are the same, see the \f(CW\*(C`unformatted()\*(C'\fR method below.
.PP
For a defined \f(CW$cell\fR the \f(CW\*(C`value()\*(C'\fR method will always return a value.
.PP
In the case of a cell with formatting but no numeric or string contents the method will return the empty string \f(CW\*(Aq\*(Aq\fR.
.SS "\fIunformatted()\fP"
.IX Subsection "unformatted()"
The \f(CW\*(C`unformatted()\*(C'\fR method returns the unformatted value of the cell.
.PP
.Vb 1
\&    my $unformatted = $cell\->unformatted();
.Ve
.PP
Returns the cell value without a numeric format. See the \f(CW\*(C`value()\*(C'\fR method above.
.SS "Other Cell Methods"
.IX Subsection "Other Cell Methods"
For other, less commonly used, Worksheet methods see Spreadsheet::ParseExcel::Cell.
.SH "Format"
.IX Header "Format"
The \f(CW\*(C`Spreadsheet::ParseExcel::Format\*(C'\fR class has the following properties:
.SS "Format properties"
.IX Subsection "Format properties"
.Vb 10
\&    $format\->{Font}
\&    $format\->{AlignH}
\&    $format\->{AlignV}
\&    $format\->{Indent}
\&    $format\->{Wrap}
\&    $format\->{Shrink}
\&    $format\->{Rotate}
\&    $format\->{JustLast}
\&    $format\->{ReadDir}
\&    $format\->{BdrStyle}
\&    $format\->{BdrColor}
\&    $format\->{BdrDiag}
\&    $format\->{Fill}
\&    $format\->{Lock}
\&    $format\->{Hidden}
\&    $format\->{Style}
.Ve
.PP
These properties are generally only of interest to advanced users. Casual users can skip this section.
.ie n .SS "$format\->{Font}"
.el .SS "\f(CW$format\fP\->{Font}"
.IX Subsection "$format->{Font}"
Returns the \*(L"Font\*(R" object for the Format.
.ie n .SS "$format\->{AlignH}"
.el .SS "\f(CW$format\fP\->{AlignH}"
.IX Subsection "$format->{AlignH}"
Returns the horizontal alignment of the format where the value has the following meaning:
.PP
.Vb 8
\&    0 => No alignment
\&    1 => Left
\&    2 => Center
\&    3 => Right
\&    4 => Fill
\&    5 => Justify
\&    6 => Center across
\&    7 => Distributed/Equal spaced
.Ve
.ie n .SS "$format\->{AlignV}"
.el .SS "\f(CW$format\fP\->{AlignV}"
.IX Subsection "$format->{AlignV}"
Returns the vertical alignment of the format where the value has the following meaning:
.PP
.Vb 5
\&    0 => Top
\&    1 => Center
\&    2 => Bottom
\&    3 => Justify
\&    4 => Distributed/Equal spaced
.Ve
.ie n .SS "$format\->{Indent}"
.el .SS "\f(CW$format\fP\->{Indent}"
.IX Subsection "$format->{Indent}"
Returns the indent level of the \f(CW\*(C`Left\*(C'\fR horizontal alignment.
.ie n .SS "$format\->{Wrap}"
.el .SS "\f(CW$format\fP\->{Wrap}"
.IX Subsection "$format->{Wrap}"
Returns true if textwrap is on.
.ie n .SS "$format\->{Shrink}"
.el .SS "\f(CW$format\fP\->{Shrink}"
.IX Subsection "$format->{Shrink}"
Returns true if \*(L"Shrink to fit\*(R" is set for the format.
.ie n .SS "$format\->{Rotate}"
.el .SS "\f(CW$format\fP\->{Rotate}"
.IX Subsection "$format->{Rotate}"
Returns the text rotation. In Excel97+, it returns the angle in degrees of the text rotation.
.PP
In Excel95 or earlier it returns a value as follows:
.PP
.Vb 4
\&    0 => No rotation
\&    1 => Top down
\&    2 => 90 degrees anti\-clockwise,
\&    3 => 90 clockwise
.Ve
.ie n .SS "$format\->{JustLast}"
.el .SS "\f(CW$format\fP\->{JustLast}"
.IX Subsection "$format->{JustLast}"
Return true if the \*(L"justify last\*(R" property is set for the format.
.ie n .SS "$format\->{ReadDir}"
.el .SS "\f(CW$format\fP\->{ReadDir}"
.IX Subsection "$format->{ReadDir}"
Returns the direction that the text is read from.
.ie n .SS "$format\->{BdrStyle}"
.el .SS "\f(CW$format\fP\->{BdrStyle}"
.IX Subsection "$format->{BdrStyle}"
Returns an array ref of border styles as follows:
.PP
.Vb 1
\&    [ $left, $right, $top, $bottom ]
.Ve
.ie n .SS "$format\->{BdrColor}"
.el .SS "\f(CW$format\fP\->{BdrColor}"
.IX Subsection "$format->{BdrColor}"
Returns an array ref of border color indexes as follows:
.PP
.Vb 1
\&    [ $left, $right, $top, $bottom ]
.Ve
.ie n .SS "$format\->{BdrDiag}"
.el .SS "\f(CW$format\fP\->{BdrDiag}"
.IX Subsection "$format->{BdrDiag}"
Returns an array ref of diagonal border kind, style and color index as follows:
.PP
.Vb 1
\&    [$kind, $style, $color ]
.Ve
.PP
Where kind is:
.PP
.Vb 4
\&    0 => None
\&    1 => Right\-Down
\&    2 => Right\-Up
\&    3 => Both
.Ve
.ie n .SS "$format\->{Fill}"
.el .SS "\f(CW$format\fP\->{Fill}"
.IX Subsection "$format->{Fill}"
Returns an array ref of fill pattern and color indexes as follows:
.PP
.Vb 1
\&    [ $pattern, $front_color, $back_color ]
.Ve
.ie n .SS "$format\->{Lock}"
.el .SS "\f(CW$format\fP\->{Lock}"
.IX Subsection "$format->{Lock}"
Returns true if the cell is locked.
.ie n .SS "$format\->{Hidden}"
.el .SS "\f(CW$format\fP\->{Hidden}"
.IX Subsection "$format->{Hidden}"
Returns true if the cell is Hidden.
.ie n .SS "$format\->{Style}"
.el .SS "\f(CW$format\fP\->{Style}"
.IX Subsection "$format->{Style}"
Returns true if the format is a Style format.
.SH "Font"
.IX Header "Font"
\&\fISpreadsheet::ParseExcel::Font\fR
.PP
Format class has these properties:
.SH "Font Properties"
.IX Header "Font Properties"
.Vb 9
\&    $font\->{Name}
\&    $font\->{Bold}
\&    $font\->{Italic}
\&    $font\->{Height}
\&    $font\->{Underline}
\&    $font\->{UnderlineStyle}
\&    $font\->{Color}
\&    $font\->{Strikeout}
\&    $font\->{Super}
.Ve
.ie n .SS "$font\->{Name}"
.el .SS "\f(CW$font\fP\->{Name}"
.IX Subsection "$font->{Name}"
Returns the name of the font, for example 'Arial'.
.ie n .SS "$font\->{Bold}"
.el .SS "\f(CW$font\fP\->{Bold}"
.IX Subsection "$font->{Bold}"
Returns true if the font is bold.
.ie n .SS "$font\->{Italic}"
.el .SS "\f(CW$font\fP\->{Italic}"
.IX Subsection "$font->{Italic}"
Returns true if the font is italic.
.ie n .SS "$font\->{Height}"
.el .SS "\f(CW$font\fP\->{Height}"
.IX Subsection "$font->{Height}"
Returns the size (height) of the font.
.ie n .SS "$font\->{Underline}"
.el .SS "\f(CW$font\fP\->{Underline}"
.IX Subsection "$font->{Underline}"
Returns true if the font in underlined.
.ie n .SS "$font\->{UnderlineStyle}"
.el .SS "\f(CW$font\fP\->{UnderlineStyle}"
.IX Subsection "$font->{UnderlineStyle}"
Returns the style of an underlined font where the value has the following meaning:
.PP
.Vb 5
\&     0 => None
\&     1 => Single
\&     2 => Double
\&    33 => Single accounting
\&    34 => Double accounting
.Ve
.ie n .SS "$font\->{Color}"
.el .SS "\f(CW$font\fP\->{Color}"
.IX Subsection "$font->{Color}"
Returns the color index for the font. The mapping to an \s-1RGB\s0 color is defined by each workbook.
.PP
The index can be converted to a \s-1RGB\s0 string using the \f(CW\*(C`$workbook\-\*(C'\fR\fIColorIdxToRGB()\fR> Parser method.
.PP
(Older versions of \f(CW\*(C`Spreadsheet::ParseExcel\*(C'\fR provided the \f(CW\*(C`ColorIdxToRGB\*(C'\fR class method, which is deprecated.)
.ie n .SS "$font\->{Strikeout}"
.el .SS "\f(CW$font\fP\->{Strikeout}"
.IX Subsection "$font->{Strikeout}"
Returns true if the font has the strikeout property set.
.ie n .SS "$font\->{Super}"
.el .SS "\f(CW$font\fP\->{Super}"
.IX Subsection "$font->{Super}"
Returns one of the following values if the superscript or subscript property of the font is set:
.PP
.Vb 3
\&    0 => None
\&    1 => Superscript
\&    2 => Subscript
.Ve
.SH "Formatter Class"
.IX Header "Formatter Class"
Formatters can be passed to the \f(CW\*(C`parse()\*(C'\fR method to deal with Unicode or Asian formatting.
.PP
Spreadsheet::ParseExcel includes 2 formatter classes. \f(CW\*(C`FmtDefault\*(C'\fR and \f(CW\*(C`FmtJapanese\*(C'\fR. It is also possible to create a user defined formatting class.
.PP
The formatter class \f(CW\*(C`Spreadsheet::ParseExcel::Fmt*\*(C'\fR should provide the following functions:
.ie n .SS "ChkType($self, $is_numeric, $format_index)"
.el .SS "ChkType($self, \f(CW$is_numeric\fP, \f(CW$format_index\fP)"
.IX Subsection "ChkType($self, $is_numeric, $format_index)"
Method to check the type of data in the cell. Should return \f(CW\*(C`Date\*(C'\fR, \f(CW\*(C`Numeric\*(C'\fR or \f(CW\*(C`Text\*(C'\fR. It is passed the following parameters:
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
A scalar reference to the Formatter object.
.ie n .IP "$is_numeric" 4
.el .IP "\f(CW$is_numeric\fR" 4
.IX Item "$is_numeric"
If true, the value seems to be number.
.ie n .IP "$format_index" 4
.el .IP "\f(CW$format_index\fR" 4
.IX Item "$format_index"
The index number for the cell Format object.
.ie n .SS "TextFmt($self, $string_data, $string_encoding)"
.el .SS "TextFmt($self, \f(CW$string_data\fP, \f(CW$string_encoding\fP)"
.IX Subsection "TextFmt($self, $string_data, $string_encoding)"
Converts the string data in the cell into the correct encoding.  It is passed the following parameters:
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
A scalar reference to the Formatter object.
.ie n .IP "$string_data" 4
.el .IP "\f(CW$string_data\fR" 4
.IX Item "$string_data"
The original string/text data.
.ie n .IP "$string_encoding" 4
.el .IP "\f(CW$string_encoding\fR" 4
.IX Item "$string_encoding"
The character encoding of original string/text.
.ie n .SS "ValFmt($self, $cell, $workbook)"
.el .SS "ValFmt($self, \f(CW$cell\fP, \f(CW$workbook\fP)"
.IX Subsection "ValFmt($self, $cell, $workbook)"
Convert the original unformatted cell value into the appropriate formatted value. For instance turn a number into a formatted date.  It is passed the following parameters:
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
A scalar reference to the Formatter object.
.ie n .IP "$cell" 4
.el .IP "\f(CW$cell\fR" 4
.IX Item "$cell"
A scalar reference to the Cell object.
.ie n .IP "$workbook" 4
.el .IP "\f(CW$workbook\fR" 4
.IX Item "$workbook"
A scalar reference to the Workbook object.
.ie n .SS "FmtString($self, $cell, $workbook)"
.el .SS "FmtString($self, \f(CW$cell\fP, \f(CW$workbook\fP)"
.IX Subsection "FmtString($self, $cell, $workbook)"
Get the format string for the Cell.  It is passed the following parameters:
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
A scalar reference to the Formatter object.
.ie n .IP "$cell" 4
.el .IP "\f(CW$cell\fR" 4
.IX Item "$cell"
A scalar reference to the Cell object.
.ie n .IP "$workbook" 4
.el .IP "\f(CW$workbook\fR" 4
.IX Item "$workbook"
A scalar reference to the Workbook object.
.SH "Reducing the memory usage of Spreadsheet::ParseExcel"
.IX Header "Reducing the memory usage of Spreadsheet::ParseExcel"
In some cases a \f(CW\*(C`Spreadsheet::ParseExcel\*(C'\fR application may consume a lot of memory when processing a large Excel file and, as a result, may fail to complete. The following explains why this can occur and how to resolve it.
.PP
\&\f(CW\*(C`Spreadsheet::ParseExcel\*(C'\fR processes an Excel file in two stages. In the first stage it extracts the Excel binary stream from the \s-1OLE\s0 container file using \f(CW\*(C`OLE::Storage_Lite\*(C'\fR. In the second stage it parses the binary stream to read workbook, worksheet and cell data which it then stores in memory. The majority of the memory usage is required for storing cell data.
.PP
The reason for this is that as the Excel file is parsed and each cell is encountered a cell handling function creates a relatively large nested cell object that contains the cell value and all of the data that relates to the cell formatting. For large files (a 10MB Excel file on a 256MB system) this overhead can cause the system to grind to a halt.
.PP
However, in a lot of cases when an Excel file is being processed the only information that is required are the cell values. In these cases it is possible to avoid most of the memory overhead by specifying your own cell handling function and by telling Spreadsheet::ParseExcel not to store the parsed cell data. This is achieved by passing a cell handler function to \f(CW\*(C`new()\*(C'\fR when creating the parse object. Here is an example.
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    use strict;
\&    use Spreadsheet::ParseExcel;
\&
\&    my $parser = Spreadsheet::ParseExcel\->new(
\&        CellHandler => \e&cell_handler,
\&        NotSetCell  => 1
\&    );
\&
\&    my $workbook = $parser\->parse(\*(Aqfile.xls\*(Aq);
\&
\&    sub cell_handler {
\&
\&        my $workbook    = $_[0];
\&        my $sheet_index = $_[1];
\&        my $row         = $_[2];
\&        my $col         = $_[3];
\&        my $cell        = $_[4];
\&
\&        # Do something useful with the formatted cell value
\&        print $cell\->value(), "\en";
\&
\&    }
.Ve
.PP
The user specified cell handler is passed as a code reference to \f(CW\*(C`new()\*(C'\fR along with the parameter \f(CW\*(C`NotSetCell\*(C'\fR which tells Spreadsheet::ParseExcel not to store the parsed cell. Note, you don't have to iterate over the rows and columns, this happens automatically as part of the parsing.
.PP
The cell handler is passed 5 arguments. The first, \f(CW$workbook\fR, is a reference to the \f(CW\*(C`Spreadsheet::ParseExcel::Workbook\*(C'\fR object that represent the parsed workbook. This can be used to access any of the \f(CW\*(C`Spreadsheet::ParseExcel::Workbook\*(C'\fR methods, see \*(L"Workbook\*(R". The second \f(CW$sheet_index\fR is the zero-based index of the worksheet being parsed. The third and fourth, \f(CW$row\fR and \f(CW$col\fR, are the zero-based row and column number of the cell. The fifth, \f(CW$cell\fR, is a reference to the \f(CW\*(C`Spreadsheet::ParseExcel::Cell\*(C'\fR object. This is used to extract the data from the cell. See \*(L"Cell\*(R" for more information.
.PP
This technique can be useful if you are writing an Excel to database filter since you can put your \s-1DB\s0 calls in the cell handler.
.PP
If you don't want all of the data in the spreadsheet you can add some control logic to the cell handler. For example we can extend the previous example so that it only prints the first 10 rows of the first two worksheets in the parsed workbook by adding some \f(CW\*(C`if()\*(C'\fR statements to the cell handler:
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    use strict;
\&    use Spreadsheet::ParseExcel;
\&
\&    my $parser = Spreadsheet::ParseExcel\->new(
\&        CellHandler => \e&cell_handler,
\&        NotSetCell  => 1
\&    );
\&
\&    my $workbook = $parser\->parse(\*(Aqfile.xls\*(Aq);
\&
\&    sub cell_handler {
\&
\&        my $workbook    = $_[0];
\&        my $sheet_index = $_[1];
\&        my $row         = $_[2];
\&        my $col         = $_[3];
\&        my $cell        = $_[4];
\&
\&        # Skip some worksheets and rows (inefficiently).
\&        return if $sheet_index >= 3;
\&        return if $row >= 10;
\&
\&        # Do something with the formatted cell value
\&        print $cell\->value(), "\en";
\&
\&    }
.Ve
.PP
However, this still processes the entire workbook. If you wish to save some additional processing time you can abort the parsing after you have read the data that you want, using the workbook \f(CW\*(C`ParseAbort\*(C'\fR method:
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    use strict;
\&    use Spreadsheet::ParseExcel;
\&
\&    my $parser = Spreadsheet::ParseExcel\->new(
\&        CellHandler => \e&cell_handler,
\&        NotSetCell  => 1
\&    );
\&
\&    my $workbook = $parser\->parse(\*(Aqfile.xls\*(Aq);
\&
\&    sub cell_handler {
\&
\&        my $workbook    = $_[0];
\&        my $sheet_index = $_[1];
\&        my $row         = $_[2];
\&        my $col         = $_[3];
\&        my $cell        = $_[4];
\&
\&        # Skip some worksheets and rows (more efficiently).
\&        if ( $sheet_index >= 1 and $row >= 10 ) {
\&            $workbook\->ParseAbort(1);
\&            return;
\&        }
\&
\&        # Do something with the formatted cell value
\&        print $cell\->value(), "\en";
\&
\&    }
.Ve
.SH "Decryption"
.IX Header "Decryption"
If a workbook is \*(L"protected\*(R" then Excel will encrypt the file whether a password is supplied or not. As of version 0.59 Spreadsheet::ParseExcel supports decrypting Excel workbooks using a default or user supplied password. However, only the following encryption scheme is supported:
.PP
.Vb 1
\&    Office 97/2000 Compatible encryption
.Ve
.PP
The following encryption methods are not supported:
.PP
.Vb 9
\&    Weak Encryption (XOR)
\&    RC4, Microsoft Base Cryptographic Provider v1.0
\&    RC4, Microsoft Base DSS and Diffie\-Hellman Cryptographic Provider
\&    RC4, Microsoft DH SChannel Cryptographic Provider
\&    RC4, Microsoft Enhanced Cryptographic Provider v1.0
\&    RC4, Microsoft Enhanced DSS and Diffie\-Hellman Cryptographic Provider
\&    RC4, Microsoft Enhanced RSA and AES Cryptographic Provider
\&    RC4, Microsoft RSA SChannel Cryptographic Provider
\&    RC4, Microsoft Strong Cryptographic Provider
.Ve
.PP
See the following for more information on Excel encryption: <http://office.microsoft.com/en\-us/office\-2003\-resource\-kit/important\-aspects\-of\-password\-and\-encryption\-protection\-HA001140311.aspx>.
.SH "KNOWN PROBLEMS"
.IX Header "KNOWN PROBLEMS"
.IP "\(bu" 4
Issues reported by users: <http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet\-ParseExcel>
.IP "\(bu" 4
This module cannot read the values of formulas from files created with Spreadsheet::WriteExcel unless the user specified the values when creating the file (which is generally not the case). The reason for this is that Spreadsheet::WriteExcel writes the formula but not the formula result since it isn't in a position to calculate arbitrary Excel formulas without access to Excel's formula engine.
.IP "\(bu" 4
If Excel has date fields where the specified format is equal to the system-default for the short-date locale, Excel does not store the format, but defaults to an internal format which is system dependent. In these cases ParseExcel uses the date format 'yyyy\-mm\-dd'.
.SH "REPORTING A BUG"
.IX Header "REPORTING A BUG"
Bugs can be reported via rt.cpan.org. See the following for instructions on bug reporting for Spreadsheet::ParseExcel
.PP
<http://rt.cpan.org/Public/Dist/Display.html?Name=Spreadsheet\-ParseExcel>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
xls2csv by Ken Prows <http://search.cpan.org/~ken/xls2csv\-1.06/script/xls2csv>.
.IP "\(bu" 4
xls2csv and xlscat by H.Merijn Brand (these utilities are part of Spreadsheet::Read, see below).
.IP "\(bu" 4
excel2txt by Ken Youens-Clark, <http://search.cpan.org/~kclark/excel2txt/excel2txt>. This is an excellent example of an Excel filter using Spreadsheet::ParseExcel. It can produce \s-1CSV,\s0 Tab delimited, Html, \s-1XML\s0 and Yaml.
.IP "\(bu" 4
XLSperl by Jon Allen <http://search.cpan.org/~jonallen/XLSperl/bin/XLSperl>. This application allows you to use Perl \*(L"one-liners\*(R" with Microsoft Excel files.
.IP "\(bu" 4
Spreadsheet::XLSX <http://search.cpan.org/~dmow/Spreadsheet\-XLSX/lib/Spreadsheet/XLSX.pm> by Dmitry Ovsyanko. A module with a similar interface to Spreadsheet::ParseExcel for parsing Excel 2007 \s-1XLSX\s0 OpenXML files.
.IP "\(bu" 4
Spreadsheet::Read <http://search.cpan.org/~hmbrand/Spreadsheet\-Read/Read.pm> by H.Merijn Brand. A single interface for reading several different spreadsheet formats.
.IP "\(bu" 4
Spreadsheet::WriteExcel <http://search.cpan.org/~jmcnamara/Spreadsheet\-WriteExcel/lib/Spreadsheet/WriteExcel.pm>. A perl module for creating new Excel files.
.IP "\(bu" 4
Spreadsheet::ParseExcel::SaveParser <http://search.cpan.org/~jmcnamara/Spreadsheet\-ParseExcel/lib/Spreadsheet/ParseExcel/SaveParser.pm>. This is a combination of Spreadsheet::ParseExcel and Spreadsheet::WriteExcel and it allows you to \*(L"rewrite\*(R" an Excel file. See the following example <http://search.cpan.org/~jmcnamara/Spreadsheet\-WriteExcel/lib/Spreadsheet/WriteExcel.pm#MODIFYING_AND_REWRITING_EXCEL_FILES>. It is part of the Spreadsheet::ParseExcel distro.
.IP "\(bu" 4
Text::CSV_XS <http://search.cpan.org/~hmbrand/Text\-CSV_XS/CSV_XS.pm> by H.Merijn Brand. A fast and rigorous module for reading and writing \s-1CSV\s0 data. Don't consider rolling your own \s-1CSV\s0 handling, use this module instead.
.SH "MAILING LIST"
.IX Header "MAILING LIST"
There is a Google group for discussing and asking questions about Spreadsheet::ParseExcel. This is a good place to search to see if your question has been asked before:  <http://groups\-beta.google.com/group/spreadsheet\-parseexcel/>
.SH "DONATIONS"
.IX Header "DONATIONS"
If you'd care to donate to the Spreadsheet::ParseExcel project, you can do so via PayPal: <http://tinyurl.com/7ayes>
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
The current maintenance work is directed towards making the documentation more useful, improving and simplifying the \s-1API,\s0 and improving the maintainability of the code base. After that new features will be added.
.IP "\(bu" 4
Fix open bugs and documentation for SaveParser.
.IP "\(bu" 4
Add Formula support, Hyperlink support, Named Range support.
.IP "\(bu" 4
Improve Spreadsheet::ParseExcel::SaveParser compatibility with Spreadsheet::WriteExcel.
.IP "\(bu" 4
Improve Unicode and other encoding support. This will probably require dropping support for perls prior to 5.8+.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
From Kawai Takanori:
.PP
First of all, I would like to acknowledge the following valuable programs and modules:
\&\s-1XHTML,\s0 OLE::Storage and Spreadsheet::WriteExcel.
.PP
In no particular order: Yamaji Haruna, Simamoto Takesi, Noguchi Harumi, Ikezawa Kazuhiro, Suwazono Shugo, Hirofumi Morisada, Michael Edwards, Kim Namusk, Slaven Rezic, Grant Stevens, H.Merijn Brand and many many people + Kawai Mikako.
.PP
Alexey Mazurin added the decryption facility.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
Because this software is licensed free of charge, there is no warranty for the software, to the extent permitted by applicable law. Except when otherwise stated in writing the copyright holders and/or other parties provide the software \*(L"as is\*(R" without warranty of any kind, either expressed or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose. The entire risk as to the quality and performance of the software is with you. Should the software prove defective, you assume the cost of all necessary servicing, repair, or correction.
.PP
In no event unless required by applicable law or agreed to in writing will any copyright holder, or any other party who may modify and/or redistribute the software as permitted by the above licence, be liable to you for damages, including any general, special, incidental, or consequential damages arising out of the use or inability to use the software (including but not limited to loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the software to operate with any other software), even if such holder or other party has been advised of the possibility of such damages.
.SH "LICENSE"
.IX Header "LICENSE"
Either the Perl Artistic Licence <http://dev.perl.org/licenses/artistic.html> or the \s-1GPL \s0<http://www.opensource.org/licenses/gpl\-license.php>
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainer 0.60+: Douglas Wilson dougw@cpan.org
.PP
Maintainer 0.40\-0.59: John McNamara jmcnamara@cpan.org
.PP
Maintainer 0.27\-0.33: Gabor Szabo szabgab@cpan.org
.PP
Original author: Kawai Takanori (Hippo2000) kwitknr@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2014 Douglas Wilson
.PP
Copyright (c) 2009\-2013 John McNamara
.PP
Copyright (c) 2006\-2008 Gabor Szabo
.PP
Copyright (c) 2000\-2006 Kawai Takanori
.PP
All rights reserved. This is free software. You may distribute under the terms of either the \s-1GNU\s0 General Public License or the Artistic License.
