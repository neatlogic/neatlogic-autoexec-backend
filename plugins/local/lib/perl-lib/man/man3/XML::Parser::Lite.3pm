.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "XML::Parser::Lite 3"
.TH XML::Parser::Lite 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Parser::Lite \- Lightweight pure\-perl XML Parser (based on regexps)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::Parser::Lite;
\&
\&  $p1 = new XML::Parser::Lite;
\&  $p1\->setHandlers(
\&    Start => sub { shift; print "start: @_\en" },
\&    Char => sub { shift; print "char: @_\en" },
\&    End => sub { shift; print "end: @_\en" },
\&  );
\&  $p1\->parse(\*(Aq<foo id="me">Hello World!</foo>\*(Aq);
\&
\&  $p2 = new XML::Parser::Lite
\&    Handlers => {
\&      Start => sub { shift; print "start: @_\en" },
\&      Char => sub { shift; print "char: @_\en" },
\&      End => sub { shift; print "end: @_\en" },
\&    }
\&  ;
\&  $p2\->parse(\*(Aq<foo id="me">Hello <bar>cruel</bar> World!</foo>\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements an \s-1XML\s0 parser with a interface similar to
XML::Parser. Though not all callbacks are supported, you should be able to
use it in the same way you use XML::Parser. Due to using experimental regexp
features it'll work only on Perl 5.6 and above and may behave differently on
different platforms.
.PP
Note that you cannot use regular expressions or split in callbacks. This is
due to a limitation of perl's regular expression implementation (which is
not re-entrant).
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new"
.IX Subsection "new"
Constructor.
.PP
The \fInew()\fR method returns the object called on when called as object method.
This behaviour was inherited from SOAP::Lite,
which XML::Parser::Lite was split out from.
This means that the following effectively is
a no-op if \f(CW$obj\fR is a object:
.PP
.Vb 1
\& $obj = $obj\->new();
.Ve
.PP
New accepts a single named parameter, \f(CW\*(C`Handlers\*(C'\fR with a hash ref as value:
.PP
.Vb 7
\& my $parser = XML::Parser::Lite\->new(
\&    Handlers => {
\&        Start => sub { shift; print "start: @_\en" },
\&        Char => sub { shift; print "char: @_\en" },
\&        End => sub { shift; print "end: @_\en" },
\&    }
\& );
.Ve
.PP
The handlers given will be passed to setHandlers.
.SS "setHandlers"
.IX Subsection "setHandlers"
Sets (or resets) the parsing handlers. Accepts a hash with the handler names
and handler code references as parameters. Passing \f(CW\*(C`undef\*(C'\fR instead of a
code reference replaces the handler by a no-op.
.PP
The following handlers can be set:
.PP
.Vb 5
\& Init
\& Start
\& Char
\& End
\& Final
.Ve
.PP
All other handlers are ignored.
.PP
Calling setHandlers without parameters resets all handlers to no-ops.
.SS "parse"
.IX Subsection "parse"
Parses the \s-1XML\s0 given. In contrast to XML::Parser's parse
method, \fIparse()\fR only parses strings.
.SH "Handler methods"
.IX Header "Handler methods"
.SS "Init"
.IX Subsection "Init"
Called before parsing starts. You should perform any necessary initializations
in Init.
.SS "Start"
.IX Subsection "Start"
Called at the start of each \s-1XML\s0 node. See XML::Parser for details.
.SS "Char"
.IX Subsection "Char"
Called for each character sequence. May be called multiple times for the
characters contained in an \s-1XML\s0 node (even for every single character).
Your implementation has to make sure that it captures all characters.
.SS "End"
.IX Subsection "End"
Called at the end of each \s-1XML\s0 node. See XML::Parser for details
.SS "Comment"
.IX Subsection "Comment"
See XML::Parser for details
.SS "XMLDecl"
.IX Subsection "XMLDecl"
See XML::Parser for details
.SS "Doctype"
.IX Subsection "Doctype"
See XML::Parser for details
.SS "Final"
.IX Subsection "Final"
Called at the end of the parsing process. You should perform any necessary
cleanup here.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Parser \- a full-blown \s-1XML\s0 Parser, on which XML::Parser::Lite is based.
Requires a C compiler and the \fIexpat\fR \s-1XML\s0 parser.
.PP
XML::Parser::LiteCopy \- a fork in XML::Parser::Lite::Tree.
.PP
\&\s-1YAX\s0 \- another pure-perl module for \s-1XML\s0 parsing.
.PP
XML::Parser::REX \- another module that parses \s-1XML\s0 with regular expressions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2007 Paul Kulchenko. All rights reserved.
.PP
Copyright (C) 2008\- Martin Kutter. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
This parser is based on \*(L"shallow parser\*(R"
<http://www.cs.sfu.ca/~cameron/REX.html>
Copyright (c) 1998, Robert D. Cameron.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Kulchenko (paulclinger@yahoo.com)
.PP
Martin Kutter (martin.kutter@fen\-net.de)
.PP
Additional handlers supplied by Adam Leggett.
