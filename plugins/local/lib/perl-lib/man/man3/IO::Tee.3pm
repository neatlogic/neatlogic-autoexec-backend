.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tee 3"
.TH Tee 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Tee \- Multiplex output to multiple output handles
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::Tee;
\&
\&    $tee = IO::Tee\->new($handle1, $handle2);
\&    print $tee "foo", "bar";
\&    my $input = <$tee>;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`IO::Tee\*(C'\fR objects can be used to multiplex input and output in two
different ways.  The first way is to multiplex output to zero or more
output handles.  The \f(CW\*(C`IO::Tee\*(C'\fR constructor, given a list of output
handles, returns a tied handle that can be written to.  When written
to (using print or printf), the \f(CW\*(C`IO::Tee\*(C'\fR object multiplexes the
output to the list of handles originally passed to the constructor.
As a shortcut, you can also directly pass a string or an array
reference to the constructor, in which case \f(CW\*(C`IO::File::new\*(C'\fR is called
for you with the specified argument or arguments.
.PP
The second way is to multiplex input from one input handle to zero or
more output handles as it is being read.  The \f(CW\*(C`IO::Tee\*(C'\fR constructor,
given an input handle followed by a list of output handles, returns a
tied handle that can be read from as well as written to.  When written
to, the \f(CW\*(C`IO::Tee\*(C'\fR object multiplexes the output to all handles passed
to the constructor, as described in the previous paragraph.  When read
from, the \f(CW\*(C`IO::Tee\*(C'\fR object reads from the input handle given as the
first argument to the \f(CW\*(C`IO::Tee\*(C'\fR constructor, then writes any data
read to the output handles given as the remaining arguments to the
constructor.
.PP
The \f(CW\*(C`IO::Tee\*(C'\fR class supports certain \f(CW\*(C`IO::Handle\*(C'\fR and \f(CW\*(C`IO::File\*(C'\fR
methods related to input and output.  In particular, the following
methods will iterate themselves over all handles associated with the
\&\f(CW\*(C`IO::Tee\*(C'\fR object, and return \s-1TRUE\s0 indicating success if and only if
all associated handles returned \s-1TRUE\s0 indicating success:
.IP "close" 4
.IX Item "close"
.PD 0
.IP "truncate" 4
.IX Item "truncate"
.IP "write" 4
.IX Item "write"
.IP "syswrite" 4
.IX Item "syswrite"
.IP "format_write" 4
.IX Item "format_write"
.IP "formline" 4
.IX Item "formline"
.IP "fcntl" 4
.IX Item "fcntl"
.IP "ioctl" 4
.IX Item "ioctl"
.IP "flush" 4
.IX Item "flush"
.IP "clearerr" 4
.IX Item "clearerr"
.IP "seek" 4
.IX Item "seek"
.PD
.PP
The following methods perform input multiplexing as described above:
.IP "read" 4
.IX Item "read"
.PD 0
.IP "sysread" 4
.IX Item "sysread"
.IP "readline" 4
.IX Item "readline"
.IP "getc" 4
.IX Item "getc"
.IP "gets" 4
.IX Item "gets"
.IP "eof" 4
.IX Item "eof"
.IP "getline" 4
.IX Item "getline"
.IP "getlines" 4
.IX Item "getlines"
.PD
.PP
The following methods can be used to set (but not retrieve) the
current values of output-related state variables on all associated
handles:
.IP "autoflush" 4
.IX Item "autoflush"
.PD 0
.IP "output_field_separator" 4
.IX Item "output_field_separator"
.IP "output_record_separator" 4
.IX Item "output_record_separator"
.IP "format_page_number" 4
.IX Item "format_page_number"
.IP "format_lines_per_page" 4
.IX Item "format_lines_per_page"
.IP "format_lines_left" 4
.IX Item "format_lines_left"
.IP "format_name" 4
.IX Item "format_name"
.IP "format_top_name" 4
.IX Item "format_top_name"
.IP "format_line_break_characters" 4
.IX Item "format_line_break_characters"
.IP "format_formfeed" 4
.IX Item "format_formfeed"
.PD
.PP
The following methods are directly passed on to the input handle given
as the first argument to the \f(CW\*(C`IO::Tee\*(C'\fR constructor:
.IP "input_record_separator" 4
.IX Item "input_record_separator"
.PD 0
.IP "input_line_number" 4
.IX Item "input_line_number"
.PD
.PP
Note that the return value of input multiplexing methods (such as
\&\f(CW\*(C`print\*(C'\fR) is always the return value of the input action, not the
return value of subsequent output actions.  In particular, no error is
indicated by the return value if the input action itself succeeds but
subsequent output multiplexing fails.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 2
\&    use IO::Tee;
\&    use IO::File;
\&
\&    my $tee = new IO::Tee(\e*STDOUT,
\&        new IO::File(">tt1.out"), ">tt2.out");
\&
\&    print join(\*(Aq \*(Aq, $tee\->handles), "\en";
\&
\&    for (1..10) { print $tee $_, "\en" }
\&    for (1..10) { $tee\->print($_, "\en") }
\&    $tee\->flush;
\&
\&    $tee = new IO::Tee(\*(Aq</etc/passwd\*(Aq, \e*STDOUT);
\&    my @lines = <$tee>;
\&    print scalar(@lines);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Chung-chieh Shan, ken@digitas.harvard.edu
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998\-2001 Chung-chieh Shan.  All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlfunc, IO::Handle, IO::File.
