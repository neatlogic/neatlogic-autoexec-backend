.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Config::Properties 3"
.TH Config::Properties 3 "2021-02-09" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Properties \- Read and write property files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Config::Properties;
\&
\&  # reading...
\&
\&  open my $fh, \*(Aq<\*(Aq, \*(Aqmy_config.props\*(Aq
\&    or die "unable to open configuration file";
\&
\&  my $properties = Config::Properties\->new();
\&  $properties\->load($fh);
\&
\&  $value = $properties\->getProperty($key);
\&
\&
\&  # saving...
\&
\&  open my $fh, \*(Aq>\*(Aq, \*(Aqmy_config.props\*(Aq
\&    or die "unable to open configuration file for writing";
\&
\&  $properties\->setProperty($key, $value);
\&
\&  $properties\->format(\*(Aq%s => %s\*(Aq);
\&  $properties\->store($fh, $header );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::Properties is a near implementation of the
java.util.Properties \s-1API.\s0  It is designed to allow easy reading,
writing and manipulation of Java-style property files.
.PP
The format of a Java-style property file is that of a key-value pair
separated by either whitespace, the colon (:) character, or the equals
(=) character.  Whitespace before the key and on either side of the
separator is ignored.
.PP
Lines that begin with either a hash (#) or a bang (!) are considered
comment lines and ignored.
.PP
A backslash (\e) at the end of a line signifies a continuation and the
next line is counted as part of the current line (minus the backslash,
any whitespace after the backslash, the line break, and any whitespace
at the beginning of the next line).
.PP
The official references used to determine this format can be found in
the Java \s-1API\s0 docs for java.util.Properties at
<http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html>.
.PP
When a property file is saved it is in the format \*(L"key=value\*(R" for each
line. This can be changed by setting the format attribute using either
\&\f(CW$object\fR\->format( \f(CW$format_string\fR ) or \f(CW$object\fR\->setFormat(
\&\f(CW$format_string\fR ) (they do the same thing). The format string is fed to
printf and must contain exactly two \f(CW%s\fR format characters. The first
will be replaced with the key of the property and the second with the
value. The string can contain no other printf control characters, but
can be anything else. A newline will be automatically added to the end
of the string. The current format string can be obtained by using
\&\f(CW$object\fR\->\fBformat()\fR (with no arguments) or \f(CW$object\fR\->\fBgetFormat()\fR.
.PP
If a recent version of Text::Wrap is available, long lines are
conveniently wrapped when saving.
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`Config::Property\*(C'\fR objects have this set of methods available:
.IP "Config::Properties\->new(%opts)" 4
.IX Item "Config::Properties->new(%opts)"
Creates a new Config::Properties object.
.Sp
The optional arguments are as follows:
.RS 4
.ie n .IP "file => $filename" 4
.el .IP "file => \f(CW$filename\fR" 4
.IX Item "file => $filename"
Opens and reads the entries from the given properties file
.ie n .IP "format => $format" 4
.el .IP "format => \f(CW$format\fR" 4
.IX Item "format => $format"
Sets the format using for saving the properties to a file. See
\&\*(L"setFormat\*(R".
.IP "wrap => 0" 4
.IX Item "wrap => 0"
Disables wrapping of long lines when saving the properties to a file.
.ie n .IP "defaults => $defaults" 4
.el .IP "defaults => \f(CW$defaults\fR" 4
.IX Item "defaults => $defaults"
Default configuration values.
.Sp
The given parameter can be a hash reference or another
Config::Properties object.
.Sp
In that way several configuration objects can be chained. For
instance:
.Sp
.Vb 5
\&  my %defaults = (...);
\&  my $global_config = Config::Properties\->new(file => \*(Aq/etc/foo.properties\*(Aq,
\&                                              defaults => \e%defaults);
\&  my $user_config = Config::Properties\->new(file => \*(Aq/home/jsmith/.foo/foo.properties\*(Aq,
\&                                            defaults => $global_config);
.Ve
.IP "order => 'keep'|'alpha'|'none'" 4
.IX Item "order => 'keep'|'alpha'|'none'"
Sets how to order the properties when saved to a file or when returned
by \f(CW\*(C`properties\*(C'\fR and \f(CW\*(C`propertyNames\*(C'\fR methods.
.Sp
\&\f(CW\*(C`alpha\*(C'\fR sorts the keys in alphanumeric order. \f(CW\*(C`keep\*(C'\fR keeps the order
of the properties as added or read from a file. \f(CW\*(C`none\*(C'\fR returns the
properties unordered.
.ie n .IP "encoding => $encoding" 4
.el .IP "encoding => \f(CW$encoding\fR" 4
.IX Item "encoding => $encoding"
\&\s-1IO\s0 encoding used to read the configuration file. See PerlIO.
.Sp
When \f(CW\*(C`load\*(C'\fR is called the given encoding is used unless the file
handler already has a encoding layer applied.
.Sp
\&\f(CW\*(C`latin1\*(C'\fR is used as the default encoding (as specified in the Java
properties specification).
.IP "be_like_java => 1" 4
.IX Item "be_like_java => 1"
When this feature is enabled, the module will try to mimic the Java
implementation as much as possible when saving files.
.Sp
Currently, some escaping rules are changed and line wrapping is
disabled.
.RE
.RS 4
.RE
.IP "Config::Properties\->new($defaults)" 4
.IX Item "Config::Properties->new($defaults)"
Calling \f(CW\*(C`new\*(C'\fR in this way is deprecated.
.ie n .IP "$p\->getProperty($k, $default, $default2, ...)" 4
.el .IP "\f(CW$p\fR\->getProperty($k, \f(CW$default\fR, \f(CW$default2\fR, ...)" 4
.IX Item "$p->getProperty($k, $default, $default2, ...)"
return property \f(CW$k\fR or when not defined, the first defined
\&\f(CW\*(C`$default*\*(C'\fR.
.ie n .IP "$p\->requireProperty($k, $default, $default2, ...)" 4
.el .IP "\f(CW$p\fR\->requireProperty($k, \f(CW$default\fR, \f(CW$default2\fR, ...)" 4
.IX Item "$p->requireProperty($k, $default, $default2, ...)"
this method is similar to \f(CW\*(C`getProperty\*(C'\fR but dies if the requested
property is not found.
.ie n .IP "$p\->setProperty($k, $v)" 4
.el .IP "\f(CW$p\fR\->setProperty($k, \f(CW$v\fR)" 4
.IX Item "$p->setProperty($k, $v)"
set property \f(CW$k\fR value to \f(CW$v\fR.
.ie n .IP "$p\->changeProperty($k, $v)" 4
.el .IP "\f(CW$p\fR\->changeProperty($k, \f(CW$v\fR)" 4
.IX Item "$p->changeProperty($k, $v)"
.PD 0
.ie n .IP "$p\->changeProperty($k, $v, $default, $default2, ...)" 4
.el .IP "\f(CW$p\fR\->changeProperty($k, \f(CW$v\fR, \f(CW$default\fR, \f(CW$default2\fR, ...)" 4
.IX Item "$p->changeProperty($k, $v, $default, $default2, ...)"
.PD
method similar to \f(CW\*(C`setPropery\*(C'\fR but that does nothing when the new
value is equal to the one returned by \f(CW\*(C`getProperty\*(C'\fR.
.Sp
An example shows why it is useful:
.Sp
.Vb 2
\&  my $defaults=Config::Properties\->new();
\&  $defaults\->setProperty(foo => \*(Aqbar\*(Aq);
\&
\&  my $p1=Config::Properties\->new($defaults);
\&  $p1\->setProperty(foo => \*(Aqbar\*(Aq);   # we set here!
\&  $p1\->store(FILE1); foo gets saved on the file
\&
\&  my $p2=Config::Properties\->new($defaults);
\&  $p2\->changeProperty(foo => \*(Aqbar\*(Aq); # does nothing!
\&  $p2\->store(FILE2); # foo doesn\*(Aqt get saved on the file
.Ve
.ie n .IP "$p\->deleteProperty($k)" 4
.el .IP "\f(CW$p\fR\->deleteProperty($k)" 4
.IX Item "$p->deleteProperty($k)"
.PD 0
.ie n .IP "$p\->deleteProperty($k, $recurse)" 4
.el .IP "\f(CW$p\fR\->deleteProperty($k, \f(CW$recurse\fR)" 4
.IX Item "$p->deleteProperty($k, $recurse)"
.PD
deletes property \f(CW$k\fR from the object.
.Sp
If \f(CW$recurse\fR is true, it also deletes any \f(CW$k\fR property from the
default properties object.
.ie n .IP "$p\->properties" 4
.el .IP "\f(CW$p\fR\->properties" 4
.IX Item "$p->properties"
returns a flatten hash with all the property key/value pairs, i.e.:
.Sp
.Vb 1
\&  my %props=$p\->properties;
.Ve
.ie n .IP "$p\->getProperties" 4
.el .IP "\f(CW$p\fR\->getProperties" 4
.IX Item "$p->getProperties"
returns a hash reference with all the properties (including those passed as defaults).
.ie n .IP "$p\->propertyNames;" 4
.el .IP "\f(CW$p\fR\->propertyNames;" 4
.IX Item "$p->propertyNames;"
returns the names of all the properties (including those passed as defaults).
.ie n .IP "$p\->\fBsplitToTree()\fR" 4
.el .IP "\f(CW$p\fR\->\fBsplitToTree()\fR" 4
.IX Item "$p->splitToTree()"
.PD 0
.ie n .IP "$p\->splitToTree($regexp)" 4
.el .IP "\f(CW$p\fR\->splitToTree($regexp)" 4
.IX Item "$p->splitToTree($regexp)"
.ie n .IP "$p\->splitToTree($regexp, $start)" 4
.el .IP "\f(CW$p\fR\->splitToTree($regexp, \f(CW$start\fR)" 4
.IX Item "$p->splitToTree($regexp, $start)"
.PD
builds a tree from the properties, splitting the keys with the regular
expression \f(CW$re\fR (or \f(CW\*(C`/\e./\*(C'\fR by default). For instance:
.Sp
.Vb 7
\&  my $data = <<EOD;
\&  name = pete
\&  date.birth = 1958\-09\-12
\&  date.death = 2004\-05\-11
\&  surname = moo
\&  surname.length = 3
\&  EOD
\&
\&  open my $fh, \*(Aq<\*(Aq, \e$data;
\&  $cfg\->load();
\&  my $tree = $cfg\->splitToTree();
.Ve
.Sp
makes...
.Sp
.Vb 5
\&  $tree = { date => { birth => \*(Aq1958\-09\-12\*(Aq,
\&                      death => \*(Aq2004\-05\-11\*(Aq },
\&            name => \*(Aqpete\*(Aq,
\&            surname => { \*(Aq\*(Aq => \*(Aqmoo\*(Aq,
\&                         length => \*(Aq3\*(Aq } };
.Ve
.Sp
The \f(CW$start\fR parameter allows to split only a subset of the
properties. For instance, with the same data as on the previous
example:
.Sp
.Vb 1
\&   my $subtree = $cfg\->splitToTree(qr/\e./, \*(Aqdate\*(Aq);
.Ve
.Sp
makes...
.Sp
.Vb 2
\&  $tree = { birth => \*(Aq1958\-09\-12\*(Aq,
\&            death => \*(Aq2004\-05\-11\*(Aq };
.Ve
.ie n .IP "$p\->setFromTree($tree)" 4
.el .IP "\f(CW$p\fR\->setFromTree($tree)" 4
.IX Item "$p->setFromTree($tree)"
.PD 0
.ie n .IP "$p\->setFromTree($tree, $separator)" 4
.el .IP "\f(CW$p\fR\->setFromTree($tree, \f(CW$separator\fR)" 4
.IX Item "$p->setFromTree($tree, $separator)"
.ie n .IP "$p\->setFromTree($tree, $separator, $start)" 4
.el .IP "\f(CW$p\fR\->setFromTree($tree, \f(CW$separator\fR, \f(CW$start\fR)" 4
.IX Item "$p->setFromTree($tree, $separator, $start)"
.PD
This method sets properties from a tree of Perl hashes and arrays. It
is the opposite of \f(CW\*(C`splitToTree\*(C'\fR.
.Sp
\&\f(CW$separator\fR is the string used to join the parts of the property
names. The default value is a dot (\f(CW\*(C`.\*(C'\fR).
.Sp
\&\f(CW$start\fR is a string used as the starting point for the property
names.
.Sp
For instance:
.Sp
.Vb 6
\&  my $c = Config::Properties\->new;
\&  $c\->setFromTree( { foo => { \*(Aq\*(Aq => one,
\&                              hollo => [2, 3, 4, 1] },
\&                     bar => \*(Aqdoo\*(Aq },
\&                   \*(Aq\->\*(Aq,
\&                   \*(Aqmama\*(Aq)
\&
\&  # sets properties:
\&  #      mama\->bar = doo
\&  #      mama\->foo = one
\&  #      mama\->foo\->hollo\->0 = 2
\&  #      mama\->foo\->hollo\->1 = 3
\&  #      mama\->foo\->hollo\->2 = 4
\&  #      mama\->foo\->hollo\->3 = 1
.Ve
.ie n .IP "$p\->changeFromTree($tree)" 4
.el .IP "\f(CW$p\fR\->changeFromTree($tree)" 4
.IX Item "$p->changeFromTree($tree)"
.PD 0
.ie n .IP "$p\->changeFromTree($tree, $separator)" 4
.el .IP "\f(CW$p\fR\->changeFromTree($tree, \f(CW$separator\fR)" 4
.IX Item "$p->changeFromTree($tree, $separator)"
.ie n .IP "$p\->changeFromTree($tree, $separator, $start)" 4
.el .IP "\f(CW$p\fR\->changeFromTree($tree, \f(CW$separator\fR, \f(CW$start\fR)" 4
.IX Item "$p->changeFromTree($tree, $separator, $start)"
.PD
similar to \f(CW\*(C`setFromTree\*(C'\fR but internally uses \f(CW\*(C`changeProperty\*(C'\fR
instead of \f(CW\*(C`setProperty\*(C'\fR to set the property values.
.ie n .IP "$p\->load($file)" 4
.el .IP "\f(CW$p\fR\->load($file)" 4
.IX Item "$p->load($file)"
loads properties from the open file \f(CW$file\fR.
.Sp
Old properties on the object are discarded.
.ie n .IP "$p\->save($file)" 4
.el .IP "\f(CW$p\fR\->save($file)" 4
.IX Item "$p->save($file)"
.PD 0
.ie n .IP "$p\->save($file, $header)" 4
.el .IP "\f(CW$p\fR\->save($file, \f(CW$header\fR)" 4
.IX Item "$p->save($file, $header)"
.ie n .IP "$p\->store($file)" 4
.el .IP "\f(CW$p\fR\->store($file)" 4
.IX Item "$p->store($file)"
.ie n .IP "$p\->store($file, $header)" 4
.el .IP "\f(CW$p\fR\->store($file, \f(CW$header\fR)" 4
.IX Item "$p->store($file, $header)"
.PD
save the properties to the open file \f(CW$file\fR. Default properties are
not saved.
.ie n .IP "$p\->saveToString($header)" 4
.el .IP "\f(CW$p\fR\->saveToString($header)" 4
.IX Item "$p->saveToString($header)"
similar to \f(CW\*(C`save\*(C'\fR, but instead of saving to a file, it returns a
string with the content.
.ie n .IP "$p\->\fBgetFormat()\fR" 4
.el .IP "\f(CW$p\fR\->\fBgetFormat()\fR" 4
.IX Item "$p->getFormat()"
.PD 0
.ie n .IP "$p\->setFormat($f)" 4
.el .IP "\f(CW$p\fR\->setFormat($f)" 4
.IX Item "$p->setFormat($f)"
.PD
get/set the format string used when saving the object to a file.
.IX Xref "setFormat"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Java docs for \f(CW\*(C`java.util.Properties\*(C'\fR at
<http://java.sun.com/j2se/1.3/docs/api/index.html>.
.PP
Config::Properties::Simple for a simpler alternative interface to
Config::Properties.
.SH "TODO"
.IX Header "TODO"
Add support for derived format as supported by Java class
org.apache.commons.configuration.PropertiesConfiguration
(<http://commons.apache.org/configuration/apidocs/org/apache/commons/configuration/PropertiesConfiguration.html>)
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\f(CW\*(C`Config::Properties\*(C'\fR was originally developed by Randy Jay Yarger. It
was maintained for some time by Craig Manley and finally it passed
hands to Salvador Fandiño <sfandino@yahoo.com>, the current
maintainer.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2001, 2002 by Randy Jay Yarger
Copyright 2002, 2003 by Craig Manley.
Copyright 2003\-2009, 2011\-2012, 2014\-2015 by Salvador Fandiño.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
