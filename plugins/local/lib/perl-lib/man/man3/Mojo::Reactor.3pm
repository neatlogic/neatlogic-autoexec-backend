.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::Reactor 3"
.TH Mojo::Reactor 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Reactor \- Low\-level event reactor base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Mojo::Reactor::MyEventLoop;
\&  use Mojo::Base \*(AqMojo::Reactor\*(Aq;
\&
\&  sub again      {...}
\&  sub io         {...}
\&  sub is_running {...}
\&  sub next_tick  {...}
\&  sub one_tick   {...}
\&  sub recurring  {...}
\&  sub remove     {...}
\&  sub reset      {...}
\&  sub start      {...}
\&  sub stop       {...}
\&  sub timer      {...}
\&  sub watch      {...}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Reactor is an abstract base class for low-level event reactors, like
Mojo::Reactor::EV and Mojo::Reactor::Poll.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Reactor inherits all events from Mojo::EventEmitter and can emit
the following new ones.
.SS "error"
.IX Subsection "error"
.Vb 4
\&  $reactor\->on(error => sub {
\&    my ($reactor, $err) = @_;
\&    ...
\&  });
.Ve
.PP
Emitted for exceptions caught in callbacks, fatal if unhandled. Note that if
this event is unhandled or fails it might kill your program, so you need to be
careful.
.PP
.Vb 4
\&  $reactor\->on(error => sub {
\&    my ($reactor, $err) = @_;
\&    say "Something very bad happened: $err";
\&  });
.Ve
.SH "METHODS"
.IX Header "METHODS"
Mojo::Reactor inherits all methods from Mojo::EventEmitter and implements
the following new ones.
.SS "again"
.IX Subsection "again"
.Vb 1
\&  $reactor\->again($id);
.Ve
.PP
Restart timer. Meant to be overloaded in a subclass. Note that this method
requires an active timer.
.SS "detect"
.IX Subsection "detect"
.Vb 1
\&  my $class = Mojo::Reactor\->detect;
.Ve
.PP
Detect and load the best reactor implementation available, will try the value
of the \f(CW\*(C`MOJO_REACTOR\*(C'\fR environment variable, Mojo::Reactor::EV or
Mojo::Reactor::Poll.
.PP
.Vb 2
\&  # Instantiate best reactor implementation available
\&  my $reactor = Mojo::Reactor\->detect\->new;
.Ve
.SS "io"
.IX Subsection "io"
.Vb 1
\&  $reactor = $reactor\->io($handle => sub {...});
.Ve
.PP
Watch handle for I/O events, invoking the callback whenever handle becomes
readable or writable. Meant to be overloaded in a subclass.
.PP
.Vb 5
\&  # Callback will be executed twice if handle becomes readable and writable
\&  $reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
.Ve
.SS "is_running"
.IX Subsection "is_running"
.Vb 1
\&  my $bool = $reactor\->is_running;
.Ve
.PP
Check if reactor is running. Meant to be overloaded in a subclass.
.SS "next_tick"
.IX Subsection "next_tick"
.Vb 1
\&  my $undef = $reactor\->next_tick(sub {...});
.Ve
.PP
Execute callback as soon as possible, but not before returning or other
callbacks that have been registered with this method, always returns \f(CW\*(C`undef\*(C'\fR.
Meant to be overloaded in a subclass.
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 1
\&  $reactor\->one_tick;
.Ve
.PP
Run reactor until an event occurs. Note that this method can recurse back into
the reactor, so you need to be careful. Meant to be overloaded in a subclass.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = $reactor\->timer(0.5 => sub {});
\&  $reactor\->one_tick;
\&  $reactor\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 1
\&  my $id = $reactor\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds. Meant to be overloaded in a subclass.
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  my $bool = $reactor\->remove($handle);
\&  my $bool = $reactor\->remove($id);
.Ve
.PP
Remove handle or timer. Meant to be overloaded in a subclass.
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&  $reactor\->reset;
.Ve
.PP
Remove all handles and timers. Meant to be overloaded in a subclass.
.SS "start"
.IX Subsection "start"
.Vb 1
\&  $reactor\->start;
.Ve
.PP
Start watching for I/O and timer events, this will block until \*(L"stop\*(R" is
called. Note that some reactors stop automatically if there are no events being
watched anymore. Meant to be overloaded in a subclass.
.PP
.Vb 2
\&  # Start reactor only if it is not running already
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 1
\&  $reactor\->stop;
.Ve
.PP
Stop watching for I/O and timer events. Meant to be overloaded in a subclass.
.SS "timer"
.IX Subsection "timer"
.Vb 1
\&  my $id = $reactor\->timer(0.5 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds. Meant to be overloaded in a subclass.
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $reactor = $reactor\->watch($handle, $readable, $writable);
.Ve
.PP
Change I/O events to watch handle for with true and false values. Meant to be
overloaded in a subclass. Note that this method requires an active I/O watcher.
.PP
.Vb 2
\&  # Watch only for readable events
\&  $reactor\->watch($handle, 1, 0);
\&
\&  # Watch only for writable events
\&  $reactor\->watch($handle, 0, 1);
\&
\&  # Watch for readable and writable events
\&  $reactor\->watch($handle, 1, 1);
\&
\&  # Pause watching for events
\&  $reactor\->watch($handle, 0, 0);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
