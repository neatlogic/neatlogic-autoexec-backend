.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SOAP::SOM 3"
.TH SOAP::SOM 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SOAP::SOM \- provides access to the values contained in SOAP Response
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects from the \s-1SOAP::SOM\s0 class aren't generally instantiated directly by an application. Rather, they are handed back by the deserialization of a message. In other words, developers will almost never do this:
.PP
.Vb 1
\&    $som = SOAP::SOM\->new;
.Ve
.PP
\&\s-1SOAP::SOM\s0 objects are returned by a SOAP::Lite call in a client context. For example:
.PP
.Vb 5
\&    my $client = SOAP::Lite
\&        \->readable(1)
\&        \->uri($NS)
\&        \->proxy($HOST)
\&    $som = $client\->someMethod();
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "new(message)" 4
.IX Item "new(message)"
.Vb 1
\&    $som = SOAP::SOM\->new($message_as_xml);
.Ve
.Sp
As said, the need to actually create an object of this class should be very rare. However, if the need arises, the syntax must be followed. The single argument to new must be a valid \s-1XML\s0 document the parser will understand as a \s-1SOAP\s0 response.
.PP
The following group of methods provide general data retrieval from the \s-1SOAP::SOM\s0 object. The model for this is an abbreviated form of XPath. Following this group are methods that are geared towards specific retrieval of commonly requested elements.
.IP "match(path)" 4
.IX Item "match(path)"
.Vb 1
\&    $som\->match(\*(Aq/Envelope/Body/[1]\*(Aq);
.Ve
.Sp
This method sets the internal pointers within the data structure so that the retrieval methods that follow will have access to the desired data. In the example path, the match is being made against the method entity, which is the first child tag of the body in a \s-1SOAP\s0 response. The enumeration of container children starts at 1 in this syntax, not 0. The returned value is dependent on the context of the call. If the call is made in a boolean context (such as \f(CW\*(C`if ($som\->match($path))\*(C'\fR), the return value is a boolean indicating whether the requested path matched at all. Otherwise, an object reference is returned. The returned object is also a \s-1SOAP::SOM\s0 instance but is smaller, containing the subset of the document tree matched by the expression.
.IP "valueof(node)" 4
.IX Item "valueof(node)"
.Vb 1
\&    $res = $som\->valueof(\*(Aq[1]\*(Aq);
.Ve
.Sp
When the \s-1SOAP::SOM\s0 object has matched a path internally with the match method, this method allows retrieval of the data within any of the matched nodes. The data comes back as native Perl data, not a class instance (see dataof). In a scalar context, this method returns just the first element from a matched node set. In an array context, all elements are returned. Assuming that the earlier call happens after the earlier call to match, it retrieves the result entity from the method response that is contained in \f(CW$som\fR, as this is the first child element in a method-response tag.
.IP "dataof(node)" 4
.IX Item "dataof(node)"
.Vb 1
\&    $resobj = $som\->dataof(\*(Aq[1]\*(Aq);
.Ve
.Sp
Performs the same operation as the earlier valueof method, except that the data is left in its SOAP::Data form, rather than being deserialized. This allows full access to all the attributes that were serialized along with the data, such as namespace and encoding.
.IP "headerof(node)" 4
.IX Item "headerof(node)"
.Vb 1
\&    $resobj = $som\->headerof(\*(Aq[1]\*(Aq);
.Ve
.Sp
Acts much like dataof, except that it returns an object of the SOAP::Header class (covered later in this chapter), rather than SOAP::Data. This is the preferred interface for manipulating the header entities in a message.
.IP "namespaceuriof(node)" 4
.IX Item "namespaceuriof(node)"
.Vb 1
\&    $ns = $som\->namespaceof(\*(Aq[1]\*(Aq);
.Ve
.Sp
Retrieves the namespace \s-1URI\s0 that governs the requested node. Note that namespaces are inherited, so this method will return the relevant value, even if it derives from a parent or other ancestor node.
.PP
The following methods provide more direct access to the message envelope. All these methods return some form of a Perl value, most often a hash reference, when called. Context is also relevant: in a scalar context only the first matching node is returned, while in an array context, all matching nodes are. When called as a static method or as a regular function (such as \f(CW\*(C`SOAP::SOM::envelope\*(C'\fR), any of the following methods returns the XPath string that is used with the match method to retrieve the data.
.IP "root" 4
.IX Item "root"
.Vb 1
\&    $root = $som\->root;
.Ve
.Sp
Returns the value of the root element as a hash reference. It behaves exactly as \f(CW\*(C`$som\-\*(C'\fRvalueof('/')> does.
.IP "envelope" 4
.IX Item "envelope"
.Vb 1
\&    $envelope = $som\->envelope;
.Ve
.Sp
Retrieves the \*(L"Envelope\*(R" element of the message, returning it and its data as a hash reference. Keys in the hash will be Header and Body (plus any optional elements that may be present in a \s-1SOAP 1.1\s0 envelope), whose values will be the serialized header and body, respectively.
.IP "header" 4
.IX Item "header"
.Vb 1
\&    $header = $som\->header;
.Ve
.Sp
Retrieves the header portion of the envelope as a hash reference. All data within it will have been deserialized. If the attributes of the header are desired, the static form of the method can be combined with match to fetch the header as a SOAP::Data object:
.Sp
.Vb 1
\&    $header = $som\->match(SOAP::SOM::header)\->dataof;
.Ve
.IP "headers" 4
.IX Item "headers"
.Vb 1
\&    @hdrs = $som\->headers;
.Ve
.Sp
Retrieves the node set of values with deserialized headers from within the Header container. This is different from the earlier header method in that it returns the whole header as a single structure, and this returns the child elements as an array. In other words, the following expressions yield the same data structure:
.Sp
.Vb 2
\&    $header = ($som\->headers)[0];
\&    $header = $som\->valueof(SOAP::SOM::header.\*(Aq/[1]\*(Aq);
.Ve
.IP "body" 4
.IX Item "body"
.Vb 1
\&    $body = $som\->body;
.Ve
.Sp
Retrieves the message body as a hash reference. The entity tags act as keys, with their deserialized content providing the values.
.IP "fault" 4
.IX Item "fault"
.Vb 1
\&    if ($som\->fault) { die $som\->fault\->faultstring }
.Ve
.Sp
Acts both as a boolean test whether a fault occurred, and as a way to retrieve the Fault entity itself from the message body as a hash reference. If the message contains a fault, the next four methods (faultcode, faultstring, faultactor, and faultdetail) may be used to retrieve the respective parts of the fault (which are also available on the hash reference as keys). If fault in a boolean context is true, the \f(CW\*(C`result\*(C'\fR, \f(CW\*(C`paramsin\*(C'\fR, \f(CW\*(C`paramsout\*(C'\fR, and \f(CW\*(C`method\*(C'\fR methods all return \f(CW\*(C`undef\*(C'\fR.
.IP "faultcode" 4
.IX Item "faultcode"
.Vb 1
\&    $code = $som\->faultcode;
.Ve
.Sp
Returns the faultcode element of the fault if there is a fault; undef otherwise.
.IP "faultstring" 4
.IX Item "faultstring"
.Vb 1
\&    $string = $som\->faultstring;
.Ve
.Sp
Returns the faultstring element of the fault if there is a fault; undef otherwise.
.IP "faultactor" 4
.IX Item "faultactor"
.Vb 1
\&    $actor = $som\->faultactor;
.Ve
.Sp
Returns the faultactor element of the fault, if there is a fault and if the actor was specified within it. The faultactor element is optional in the serialization of a fault, so it may not always be present. This element is usually a string.
.IP "faultdetail" 4
.IX Item "faultdetail"
.Vb 1
\&    $detail = $som\->faultdetail;
.Ve
.Sp
Returns the content of the detail element of the fault, if there is a fault and if the detail element was provided. Note that the name of the element isn't the same as the method, due to the possibility for confusion had the method been called simply, detail. As with the faultactor element, this isn't always a required component of a fault, so it isn't guaranteed to be present. The specification for the detail portion of a fault calls for it to contain a series of element tags, so the application may expect a hash reference as a return value when detail information is available (and undef otherwise).
.IP "method" 4
.IX Item "method"
.Vb 1
\&    $method = $som\->method
.Ve
.Sp
Retrieves the \*(L"method\*(R" element of the message, as a hash reference. This includes all input parameters when called on a request message or all result/output parameters when called on a response message. If there is a fault present in the message, it returns undef.
.IP "result" 4
.IX Item "result"
.Vb 1
\&    $value = $som\->result;
.Ve
.Sp
Returns the value that is the result of a \s-1SOAP\s0 response. The value will be already deserialized into a native Perl datatype.
.IP "paramsin" 4
.IX Item "paramsin"
.Vb 1
\&    @list = $som\->paramsin;
.Ve
.Sp
Retrieves the parameters being passed in on a \s-1SOAP\s0 request. If called in a scalar context, the first parameter is returned. When called in a list context, the full list of all parameters is returned. Each parameter is a hash reference, following the established structure for such return values.
.IP "paramsout" 4
.IX Item "paramsout"
.Vb 1
\&    @list = $som\->paramsout;
.Ve
.Sp
Returns the output parameters from a \s-1SOAP\s0 response. These are the named parameters that are returned in addition to the explicit response entity itself. It shares the same scalar/list context behavior as the paramsin method.
.IP "paramsall" 4
.IX Item "paramsall"
.Vb 1
\&    @list = $som\->paramsall;
.Ve
.Sp
Returns all parameters from a \s-1SOAP\s0 response, including the result entity itself, as one array.
.IP "\fIparts()\fR" 4
.IX Item "parts()"
Return an array of \f(CW\*(C`MIME::Entity\*(C'\fR's if the current payload contains attachments, or returns undefined if payload is not \s-1MIME\s0 multipart.
.IP "\fIis_multipart()\fR" 4
.IX Item "is_multipart()"
Returns true if payload is \s-1MIME\s0 multipart, false otherwise.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "\s-1ACCESSING ELEMENT VALUES\s0"
.IX Subsection "ACCESSING ELEMENT VALUES"
Suppose for the following \s-1SOAP\s0 Envelope:
.PP
.Vb 7
\&    <Envelope>
\&      <Body>
\&        <fooResponse>
\&          <bar>abcd</bar>
\&        </fooResponse>
\&      </Body>
\&    </Envelope>
.Ve
.PP
And suppose you wanted to access the value of the bar element, then use the following code:
.PP
.Vb 5
\&    my $soap = SOAP::Lite
\&        \->uri($SOME_NS)
\&        \->proxy($SOME_HOST);
\&    my $som = $soap\->foo();
\&    print $som\->valueof(\*(Aq//fooResponse/bar\*(Aq);
.Ve
.SS "\s-1ACCESSING ATTRIBUTE VALUES\s0"
.IX Subsection "ACCESSING ATTRIBUTE VALUES"
Suppose the following \s-1SOAP\s0 Envelope:
.PP
.Vb 7
\&    <Envelope>
\&      <Body>
\&        <c2fResponse>
\&          <convertedTemp test="foo">98.6</convertedTemp>
\&        </c2fResponse>
\&      </Body>
\&    </Envelope>
.Ve
.PP
Then to print the attribute 'test' use the following code:
.PP
.Vb 2
\&    print "The attribute is: " .
\&      $som\->dataof(\*(Aq//c2fResponse/convertedTemp\*(Aq)\->attr\->{\*(Aqtest\*(Aq};
.Ve
.SS "\s-1ITERATING OVER AN ARRAY\s0"
.IX Subsection "ITERATING OVER AN ARRAY"
Suppose for the following \s-1SOAP\s0 Envelope:
.PP
.Vb 10
\&    <Envelope>
\&      <Body>
\&        <catalog>
\&          <product>
\&            <title>Programming Web Service with Perl</title>
\&            <price>$29.95</price>
\&          </product>
\&          <product>
\&            <title>Perl Cookbook</title>
\&            <price>$49.95</price>
\&          </product>
\&        </catalog>
\&      </Body>
\&    </Envelope>
.Ve
.PP
If the \s-1SOAP\s0 Envelope returned contained an array, use the following code to iterate over the array:
.PP
.Vb 3
\&    for my $t ($som\->valueof(\*(Aq//catalog/product\*(Aq)) {
\&      print $t\->{title} . " \- " . $t\->{price} . "\en";
\&    }
.Ve
.SS "\s-1DETECTING A SOAP FAULT\s0"
.IX Subsection "DETECTING A SOAP FAULT"
A \s-1SOAP::SOM\s0 object is returned by a SOAP::Lite client regardless of whether the call succeeded or not. Therefore, a \s-1SOAP\s0 Client is responsible for determining if the returned value is a fault or not. To do so, use the \fIfault()\fR method which returns 1 if the \s-1SOAP::SOM\s0 object is a fault and 0 otherwise.
.PP
.Vb 1
\&    my $som = $client\->someMethod(@parameters);
\&
\&    if ($som\->fault) {
\&      print $som\->faultdetail;
\&    } else {
\&      # do something
\&    }
.Ve
.SS "\s-1PARSING ARRAYS OF ARRAYS\s0"
.IX Subsection "PARSING ARRAYS OF ARRAYS"
The most efficient way To parse and to extract data out of an array containing another array encoded in a \s-1SOAP::SOM\s0 object is the following:
.PP
.Vb 12
\&    $xml = <<END_XML;
\&    <foo>
\&      <person>
\&        <foo>123</foo>
\&        <foo>456</foo>
\&      </person>
\&      <person>
\&        <foo>789</foo>
\&        <foo>012</foo>
\&      </person>
\&    </foo>
\&    END_XML
\&
\&    my $som = SOAP::Deserializer\->deserialize($xml);
\&    my $i = 0;
\&    foreach my $a ($som\->dataof("//person/*")) {
\&        $i++;
\&        my $j = 0;
\&        foreach my $b ($som\->dataof("//person/[$i]/*")) {
\&            $j++;
\&            # do something
\&        }
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SOAP::Data, SOAP::Serializer
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Special thanks to O'Reilly publishing which has graciously allowed SOAP::Lite to republish and redistribute large excerpts from \fIProgramming Web Services with Perl\fR, mainly the SOAP::Lite reference found in Appendix B.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2004 Paul Kulchenko. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Kulchenko (paulclinger@yahoo.com)
.PP
Randy J. Ray (rjray@blackperl.com)
.PP
Byrne Reese (byrne@majordojo.com)
