.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::RandPasswd 3"
.TH Crypt::RandPasswd 3 "2021-05-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::RandPasswd \- random password generator based on FIPS\-181
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Crypt::RandPasswd;
\&  ( $word, $hyphenated ) = Crypt::RandPasswd\->word( $minlen, $maxlen );
\&  $word = Crypt::RandPasswd\->word( $minlen, $maxlen );
\&  $word = Crypt::RandPasswd\->letters( $minlen, $maxlen );
\&  $word = Crypt::RandPasswd\->chars( $minlen, $maxlen );
\&
\&  # override the defaults for these functions:
\&  *Crypt::RandPasswd::rng = \e&my_random_number_generator;
\&  *Crypt::RandPasswd::restrict = \e&my_restriction_filter;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Crypt::RandPasswd provides three functions that can be used
to generate random passwords, constructed from words,
letters, or characters.
.PP
This code is a Perl implementation of the Automated
Password Generator standard, like the program described in
\&\*(L"A Random Word Generator For Pronounceable Passwords\*(R" (not available on-line). 
This code is a re-engineering of the program contained in Appendix A
of \s-1FIPS\s0 Publication 181, \*(L"Standard for Automated Password Generator\*(R".
In accordance with the standard, the results obtained from this
program are logically equivalent to those produced by the standard.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Bugs"
.IX Subsection "Bugs"
The function to generate a password can sometimes take an extremely long time.
.SS "Deviations From Standard"
.IX Subsection "Deviations From Standard"
This implementation deviates in one critical way from the standard
upon which it is based: the random number generator in this 
implementation does not use \s-1DES.\s0  Instead, it uses perl's built-in
\&\f(CW\*(C`rand()\*(C'\fR function, which in turn is (usually) built on the
pseudo-random number generator functions of the underlying C library.
.PP
However, the random function can be replaced by the user if desired.
(See \*(L"rng\*(R".)
.SH "Functions"
.IX Header "Functions"
.SS "word"
.IX Subsection "word"
.Vb 2
\&  word = word( minlen, maxlen );
\&  ( word, hyphenated_form ) = word( minlen, maxlen );
.Ve
.PP
Generates a random word, as well as its hyphenated form.
The length of the returned word will be between minlen and maxlen.
.SS "letters"
.IX Subsection "letters"
.Vb 1
\&  word = letters( minlen, maxlen );
.Ve
.PP
Generates a string of random letters.
The length of the returned word is between minlen and maxlen.  
Calls \f(CW\*(C`random_chars_in_range( \*(Aqa\*(Aq => \*(Aqz\*(Aq )\*(C'\fR.
.SS "chars"
.IX Subsection "chars"
.Vb 1
\&  word = chars( minlen, maxlen );
.Ve
.PP
Generates a string of random printable characters.
The length of the returned word is between minlen and maxlen.  
Calls \f(CW\*(C`random_chars_in_range( \*(Aq!\*(Aq => \*(Aq~\*(Aq )\*(C'\fR.
.SS "random_chars_in_range"
.IX Subsection "random_chars_in_range"
.Vb 1
\&  word = random_chars_in_range( minlen, maxlen, lo_char => hi_char );
.Ve
.PP
Generates a string of printable characters.
The length of the returned string is between minlen and maxlen.  
Each character is selected from the range of \s-1ASCII\s0 characters
delimited by (lo_char,hi_char).
.SS "rand_int_in_range"
.IX Subsection "rand_int_in_range"
.Vb 1
\&  n = rand_int_in_range( min, max );
.Ve
.PP
Returns an integer between min and max, inclusive.
Calls \f(CW\*(C`rng\*(C'\fR like so:
.PP
.Vb 1
\&  n = min + int( rng( max \- min + 1 ) )
.Ve
.SS "random_element"
.IX Subsection "random_element"
.Vb 1
\&  e = random_element( \e@elts )
.Ve
.PP
Selects a random element from an array, which is passed by ref.
.SS "rng"
.IX Subsection "rng"
.Vb 1
\&  r = rng( n );
.Ve
.PP
\&\f(CW\*(C`rng\*(C'\fR is designed to have the same interface as the built-in \f(CW\*(C`rand\*(C'\fR function.
The default implementation here is a simple wrapper around \f(CW\*(C`rand\*(C'\fR,
which is typically a wrapper for some pseudo-random number function in the
underlying C library.
.PP
The reason for having this simple wrapper is so the user can
easily substitute a different random number generator if desired.
Since many rng's have the same interface as \f(CW\*(C`rand\*(C'\fR, replacing \f(CW\*(C`rng()\*(C'\fR
is as simple as
.PP
.Vb 4
\&    {
\&        local $^W; # squelch sub redef warning.
\&        *Crypt::RandPasswd::rng = \e&my_rng;
\&    }
.Ve
.PP
See rand.
.SS "restrict"
.IX Subsection "restrict"
.Vb 1
\&  word = restrict( word );
.Ve
.PP
A filter.  Returns the arg unchanged if it is allowable; returns undef if not.
.PP
The default version of \f(CW\*(C`restrict()\*(C'\fR allows everything.
You may install a different form to implement other restrictions,
by doing something like this:
.PP
.Vb 4
\&    {
\&      local $^W; # squelch sub redef warning.
\&      *Crypt::RandPasswd::restrict = \e&my_filter;
\&    }
.Ve
.SS "init"
.IX Subsection "init"
This initializes the environment, which by default simply seeds the random number generator.
.SS "get_syllable"
.IX Subsection "get_syllable"
Generate next unit to password, making sure that it follows these rules:
.PP
1. Each syllable must contain exactly 1 or 2 consecutive vowels, where y is considered a vowel.
.PP
2. Syllable end is determined as follows:
.PP
.Vb 7
\&   a. Vowel is generated and previous unit is a consonant and syllable already has a vowel. 
\&      In this case, new syllable is started and already contains a vowel.
\&   b. A pair determined to be a "break" pair is encountered. 
\&      In this case new syllable is started with second unit of this pair.
\&   c. End of password is encountered.
\&   d. "begin" pair is encountered legally.  New syllable is started with this pair.
\&   e. "end" pair is legally encountered.  New syllable has nothing yet.
.Ve
.PP
3. Try generating another unit if:
.PP
.Vb 8
\&   a. third consecutive vowel and not y.
\&   b. "break" pair generated but no vowel yet in current or previous 2 units are "not_end".
\&   c. "begin" pair generated but no vowel in syllable preceding begin pair,
\&      or both previous 2 pairs are designated "not_end".
\&   d. "end" pair generated but no vowel in current syllable or in "end" pair.
\&   e. "not_begin" pair generated but new syllable must begin (because previous syllable ended as defined in 2 above).
\&   f. vowel is generated and 2a is satisfied, but no syllable break is possible in previous 3 pairs.
\&   g. Second and third units of syllable must begin, and first unit is "alternate_vowel".
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1CPAN\s0 modules for generating passwords <http://neilb.org/reviews/passwords.html> \- a review of modules of \s-1CPAN\s0 for random password generation.
.PP
Some of the better modules:
App::Genpass, Crypt::XkcdPassword,
Crypt::YAPassGen, Data::Random,
String::Random.
.PP
\&\s-1FIPS 181\s0 \- (\s-1APG\s0), Automated Password Generator:
http://www.itl.nist.gov/fipspubs/fip181.htm
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/neilbowers/Crypt\-RandPasswd>
.SH "AUTHOR"
.IX Header "AUTHOR"
JDPORTER@cpan.org (John Porter)
.PP
Now maintained by Neil Bowers <neilb@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This perl module is free software; it may be redistributed and/or modified 
under the same terms as Perl itself.
