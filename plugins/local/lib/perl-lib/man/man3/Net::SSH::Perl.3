.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl 3"
.TH Net::SSH::Perl 3 "2021-02-09" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Perl \- Perl client Interface to SSH
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Net::SSH::Perl;
\&    my $ssh = Net::SSH::Perl\->new($host);
\&    $ssh\->login($user, $pass);
\&    my($stdout, $stderr, $exit) = $ssh\->cmd($cmd);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl\fR is an all-Perl module implementing an \s-1SSH\s0
(Secure Shell) client. It is compatible with both the \s-1SSH\-1\s0 and
\&\s-1SSH\-2\s0 protocols.
.PP
\&\fINet::SSH::Perl\fR enables you to simply and securely execute commands
on remote machines, and receive the \s-1STDOUT, STDERR,\s0 and exit status
of that remote command. It contains built-in support for various
methods of authenticating with the server (password authentication,
\&\s-1RSA\s0 challenge-response authentication, etc.). It completely implements
the I/O buffering, packet transport, and user authentication layers
of the \s-1SSH\s0 protocol, and makes use of external Perl libraries (in
the Crypt:: family of modules) to handle encryption of all data sent
across the insecure network. It can also read your existing \s-1SSH\s0
configuration files (\fI/etc/ssh_config\fR, etc.), \s-1RSA\s0 identity files,
\&\s-1DSA\s0 identity files, known hosts files, etc.
.PP
One advantage to using \fINet::SSH::Perl\fR over wrapper-style
implementations of ssh clients is that it saves on process
overhead: you no longer need to fork and execute a separate process
in order to connect to an sshd. Depending on the amount of time
and memory needed to fork a process, this win can be quite
substantial; particularly if you're running in a persistent
Perl environment (\fImod_perl\fR, for example), where forking a new
process is a drain on process and memory resources.
.PP
It also simplifies the process of using password-based authentications;
when writing a wrapper around \fIssh\fR you probably need to use
\&\fIExpect\fR to control the ssh client and give it your password.
\&\fINet::SSH::Perl\fR has built-in support for the authentication
protocols, so there's no longer any hassle of communicating with
any external processes.
.PP
The \s-1SSH2\s0 protocol support (present in \fINet::SSH::Perl\fR as of version
1.00) is compatible with the \s-1SSH2\s0 implementation in OpenSSH, and should
also be fully compatible with the \*(L"official\*(R" \s-1SSH\s0 implementation. If
you find an \s-1SSH2\s0 implementation that is not compatible with
\&\fINet::SSH::Perl\fR, please let me know (email address down in
\&\fI\s-1AUTHOR & COPYRIGHTS\s0\fR); it turns out that some \s-1SSH2\s0 implementations
have subtle differences from others. 3DES (\f(CW\*(C`3des\-cbc\*(C'\fR), Blowfish
(\f(CW\*(C`blowfish\-cbc\*(C'\fR), and \s-1RC4\s0 (\f(CW\*(C`arcfour\*(C'\fR) ciphers are currently
supported for \s-1SSH2\s0 encryption, and integrity checking is performed
by either the \f(CW\*(C`hmac\-sha1\*(C'\fR or \f(CW\*(C`hmac\-md5\*(C'\fR algorithms. Compression, if
requested, is limited to Zlib. Supported server host key algorithms
are \f(CW\*(C`ssh\-dss\*(C'\fR (the default) and \f(CW\*(C`ssh\-rsa\*(C'\fR (requires \fICrypt::RSA\fR);
supported \s-1SSH2\s0 public key authentication algorithms are the same.
.PP
If you're looking for \s-1SFTP\s0 support, take a look at \fINet::SFTP\fR,
which provides a full-featured Perl implementation of \s-1SFTP,\s0 and
sits on top of \fINet::SSH::Perl\fR. \s-1SFTP\s0 requires the usage of the
\&\s-1SSH2\s0 protocol.
.SH "BASIC USAGE"
.IX Header "BASIC USAGE"
Usage of \fINet::SSH::Perl\fR is very simple.
.ie n .SS "Net::SSH::Perl\->new($host, %params)"
.el .SS "Net::SSH::Perl\->new($host, \f(CW%params\fP)"
.IX Subsection "Net::SSH::Perl->new($host, %params)"
To set up a new connection, call the \fInew\fR method, which
connects to \fI\f(CI$host\fI\fR and returns a \fINet::SSH::Perl\fR object.
.PP
\&\fInew\fR accepts the following named parameters in \fI\f(CI%params\fI\fR:
.IP "\(bu" 4
protocol
.Sp
The protocol you wish to use for the connection: should be either
\&\f(CW2\fR, \f(CW1\fR, \f(CW\*(Aq1,2\*(Aq\fR or \f(CW\*(Aq2,1\*(Aq\fR. The first two say, quite simply,
\&\*(L"only use this version of the protocol\*(R" (\s-1SSH\-2\s0 or \s-1SSH\-1,\s0 respectively).
The latter two specify that either protocol can be used, but that
one protocol (the first in the comma-separated list) is preferred
over the other.
.Sp
For this reason, it's \*(L"safer\*(R" to use the latter two protocol
specifications, because they ensure that either way, you'll be able
to connect; if your server doesn't support the first protocol listed,
the second will be used. (Presumably your server will support at
least one of the two protocols. :)
.Sp
The default value is \f(CW\*(Aq1,2\*(Aq\fR, for compatibility with OpenSSH; this
means that the client will use \s-1SSH\-1\s0 if the server supports \s-1SSH\-1.\s0
Of course, you can always override this using a user/global
configuration file, or through using this constructor argument.
.IP "\(bu" 4
cipher
.Sp
Specifies the name of the encryption cipher that you wish to
use for this connection. This must be one of the supported
ciphers; specifying an unsupported cipher will give you an error
when you enter algorithm negotiation (in either \s-1SSH\-1\s0 or \s-1SSH\-2\s0).
.Sp
In \s-1SSH\-1,\s0 the supported cipher names are \fI\s-1IDEA\s0\fR, \fI\s-1DES\s0\fR, \fI\s-1DES3\s0\fR,
and \fIBlowfish\fR; in \s-1SSH\-2,\s0 the supported ciphers are \fIarcfour\fR,
\&\fIblowfish-cbc\fR, and \fI3des\-cbc\fR.
.Sp
The default \s-1SSH\-1\s0 cipher is \fI\s-1IDEA\s0\fR; the default \s-1SSH\-2\s0 cipher is
\&\fI3des\-cbc\fR.
.IP "\(bu" 4
ciphers
.Sp
Like \fIcipher\fR, this is a method of setting the cipher you wish to
use for a particular \s-1SSH\s0 connection; but this corresponds to the
\&\fICiphers\fR configuration option, where \fIcipher\fR corresponds to
\&\fICipher\fR. This also applies only in \s-1SSH\-2.\s0
.Sp
This should be a comma-separated list of \s-1SSH\-2\s0 cipher names; the list
of cipher names is listed above in \fIcipher\fR.
.Sp
This defaults to \fI3des\-cbc,blowfish\-cbc,arcfour\fR.
.IP "\(bu" 4
port
.Sp
The port of the \fIsshd\fR daemon to which you wish to connect;
if not specified, this is assumed to be the default \fIssh\fR
port.
.IP "\(bu" 4
debug
.Sp
Set to a true value if you want debugging messages printed
out while the connection is being opened. These can be helpful
in trying to determine connection problems, etc. The messages
are similar (and in some cases exact) to those written out by
the \fIssh\fR client when you use the \fI\-v\fR option.
.Sp
Defaults to false.
.IP "\(bu" 4
interactive
.Sp
Set to a true value if you're using \fINet::SSH::Perl\fR interactively.
This is used in determining whether or not to display password
prompts, for example. It's basically the inverse of the
\&\fIBatchMode\fR parameter in ssh configuration.
.Sp
Defaults to false.
.IP "\(bu" 4
privileged
.Sp
Set to a true value if you want to bind to a privileged port
locally. You'll need this if you plan to use Rhosts or
Rhosts-RSA authentication, because the remote server
requires the client to connect on a privileged port. Of course,
to bind to a privileged port you'll need to be root.
.Sp
If you don't provide this parameter, and \fINet::SSH::Perl\fR
detects that you're running as root, this will automatically
be set to true. Otherwise it defaults to false.
.IP "\(bu" 4
identity_files
.Sp
A list of \s-1RSA/DSA\s0 identity files to be used in \s-1RSA/DSA\s0 authentication.
The value of this argument should be a reference to an array of
strings, each string identifying the location of an identity
file. Each identity file will be tested against the server until
the client finds one that authenticates successfully.
.Sp
If you don't provide this, \s-1RSA\s0 authentication defaults to using
\&\fI\f(CI$ENV\fI{\s-1HOME\s0}/.ssh/identity\fR, and \s-1DSA\s0 authentication defaults to
\&\fI\f(CI$ENV\fI{\s-1HOME\s0}/.ssh/id_dsa\fR.
.IP "\(bu" 4
strict_host_key_checking
.Sp
This corresponds to the \fIStrictHostKeyChecking\fR ssh configuration
option. Allowed values are \fIno\fR, \fIyes\fR, or \fIask\fR. \fIno\fR disables
host key checking, e.g., if you connect to a virtual host that answers
to multiple \s-1IP\s0 addresses. \fIyes\fR or \fIask\fR enable it, and when it
fails in \fIinteractive\fR mode, you are asked whether to continue. The
host is then added to the list of known hosts.
.IP "\(bu" 4
compression
.Sp
If set to a true value, compression is turned on for the session
(assuming that the server supports it).
.Sp
Compression is off by default.
.Sp
Note that compression requires that you have the \fICompress::Zlib\fR
module installed on your system. If the module can't be loaded
successfully, compression is disabled; you'll receive a warning
stating as much if you having debugging on (\fIdebug\fR set to 1),
and you try to turn on compression.
.IP "\(bu" 4
compression_level
.Sp
Specifies the compression level to use if compression is enabled
(note that you must provide both the \fIcompression\fR and
\&\fIcompression_level\fR arguments to set the level; providing only
this argument will not turn on encryption).
.Sp
This setting is only applicable to \s-1SSH\-1\s0; the compression level for
\&\s-1SSH\-2\s0 Zlib compression is always set to 6.
.Sp
The default value is 6.
.IP "\(bu" 4
use_pty
.Sp
Set this to 1 if you want to request a pseudo tty on the remote
machine. This is really only useful if you're setting up a shell
connection (see the \fIshell\fR method, below); and in that case,
unless you've explicitly declined a pty (by setting \fIuse_pty\fR
to 0), this will be set automatically to 1. In other words,
you probably won't need to use this, often.
.Sp
The default is 1 if you're starting up a shell, and 0 otherwise.
.IP "\(bu" 4
terminal_mode_string
.Sp
Specify the \s-1POSIX\s0 terminal mode string to send when use_pty is
set. By default the only mode set is the \s-1VEOF\s0 character to 0x04
(opcode 5, value 0x00000004). See \s-1RFC 4254\s0 section 8 for complete
details on this value.
.IP "\(bu" 4
no_append_veof
.Sp
(\s-1SSH\-2\s0 only) Set this to 1 if you specified use_pty and do not want
Ctrl-D (0x04) appended twice to the end of your input string. On most
systems, these bytes cause the terminal driver to return \*(L"\s-1EOF\*(R"\s0 when
standard input is read. Without them, many programs that read from
standard input will hang after consuming all the data on \s-1STDIN.\s0
.Sp
No other modifications are made to input data. If your data contains
0x04 bytes, you may need to escape them.
.Sp
Set this to 0 if you have raw terminal data to specify on standard
input, and you have terminated it correctly.
.IP "\(bu" 4
options
.Sp
Used to specify additional options to the configuration settings;
useful for specifying options for which there is no separate
constructor argument. This is analogous to the \fB\-o\fR command line
flag to the \fIssh\fR program.
.Sp
If used, the value should be a reference to a list of option
directives in the format used in the config file. For example:
.Sp
.Vb 2
\&    my $ssh = Net::SSH::Perl\->new("host", options => [
\&        "BatchMode yes", "RhostsAuthentication no" ]);
.Ve
.ie n .SS "$ssh\->login([ $user [, $password [, $suppress_shell ] ] ])"
.el .SS "\f(CW$ssh\fP\->login([ \f(CW$user\fP [, \f(CW$password\fP [, \f(CW$suppress_shell\fP ] ] ])"
.IX Subsection "$ssh->login([ $user [, $password [, $suppress_shell ] ] ])"
Sets the username and password to be used when authenticating
with the \fIsshd\fR daemon. The username \fI\f(CI$user\fI\fR is required for
all authentication protocols (to identify yourself to the
remote server), but if you don't supply it the username of the
user executing the program is used.
.PP
The password \fI\f(CI$password\fI\fR is needed only for password
authentication (it's not used for passphrases on encrypted
\&\s-1RSA/DSA\s0 identity files, though perhaps it should be). And if you're
running in an interactive session and you've not provided a
password, you'll be prompted for one.
.PP
By default, Net::SSH::Perl will open a channel with a shell
on it. This is usually what you want. If you are tunneling
another protocol over \s-1SSH,\s0 however, you may want to
prevent this behavior.  Passing a true value in \fI\f(CI$suppress_shell\fI\fR
will prevent the shell channel from being opened (\s-1SSH2\s0 only).
.ie n .SS "($out, $err, $exit) = $ssh\->cmd($cmd, [ $stdin ])"
.el .SS "($out, \f(CW$err\fP, \f(CW$exit\fP) = \f(CW$ssh\fP\->cmd($cmd, [ \f(CW$stdin\fP ])"
.IX Subsection "($out, $err, $exit) = $ssh->cmd($cmd, [ $stdin ])"
Runs the command \fI\f(CI$cmd\fI\fR on the remote server and returns
the \fIstdout\fR, \fIstderr\fR, and exit status of that
command.
.PP
If \fI\f(CI$stdin\fI\fR is provided, it's supplied to the remote command
\&\fI\f(CI$cmd\fI\fR on standard input.
.PP
\&\s-1NOTE:\s0 the \s-1SSH\-1\s0 protocol does not support running multiple commands
per connection, unless those commands are chained together so that
the remote shell can evaluate them. Because of this, a new socket
connection is created each time you call \fIcmd\fR, and disposed of
afterwards. In other words, this code:
.PP
.Vb 2
\&    my $ssh = Net::SSH::Perl\->new("host1");
\&    $ssh\->login("user1", "pass1");
\&
\&    $ssh\->cmd("foo");
\&    $ssh\->cmd("bar");
.Ve
.PP
will actually connect to the \fIsshd\fR on the first invocation of
\&\fIcmd\fR, then disconnect; then connect again on the second
invocation of \fIcmd\fR, then disconnect again.
.PP
Note that this does \fInot\fR apply to the \s-1SSH\-2\s0 protocol. \s-1SSH\-2\s0 fully
supports running more than one command over the same connection.
.ie n .SS "$ssh\->shell"
.el .SS "\f(CW$ssh\fP\->shell"
.IX Subsection "$ssh->shell"
Opens up an interactive shell on the remote machine and connects
it to your \s-1STDIN.\s0 This is most effective when used with a
pseudo tty; otherwise you won't get a command line prompt,
and it won't look much like a shell. For this reason\*(--unless
you've specifically declined one\*(--a pty will be requested
from the remote machine, even if you haven't set the \fIuse_pty\fR
argument to \fInew\fR (described above).
.PP
This is really only useful in an interactive program.
.PP
In addition, you'll probably want to set your terminal to raw
input before calling this method. This lets \fINet::SSH::Perl\fR
process each character and send it off to the remote machine,
as you type it.
.PP
To do so, use \fITerm::ReadKey\fR in your program:
.PP
.Vb 4
\&    use Term::ReadKey;
\&    ReadMode(\*(Aqraw\*(Aq);
\&    $ssh\->shell;
\&    ReadMode(\*(Aqrestore\*(Aq);
.Ve
.PP
In fact, you may want to place the \f(CW\*(C`restore\*(C'\fR line in an \fI\s-1END\s0\fR
block, in case your program exits prior to reaching that line.
.PP
If you need an example, take a look at \fIeg/pssh\fR, which
uses almost this exact code to implement an ssh shell.
.ie n .SS "$ssh\->register_handler($packet_type, $subref [, @args ])"
.el .SS "\f(CW$ssh\fP\->register_handler($packet_type, \f(CW$subref\fP [, \f(CW@args\fP ])"
.IX Subsection "$ssh->register_handler($packet_type, $subref [, @args ])"
Registers an anonymous subroutine handler \fI\f(CI$subref\fI\fR to handle
packets of type \fI\f(CI$packet_type\fI\fR during the client loop. The
subroutine will be called when packets of type \fI\f(CI$packet_type\fI\fR
are received, and in addition to the standard arguments (see
below), will receive any additional arguments in \fI\f(CI@args\fI\fR, if
specified.
.PP
The client loop is entered after the client has sent a command
to the remote server, and after any \s-1STDIN\s0 data has been sent;
it consists of reading packets from the server (\s-1STDOUT\s0
packets, \s-1STDERR\s0 packets, etc.) until the server sends the exit
status of the command executed remotely. At this point the client
exits the client loop and disconnects from the server.
.PP
When you call the \fIcmd\fR method, the client loop by default
simply sticks \s-1STDOUT\s0 packets into a scalar variable and returns
that value to the caller. It does the same for \s-1STDERR\s0 packets,
and for the process exit status. (See the docs for \fIcmd\fR).
.PP
You can, however, override that default behavior, and instead
process the data itself as it is sent to the client. You do this
by calling the \fIregister_handler\fR method and setting up handlers
to be called at specific times.
.PP
The behavior of the \fIregister_handler\fR method differs between
the \fINet::SSH::Perl\fR \s-1SSH\-1\s0 and \s-1SSH\-2\s0 implementations. This is so
because of the differences between the protocols (all 
client-server communications in \s-1SSH\-2\s0 go through the channel
mechanism, which means that input packets are processed
differently).
.IP "\(bu" 4
\&\s-1SSH\-1\s0 Protocol
.Sp
In the \s-1SSH\-1\s0 protocol, you should call \fIregister_handler\fR with two
arguments: a packet type \fI\f(CI$packet_type\fI\fR and a subroutine reference
\&\fI\f(CI$subref\fI\fR. Your subroutine will receive as arguments the
\&\fINet::SSH::Perl::SSH1\fR object (with an open connection to the
ssh3), and a \fINet::SSH::Perl::Packet\fR object, which represents the
packet read from the server. It will also receive any additional
arguments \fI\f(CI@args\fI\fR that you pass to \fIregister_handler\fR; this can
be used to give your callback functions access to some of your
otherwise private variables, if desired. \fI\f(CI$packet_type\fI\fR should be
an integer constant; you can import the list of constants into your
namespace by explicitly loading the \fINet::SSH::Perl::Constants\fR
module:
.Sp
.Vb 1
\&    use Net::SSH::Perl::Constants qw( :msg );
.Ve
.Sp
This will load all of the \fI\s-1MSG\s0\fR constants into your namespace
so that you can use them when registering the handler. To do
that, use this method. For example:
.Sp
.Vb 4
\&    $ssh\->register_handler(SSH_SMSG_STDOUT_DATA, sub {
\&        my($ssh, $packet) = @_;
\&        print "I received this: ", $packet\->get_str;
\&    });
.Ve
.Sp
To learn about the methods that you can call on the packet object,
take a look at the \fINet::SSH::Perl::Packet\fR docs, as well as the
\&\fINet::SSH::Perl::Buffer\fR docs (the \fIget_*\fR and \fIput_*\fR methods).
.Sp
Obviously, writing these handlers requires some knowledge of the
contents of each packet. For that, read through the \s-1SSH RFC,\s0 which
explains each packet type in detail. There's a \fIget_*\fR method for
each datatype that you may need to read from a packet.
.Sp
Take a look at \fIeg/remoteinteract.pl\fR for an example of interacting
with a remote command through the use of \fIregister_handler\fR.
.IP "\(bu" 4
\&\s-1SSH\-2\s0 Protocol
.Sp
In the \s-1SSH\-2\s0 protocol, you call \fIregister_handler\fR with two
arguments: a string identifying the type of handler you wish to
create, and a subroutine reference. The \*(L"string\*(R" should be, at
this point, either \f(CW\*(C`stdout\*(C'\fR or \f(CW\*(C`stderr\*(C'\fR; any other string will
be silently ignored. \f(CW\*(C`stdout\*(C'\fR denotes that you wish to handle
\&\s-1STDOUT\s0 data sent from the server, and \f(CW\*(C`stderr\*(C'\fR that you wish
to handle \s-1STDERR\s0 data.
.Sp
Your subroutine reference will be passed two arguments:
a \fINet::SSH::Perl::Channel\fR object that represents the open
channel on which the data was sent, and a \fINet::SSH::Perl::Buffer\fR
object containing data read from the server. In addition to these
two arguments, the callback will be passed any additional
arguments \fI\f(CI@args\fI\fR that you passed to \fIregister_handler\fR; this
can be used to give your callback functions to otherwise private
variables, if desired.
.Sp
This illustrates the two main differences between the \s-1SSH\-1\s0 and
\&\s-1SSH\-2\s0 implementations. The first difference is that, as mentioned
above, all communication between server and client is done through
channels, which are built on top of the main connection between
client and server. Multiple channels are multiplexed over the
same connection. The second difference is that, in \s-1SSH\-1,\s0 you are
processing the actual packets as they come in; in \s-1SSH\-2,\s0 the packets
have already been processed somewhat, and their contents stored in
buffers\*(--you are processing those buffers.
.Sp
The above example (the \fII received this\fR example) of using
\&\fIregister_handler\fR in \s-1SSH\-1\s0 would look like this in \s-1SSH\-2:\s0
.Sp
.Vb 4
\&    $ssh\->register_handler("stdout", sub {
\&        my($channel, $buffer) = @_;
\&        print "I received this: ", $buffer\->bytes;
\&    });
.Ve
.Sp
As you can see, it's quite similar to the form used in \s-1SSH\-1,\s0
but with a few important differences, due to the differences
mentioned above between \s-1SSH\-1\s0 and \s-1SSH\-2.\s0
.SH "ADVANCED METHODS"
.IX Header "ADVANCED METHODS"
Your basic \s-1SSH\s0 needs will hopefully be met by the methods listed
above. If they're not, however, you may want to use some of the
additional methods listed here. Some of these are aimed at
end-users, while others are probably more useful for actually
writing an authentication module, or a cipher, etc.
.ie n .SS "$ssh\->config"
.el .SS "\f(CW$ssh\fP\->config"
.IX Subsection "$ssh->config"
Returns the \fINet::SSH::Perl::Config\fR object managing the
configuration data for this \s-1SSH\s0 object. This is constructed
from data passed in to the constructor \fInew\fR (see above),
merged with data read from the user and system configuration
files. See the \fINet::SSH::Perl::Config\fR docs for details
on methods you can call on this object (you'll probably
be more interested in the \fIget\fR and \fIset\fR methods).
.ie n .SS "$ssh\->sock"
.el .SS "\f(CW$ssh\fP\->sock"
.IX Subsection "$ssh->sock"
Returns the socket connection to sshd. If your client is not
connected, dies.
.ie n .SS "$ssh\->debug($msg)"
.el .SS "\f(CW$ssh\fP\->debug($msg)"
.IX Subsection "$ssh->debug($msg)"
If debugging is turned on for this session (see the \fIdebug\fR
parameter to the \fInew\fR method, above), writes \fI\f(CI$msg\fI\fR to
\&\f(CW\*(C`STDERR\*(C'\fR. Otherwise nothing is done.
.ie n .SS "$ssh\->incoming_data"
.el .SS "\f(CW$ssh\fP\->incoming_data"
.IX Subsection "$ssh->incoming_data"
Incoming data buffer, an object of type \fINet::SSH::Perl::Buffer\fR.
Returns the buffer object.
.PP
The idea behind this is that we our socket is non-blocking, so we
buffer input and periodically check back to see if we've read a
full packet. If we have a full packet, we rip it out of the incoming
data buffer and process it, returning it to the caller who
presumably asked for it.
.PP
This data \*(L"belongs\*(R" to the underlying packet layer in
\&\fINet::SSH::Perl::Packet\fR. Unless you really know what you're
doing you probably don't want to disturb that data.
.ie n .SS "$ssh\->session_id"
.el .SS "\f(CW$ssh\fP\->session_id"
.IX Subsection "$ssh->session_id"
Returns the session \s-1ID,\s0 which is generated from the server's
host and server keys, and from the check bytes that it sends
along with the keys. The server may require the session \s-1ID\s0 to
be passed along in other packets, as well (for example, when
responding to \s-1RSA\s0 challenges).
.ie n .SS "$packet = $ssh\->packet_start($packet_type)"
.el .SS "\f(CW$packet\fP = \f(CW$ssh\fP\->packet_start($packet_type)"
.IX Subsection "$packet = $ssh->packet_start($packet_type)"
Starts building a new packet of type \fI\f(CI$packet_type\fI\fR. This is
just a handy method for lazy people. Internally it calls
\&\fINet::SSH::Perl::Packet::new\fR, so take a look at those docs
for more details.
.SH "SUPPORT"
.IX Header "SUPPORT"
For samples/tutorials, take a look at the scripts in \fIeg/\fR in
the distribution directory.
.PP
There is a mailing list for development discussion and usage
questions.  Posting is limited to subscribers only.  You can sign up
at http://lists.sourceforge.net/lists/listinfo/ssh\-sftp\-perl\-users
.PP
Please report all bugs via rt.cpan.org at
https://rt.cpan.org/NoAuth/ReportBug.html?Queue=net%3A%3Assh%3A%3Aperl
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainer is David Robins, dbrobins@cpan.org.
.PP
Previous maintainer was Dave Rolsky, autarch@urth.org.
.PP
Originally written by Benjamin Trott.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2003 Benjamin Trott, Copyright (c) 2003\-2008 David
Rolsky.  Copyright (c) David Robins.  All rights reserved.  This
program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file included
with this module.
