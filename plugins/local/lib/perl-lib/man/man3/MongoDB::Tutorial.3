.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MongoDB::Tutorial 3"
.TH MongoDB::Tutorial 3 "2021-05-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MongoDB::Tutorial \- Getting started with MongoDB
.SH "VERSION"
.IX Header "VERSION"
version v2.2.2
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The tutorial runs through the basic functionality of the MongoDB package.
This is a good starting point if you have never used MongoDB before.
.PP
The tutorial assumes that you are running a \fBstandalone\fR MongoDB database
server (i.e. not a replica set) locally on the default port.  You can
download MongoDB from <http://www.mongodb.org>.
.SH "TERMINOLOGY"
.IX Header "TERMINOLOGY"
Document-oriented database terms and their relational equivalents:
.IP "Database" 4
.IX Item "Database"
Database
.IP "Collection" 4
.IX Item "Collection"
Table
.IP "Document" 4
.IX Item "Document"
Record or row
.IP "\s-1BSON::OID\s0" 4
.IX Item "BSON::OID"
Autoincrementing primary key
.SH "PREAMBLE"
.IX Header "PREAMBLE"
To use MongoDB, you'll usually just start with:
.PP
.Vb 1
\&    use MongoDB;
.Ve
.PP
The MongoDB module loads most of the modules you'll need to interact
with MongoDB:
.IP "\(bu" 4
MongoDB::MongoClient
.IP "\(bu" 4
MongoDB::Database
.IP "\(bu" 4
MongoDB::Collection
.IP "\(bu" 4
Query result classes like MongoDB::Cursor and MongoDB::QueryResult
.IP "\(bu" 4
Write result classes like MongoDB::InsertOneResult and MongoDB::UpdateResult
.SH "CONNECTING"
.IX Header "CONNECTING"
To get started, we have to connect to the database server.  Because it's running
locally on the default port, we need not pass any parameters to the
connect method.
.PP
.Vb 1
\&    my $client = MongoDB\->connect();
.Ve
.PP
Now we we have a client connected to the MongoDB server.  Next we need a
database to work with, we'll call it \*(L"tutorial\*(R".  You need not do anything
special to create the database, MongoDB will create it on the fly.
.PP
.Vb 1
\&    my $db = $client\->get_database( \*(Aqtutorial\*(Aq );
.Ve
.PP
The last part of the preliminary setup is to choose a collection.  We'll be
using the \*(L"users\*(R" collection to start out.
.PP
.Vb 1
\&    my $users = $db\->get_collection( \*(Aqusers\*(Aq );
.Ve
.PP
Again, there is no need to create the collection in advance, it will be created
as needed.
.PP
The ns method is a short cut to get
a MongoDB::Collection object direct from the client.
.PP
.Vb 1
\&    my $users = $client\->ns("tutorial.users");
.Ve
.SH "CRUD"
.IX Header "CRUD"
.SS "Creating Documents"
.IX Subsection "Creating Documents"
\fIInserting\fR
.IX Subsection "Inserting"
.PP
To add a document to the collection, we use the
insert_one function.  It
takes a hash reference which is saved to the collection.
.PP
.Vb 5
\&    $users\->insert_one( {
\&        "name" => "Joe",
\&        "age" => 52,
\&        "likes" => [qw/skiing math ponies/]
\&    });
.Ve
.PP
Now there is a user in the collection.
.PP
\fI\s-1BSON::OID\s0s\fR
.IX Subsection "BSON::OIDs"
.PP
When a document is inserted, it is given a \f(CW\*(C`_id\*(C'\fR field if one does not already
exist.  By default, this field is a \s-1BSON::OID\s0, 12 bytes that are
guaranteed to be unique. The \f(CW\*(C`_id\*(C'\fR field of the inserted document is returned
in a MongoDB::InsertOneResult object by the \f(CW\*(C`insert_one\*(C'\fR method.
.PP
.Vb 2
\&    my $result = $users\->insert_one({"name" => "Bill"});
\&    my $id     = $result\->inserted_id;
.Ve
.PP
An efficient way to insert documents is to send many at a time to the
database by using insert_many, which
returns a MongoDB::InsertManyResult describing the documents inserted.
.PP
.Vb 1
\&    my $result = $users\->insert_many(\e@many_users);
.Ve
.SS "Retrieving Documents"
.IX Subsection "Retrieving Documents"
\fIQueries\fR
.IX Subsection "Queries"
.PP
To retrieve documents that were saved to a collection, we can use the
find method.
.PP
.Vb 1
\&    my $all_users = $users\->find;
.Ve
.PP
To query for certain criteria, say, all users named Joe, pass the query a hash
with the key/value pair you wish to match:
.PP
.Vb 1
\&    my $some_users = $users\->find({"name" => "Joe"});
.Ve
.PP
You can match array elements in your queries; for example, to find all users who
like math:
.PP
.Vb 1
\&    my $geeks = $users\->find({"likes" => "math"});
.Ve
.PP
This being Perl, it is important to mention that you can also use regular
expressions to search for strings.  If you wanted to find all users with the
name John and all variations of said name, you could do:
.PP
.Vb 1
\&    my $john = $users\->find({"name" => qr/joh?n/i});
.Ve
.PP
See \*(L"Regular Expressions\*(R" in MongoDB::DataTypes for more information.
.PP
\fIRanges\fR
.IX Subsection "Ranges"
.PP
As queries are hashes, they use a special syntax to express comparisons, such as
\&\*(L"x < 4\*(R".  To make the query a valid hash, MongoDB uses $\-prefixed terms.  For
example, \*(L"x < 4\*(R" could be expressed by:
.PP
.Vb 1
\&    my $doc321 = $collection\->find({\*(Aqx\*(Aq => { \*(Aq$lt\*(Aq => 4 }});
.Ve
.PP
Comparison operators can be combined to get a range:
.PP
.Vb 1
\&    my $doc32 = $collection\->find({\*(Aqx\*(Aq => { \*(Aq$gte\*(Aq => 2, \*(Aq$lt\*(Aq => 4 }});
.Ve
.PP
\fICursors\fR
.IX Subsection "Cursors"
.PP
\&\f(CW\*(C`find\*(C'\fR returns a MongoDB::Cursor, which can be iterated over.  It lazily
loads results from the database.  The following prints all of the users' names:
.PP
.Vb 3
\&    while (my $doc = $all_users\->next) {
\&        print $doc\->{\*(Aqname\*(Aq}."\en";
\&    }
.Ve
.PP
A cursor can also be converted into an array of hash references.  For example,
to print the \*(L"name\*(R" field of the first result:
.PP
.Vb 2
\&    my @arr = $geeks\->all;
\&    print $arr[0]\->{\*(Aqname\*(Aq}."\en";
.Ve
.SS "Updating Documents"
.IX Subsection "Updating Documents"
\fI\f(CI\*(C`$\*(C'\fI\-operators\fR
.IX Subsection "$-operators"
.PP
To change a document after it has been saved to the database, you must pass
update_one (or
update_many to change many documents at
once) two arguments.  The first is a query argument, identical to the
previous section, to identify the document you want to change.  The second
is an argument that describes the change that you wish to make.
.PP
The change is described by $\-prefixed descriptors.  For example, to increment a
field, we would write:
.PP
.Vb 1
\&    $users\->update_one({"_id" => $id}, {\*(Aq$inc\*(Aq => {\*(Aqage\*(Aq => 1}});
.Ve
.PP
To add an element to an array, we can use \f(CW$push\fR.  So, to add an element to
the \f(CW"likes"\fR array, we write:
.PP
.Vb 1
\&    $users\->update_one({"_id" => $id}, {\*(Aq$push\*(Aq => {\*(Aqlikes\*(Aq => \*(Aqreading\*(Aq}});
.Ve
.PP
To add a new field or change the type or value of an existing field, we use
\&\f(CW$set\fR.  For example, to change the \f(CW\*(C`name\*(C'\fR field to a username, we would say:
.PP
.Vb 1
\&    $users\->update_one({"_id" => $id}, {\*(Aq$set\*(Aq => {\*(Aqname\*(Aq => \*(Aqjoe_schmoe\*(Aq}});
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
\&\f(CW\*(C`update_one\*(C'\fR and \f(CW\*(C`update_many\*(C'\fR do nothing if no document matches the
query.
.PP
Sometimes we may want update to create an element if it does not already
exist.  This is called an 'upsert' (a combination of an update and an
insert).  For example, the same code could be used for creating and
updating a log document:
.PP
.Vb 5
\&    $pageviews\->update_one(
\&        {"url" => "www.example.com"},
\&        {\*(Aq$inc\*(Aq => {"views" => 1}},
\&        {\*(Aqupsert\*(Aq => 1}
\&    );
.Ve
.PP
If the pageview counter for www.example.com did not exist yet, it would be
created and the \*(L"views\*(R" field would be set to 1.  If it did exist, the \*(L"views\*(R"
field would be incremented.
.SS "Deleting Documents"
.IX Subsection "Deleting Documents"
To delete documents, we use the delete_one
or delete_many methods.
They take the same type of hash queries do:
.PP
.Vb 1
\&    $users\->delete_many({"name" => "Joe"});
.Ve
.PP
It does not delete the collection, though (in that it will still appear
if the user lists collections in the database and the indexes will still exist).
To remove a collection entirely, call \f(CW\*(C`drop\*(C'\fR:
.PP
.Vb 1
\&    $users\->drop;
.Ve
.PP
\&\f(CW\*(C`drop\*(C'\fR can also be used for whole databases:
.PP
.Vb 1
\&    $db\->drop;
.Ve
.SH "MONGODB BASICS"
.IX Header "MONGODB BASICS"
.SS "Database Commands"
.IX Subsection "Database Commands"
There is a large number of useful database commands that can be called
directly on \f(CW$db\fR with the run_command
method.
.PP
For example, you can use a database command to create a capped collection like
so:
.PP
.Vb 1
\&    use boolean; # imports \*(Aqtrue\*(Aq and \*(Aqfalse\*(Aq
\&
\&    my $cmd = [
\&        create => "posts",
\&        capped => true,
\&        size   => 10240,
\&        max    => 100
\&    ];
\&
\&    $db\->run_command($cmd);
.Ve
.PP
This will create a capped collection called \*(L"posts\*(R" in the current database.  It
has a maximum size of 10240 bytes and can contain up to 100 documents.  The
boolean module must be used whenever the database expects an actual
boolean argument (i.e. not \*(L"1\*(R" or \*(L"0\*(R").
.PP
MongoDB expects commands to have key/value pairs in a certain order, so you must
give arguments in an array reference (or Tie::IxHash object).
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Now that you know the basic syntax used by the Perl driver, you should be able
to translate the JavaScript examples in the main MongoDB documentation
(<http://www.mongodb.org>) into Perl.
.PP
Check out MongoDB::Examples for more examples.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
David Golden <david@mongodb.com>
.IP "\(bu" 4
Rassi <rassi@mongodb.com>
.IP "\(bu" 4
Mike Friedman <friedo@friedo.com>
.IP "\(bu" 4
Kristina Chodorow <k.chodorow@gmail.com>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2020 by MongoDB, Inc.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
