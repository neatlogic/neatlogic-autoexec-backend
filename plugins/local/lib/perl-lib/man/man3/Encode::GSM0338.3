.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Encode::GSM0338 3"
.TH Encode::GSM0338 3 "2019-10-08" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Encode::GSM0338 \-\- ESTI GSM 03.38 Encoding
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Encode qw/encode decode/; 
\&  $gsm0338 = encode("gsm0338", $utf8);    # loads Encode::GSM0338 implicitly
\&  $utf8    = decode("gsm0338", $gsm0338); # ditto
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1GSM0338\s0 is for \s-1GSM\s0 handsets. Though it shares alphanumerals with \s-1ASCII,\s0
control character ranges and other parts are mapped very differently,
mainly to store Greek characters.  There are also escape sequences
(starting with 0x1B) to cover e.g. the Euro sign.
.PP
This was once handled by Encode::Bytes but because of all those
unusual specifications, Encode 2.20 has relocated the support to
this module.
.SH "NOTES"
.IX Header "NOTES"
Unlike most other encodings,  the following always croaks on error
for any \f(CW$chk\fR that evaluates to true.
.PP
.Vb 2
\&  $gsm0338 = encode("gsm0338", $utf8      $chk);
\&  $utf8    = decode("gsm0338", $gsm0338,  $chk);
.Ve
.PP
So if you want to check the validity of the encoding, surround the
expression with \f(CW\*(C`eval {}\*(C'\fR block as follows;
.PP
.Vb 5
\&  eval {
\&    $utf8    = decode("gsm0338", $gsm0338,  $chk);
\&  } or do {
\&    # handle exception here
\&  };
.Ve
.SH "BUGS"
.IX Header "BUGS"
\&\s-1ESTI GSM 03.38\s0 Encoding itself.
.PP
Mapping \ex00 to '@' causes too much pain everywhere.
.PP
Its use of \ex1b (escape) is also very questionable.
.PP
Because of those two, the code paging approach used use in ucm-based
Encoding \s-1SOMETIMES\s0 fails so this module was written.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode
