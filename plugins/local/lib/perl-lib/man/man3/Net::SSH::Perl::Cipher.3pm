.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Cipher 3"
.TH Net::SSH::Perl::Cipher 3 "2021-07-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Perl::Cipher \- Base cipher class, plus utility methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::SSH::Perl::Cipher;
\&
\&    # Get list of supported cipher IDs.
\&    my $supported = Net::SSH::Perl::Cipher::supported();
\&
\&    # Translate a cipher name into an ID.
\&    my $id = Net::SSH::Perl::Cipher::id($name);
\&
\&    # Translate a cipher ID into a name.
\&    my $name = Net::SSH::Perl::Cipher::name($id);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Cipher\fR provides a base class for each of
the encryption cipher classes. In addition, it defines
a set of utility methods that can be called either as
functions or object methods.
.SH "UTILITY METHODS"
.IX Header "UTILITY METHODS"
.ie n .SS "supported( [ protocol => $protocol, ] [ $ciph_id [, $server_supports ] ])"
.el .SS "supported( [ protocol => \f(CW$protocol\fP, ] [ \f(CW$ciph_id\fP [, \f(CW$server_supports\fP ] ])"
.IX Subsection "supported( [ protocol => $protocol, ] [ $ciph_id [, $server_supports ] ])"
Without arguments returns a reference to an array of
ciphers supported by \fINet::SSH::Perl\fR. These are ciphers
that have working Net::SSH::Perl::Cipher:: implementations,
essentially.  Pass 'protocol => 2' to get a list of
\&\s-1SSH2\s0 ciphers.
.PP
With one argument \fI\f(CI$ciph_id\fI\fR, returns a true value if
that cipher is supported by \fINet::SSH::Perl\fR, and false
otherwise.
.PP
With two arguments, \fI\f(CI$ciph_id\fI\fR and \fI\f(CI$server_supports\fI\fR,
returns true if the cipher represented by \fI\f(CI$ciph_id\fI\fR
is supported both by \fINet::SSH::Perl\fR and by the sshd
server. The list of ciphers supported by the server
should be in \fI\f(CI$server_supports\fI\fR, a bit mask sent
from the server during the session identification
phase.
.PP
Can be called either as a non-exported function, i.e.
.PP
.Vb 1
\&    my $i_support = Net::SSH::Perl::Cipher::supported();
.Ve
.PP
or as an object method of a \fINet::SSH::Perl::Cipher\fR
object, or an object of a subclass:
.PP
.Vb 3
\&    if ($ciph\->supported($server_supports)) {
\&        print "Server supports cipher $ciph";
\&    }
.Ve
.ie n .SS "id( [ $cipher_name ] )"
.el .SS "id( [ \f(CW$cipher_name\fP ] )"
.IX Subsection "id( [ $cipher_name ] )"
Translates a cipher name into a cipher \s-1ID.\s0
.PP
If given \fI\f(CI$cipher_name\fI\fR translates that name into
the corresponding \s-1ID.\s0 If called as an object method,
translates the object's cipher class name into the
\&\s-1ID.\s0
.ie n .SS "name( [ $cipher_id ] )"
.el .SS "name( [ \f(CW$cipher_id\fP ] )"
.IX Subsection "name( [ $cipher_id ] )"
Translates a cipher \s-1ID\s0 into a cipher name.
.PP
If given \fI\f(CI$cipher_id\fI\fR translates that \s-1ID\s0 into the
corresponding name. If called as an object method,
returns the (stripped) object's cipher class name;
for example, if the object were of type
\&\fINet::SSH::Perl::Cipher::IDEA\fR, \fIname\fR would return
\&\fI\s-1IDEA\s0\fR.
.SH "CIPHER USAGE"
.IX Header "CIPHER USAGE"
.ie n .SS "Net::SSH::Perl::Cipher\->new($cipher_name, $key)"
.el .SS "Net::SSH::Perl::Cipher\->new($cipher_name, \f(CW$key\fP)"
.IX Subsection "Net::SSH::Perl::Cipher->new($cipher_name, $key)"
Instantiates a new cipher object of the type
\&\fI\f(CI$cipher_name\fI\fR with the key \fI\f(CI$key\fI\fR; returns
the cipher object, which will be blessed into the
actual cipher subclass.
.PP
If \fI\f(CI$cipher_name\fI\fR is the special type \fI'None'\fR
(no encryption cipher), the object will actually
be blessed directly into the base class, and
text to be encrypted and decrypted will be passed
through without change.
.ie n .SS "$cipher\->encrypt($text)"
.el .SS "\f(CW$cipher\fP\->encrypt($text)"
.IX Subsection "$cipher->encrypt($text)"
Encrypts \fI\f(CI$text\fI\fR and returns the encrypted string.
.ie n .SS "$cipher\->decrypt($text)"
.el .SS "\f(CW$cipher\fP\->decrypt($text)"
.IX Subsection "$cipher->decrypt($text)"
Decrypts \fI\f(CI$text\fI\fR and returns the decrypted string.
.SH "CIPHER DEVELOPMENT"
.IX Header "CIPHER DEVELOPMENT"
Classes implementing an encryption cipher must
implement the following three methods:
.IP "\(bu" 4
\&\f(CW$class\fR\->new($key)
.Sp
Given a key \fI\f(CI$key\fI\fR, should construct a new cipher
object and bless it into \fI\f(CI$class\fI\fR, presumably.
.IP "\(bu" 4
\&\f(CW$cipher\fR\->encrypt($text)
.Sp
Given plain text \fI\f(CI$text\fI\fR, should encrypt the text
and return the encrypted string.
.IP "\(bu" 4
\&\f(CW$cipher\fR\->decrypt($text)
.Sp
Given encrypted text \fI\f(CI$text\fI\fR, should decrypt the
text and return the decrypted string.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
