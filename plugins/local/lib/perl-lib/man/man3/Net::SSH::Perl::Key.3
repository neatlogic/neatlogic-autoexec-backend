.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Key 3"
.TH Net::SSH::Perl::Key 3 "2021-05-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Perl::Key \- Public or private key abstraction
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Net::SSH::Perl::Key;
\&    my $key = Net::SSH::Perl::Key\->new;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Key\fR implements an abstract base class interface
to key objects (either \s-1DSA\s0 or \s-1RSA\s0 keys, currently). The underlying
implementation for \s-1RSA\s0 is an internal, hash-reference implementation;
the \s-1DSA\s0 implementation uses \fICrypt::DSA\fR.
.SH "USAGE"
.IX Header "USAGE"
.ie n .SS "Net::SSH::Perl::Key\->new($key_type [, $blob [, $compat_flag_ref ]])"
.el .SS "Net::SSH::Perl::Key\->new($key_type [, \f(CW$blob\fP [, \f(CW$compat_flag_ref\fP ]])"
.IX Subsection "Net::SSH::Perl::Key->new($key_type [, $blob [, $compat_flag_ref ]])"
Creates a new object of type \fINet::SSH::Perl::Key::$key_type\fR,
after loading the class implementing \fI\f(CI$key_type\fI\fR. \fI\f(CI$key_type\fI\fR
should be either \f(CW\*(C`DSA\*(C'\fR or \f(CW\*(C`RSA1\*(C'\fR, currently; these are the
only supported key implementations at the moment.
.PP
\&\fI\f(CI$blob\fI\fR, if present, should be a string representation of the key,
from which the key object can be initialized. In fact, it should
be the representation that is returned from the \fIas_blob\fR method,
below.
.PP
\&\fI\f(CI$compat_flag_ref\fI\fR should be a reference to the \s-1SSH\s0 compatibility
flag, which is generally stored inside of the \fINet::SSH::Perl\fR
object. This flag is used by certain key implementations (\f(CW\*(C`DSA\*(C'\fR)
to work around differences between \s-1SSH2\s0 protocol implementations.
.PP
Returns the new key object, which is blessed into the subclass.
.ie n .SS "Net::SSH::Perl::Key\->read_private($key_type, $file [, $pass])"
.el .SS "Net::SSH::Perl::Key\->read_private($key_type, \f(CW$file\fP [, \f(CW$pass\fP])"
.IX Subsection "Net::SSH::Perl::Key->read_private($key_type, $file [, $pass])"
Reads a private key of type \fI\f(CI$key_type\fI\fR out of the key file
\&\fI\f(CI$file\fI\fR. If the private key is encrypted, an attempt will be
made to decrypt it using the passphrase \fI\f(CI$pass\fI\fR; if \fI\f(CI$pass\fI\fR
is not provided, the empty string will be used. An empty
passphrase can be a handy way of providing password-less access
using publickey authentication.
.PP
If for any reason loading the key fails, returns \fIundef\fR; most
of the time, if loading the key fails, it's because the passphrase
is incorrect. If you first tried to read the key using an empty
passphrase, this might be a good time to ask the user for the
actual passphrase. :)
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fI\f(CI$key_type\fI\fR (either \f(CW\*(C`DSA\*(C'\fR or \f(CW\*(C`RSA1\*(C'\fR).
.ie n .SS "Net::SSH::Perl::Key\->keygen($key_type, $bits)"
.el .SS "Net::SSH::Perl::Key\->keygen($key_type, \f(CW$bits\fP)"
.IX Subsection "Net::SSH::Perl::Key->keygen($key_type, $bits)"
Generates a new key and returns that key. The key returned is
the private key, which (presumably) contains all of the public
key data, as well. \fI\f(CI$bits\fI\fR is the number of bits in the key.
.PP
Your \fI\f(CI$key_type\fI\fR implementation may not support key generation;
if not, calling this method is a fatal error.
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fI\f(CI$key_type\fI\fR (either \f(CW\*(C`DSA\*(C'\fR or \f(CW\*(C`RSA1\*(C'\fR).
.ie n .SS "Net::SSH::Perl::Key\->extract_public($key_type, $key_string)"
.el .SS "Net::SSH::Perl::Key\->extract_public($key_type, \f(CW$key_string\fP)"
.IX Subsection "Net::SSH::Perl::Key->extract_public($key_type, $key_string)"
Given a key string \fI\f(CI$key_string\fI\fR, which should be a textual
representation of the public portion of a key of \fI\f(CI$key_type\fI\fR,
extracts the key attributes out of that string. This is used to
extract public keys out of entries in \fIknown_hosts\fR and public
identity files.
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fI\f(CI$key_type\fI\fR (either \f(CW\*(C`DSA\*(C'\fR or \f(CW\*(C`RSA1\*(C'\fR).
.ie n .SS "$key\->write_private([ $file [, $pass] ])"
.el .SS "\f(CW$key\fP\->write_private([ \f(CW$file\fP [, \f(CW$pass\fP] ])"
.IX Subsection "$key->write_private([ $file [, $pass] ])"
Writes out the private key \fI\f(CI$key\fI\fR to \fI\f(CI$file\fI\fR, and encrypts
it using the passphrase \fI\f(CI$pass\fI\fR. If \fI\f(CI$pass\fI\fR is not provided,
the key is unencrypted, and the only security protection is
through filesystem protections.
.PP
If \fI\f(CI$file\fI\fR is not provided, returns the content that would
have been written to the key file.
.ie n .SS "$key\->dump_public"
.el .SS "\f(CW$key\fP\->dump_public"
.IX Subsection "$key->dump_public"
Performs the inverse of \fIextract_public\fR: takes a key \fI\f(CI$key\fI\fR
and dumps out a textual representation of the public portion
of the key. This is used when writing public key entries to
\&\fIknown_hosts\fR and public identity files.
.PP
Returns the textual representation.
.ie n .SS "$key\->as_blob"
.el .SS "\f(CW$key\fP\->as_blob"
.IX Subsection "$key->as_blob"
Returns a string representation of the public portion of the
key; this is \fInot\fR the same as \fIdump_public\fR, which is
intended to match the format used in \fIknown_hosts\fR, etc.
The return value of \fIas_blob\fR is used as an intermediary in
computing other values: the key fingerprint, the known hosts
representation, etc.
.ie n .SS "$key\->equal($key2)"
.el .SS "\f(CW$key\fP\->equal($key2)"
.IX Subsection "$key->equal($key2)"
Returns true if the public portions of \fI\f(CI$key\fI\fR are equal to
those of \fI\f(CI$key2\fI\fR, and false otherwise. This is used when
comparing server host keys to keys in \fIknown_hosts\fR.
.ie n .SS "$key\->size"
.el .SS "\f(CW$key\fP\->size"
.IX Subsection "$key->size"
Returns the size (in bits) of the key \fI\f(CI$key\fI\fR.
.ie n .SS "$key\->fingerprint([ \fI\fP\f(CI$type\fP\fI\fP ])"
.el .SS "\f(CW$key\fP\->fingerprint([ \fI\fP\f(CI$type\fP\fI\fP ])"
.IX Subsection "$key->fingerprint([ $type ])"
Returns a fingerprint of \fI\f(CI$key\fI\fR. The default fingerprint is
a hex representation; if \fI\f(CI$type\fI\fR is equal to \f(CW\*(C`bubblebabble\*(C'\fR,
the Bubble Babble representation of the fingerprint is used
instead. The former uses an \fI\s-1MD5\s0\fR digest of the public key,
and the latter uses a \fI\s-1SHA\-1\s0\fR digest.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
