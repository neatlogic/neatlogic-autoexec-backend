.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Packet 3"
.TH Net::SSH::Perl::Packet 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Perl::Packet \- Packet layer of SSH protocol
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::SSH::Perl::Packet;
\&
\&    # Send a packet to an ssh daemon.
\&    my $pack = Net::SSH::Perl::Packet\->new($ssh, type => SSH_MSG_NONE);
\&    $pack\->send;
\&
\&    # Receive a packet.
\&    my $pack = Net::SSH::Perl::Packet\->read($ssh);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Packet\fR implements the packet-layer piece
of the \s-1SSH\s0 protocol. Messages between server and client
are sent as binary data packets, which are encrypted
(once the two sides have agreed on the encryption
cipher, that is).
.PP
Packets are made up primarily of a packet type, which
describes the type of message and data contained
therein, and the data itself. In addition, each packet:
indicates its length in a 32\-bit unsigned integer;
contains padding to pad the length of the packet to
a multiple of 8 bytes; and is verified by a 32\-bit crc
checksum.
.PP
Refer to the \s-1SSH RFC\s0 for more details on the packet
protocol and the \s-1SSH\s0 protocol in general.
.SH "USAGE"
.IX Header "USAGE"
.ie n .SS "Net::SSH::Perl::Packet\->new($ssh, %params)"
.el .SS "Net::SSH::Perl::Packet\->new($ssh, \f(CW%params\fP)"
.IX Subsection "Net::SSH::Perl::Packet->new($ssh, %params)"
Creates/starts a new packet in memory. \fI\f(CI$ssh\fI\fR is
a \fINet::SSH::Perl\fR object, which should already be connected
to an ssh daemon. \fI\f(CI%params\fI\fR can contain the following
keys:
.IP "\(bu" 4
type
.Sp
The message type of this packet. This should be one of
the values exported by \fINet::SSH::Perl::Constants\fR from the
\&\fImsg\fR tag; for example, \fI\s-1SSH_MSG_NONE\s0\fR.
.IP "\(bu" 4
data
.Sp
A \fINet::SSH::Perl::Buffer\fR object containing the data in this
packet. Realistically, there aren't many times you'll need
to supply this argument: when sending a packet, it will be
created automatically; and when receiving a packet, the
\&\fIread\fR method (see below) will create the buffer
automatically, as well.
.SS "Net::SSH::Perl::Packet\->read($ssh)"
.IX Subsection "Net::SSH::Perl::Packet->read($ssh)"
Reads a packet from the ssh daemon and returns that packet.
.PP
This method will block until an entire packet has been read.
The socket itself is non-blocking, but the method waits (using
\&\fIselect\fR) for data on the incoming socket, then processes
that data when it comes in. If the data makes up a complete
packet, the packet is returned to the caller. Otherwise \fIread\fR
continues to try to read more data.
.SS "Net::SSH::Perl::Packet\->read_poll($ssh)"
.IX Subsection "Net::SSH::Perl::Packet->read_poll($ssh)"
Checks the data that's been read from the sshd to see if that
data comprises a complete packet. If so, that packet is
returned. If not, returns \f(CW\*(C`undef\*(C'\fR.
.PP
This method does not block.
.ie n .SS "Net::SSH::Perl::Packet\->read_expect($ssh, $type)"
.el .SS "Net::SSH::Perl::Packet\->read_expect($ssh, \f(CW$type\fP)"
.IX Subsection "Net::SSH::Perl::Packet->read_expect($ssh, $type)"
Reads the next packet from the daemon and dies if the
packet type does not match \fI\f(CI$type\fI\fR. Otherwise returns
the read packet.
.ie n .SS "$packet\->send([ $data ])"
.el .SS "\f(CW$packet\fP\->send([ \f(CW$data\fP ])"
.IX Subsection "$packet->send([ $data ])"
Sends a packet to the ssh daemon. \fI\f(CI$data\fI\fR is optional,
and if supplied specifies the buffer to be sent in
the packet (should be a \fINet::SSH::Perl::Buffer\fR object).
In addition, \fI\f(CI$data\fI\fR, if specified, \fImust\fR include
the packed message type.
.PP
If \fI\f(CI$data\fI\fR is not specified, \fIsend\fR sends the buffer
internal to the packet, which you've presumably filled
by calling the \fIput_*\fR methods (see below).
.ie n .SS "$packet\->type"
.el .SS "\f(CW$packet\fP\->type"
.IX Subsection "$packet->type"
Returns the message type of the packet \fI\f(CI$packet\fI\fR.
.ie n .SS "$packet\->data"
.el .SS "\f(CW$packet\fP\->data"
.IX Subsection "$packet->data"
Returns the message buffer from the packet \fI\f(CI$packet\fI\fR;
a \fINet::SSH::Perl::Buffer\fR object.
.SS "Net::SSH::Perl::Buffer methods"
.IX Subsection "Net::SSH::Perl::Buffer methods"
Calling methods from the \fINet::SSH::Perl::Buffer\fR class on
your \fINet::SSH::Perl::Packet\fR object will automatically
invoke those methods on the buffer object internal
to your packet object (which is created when your
object is constructed). For example, if you executed
the following code:
.PP
.Vb 2
\&    my $packet = Net::SSH::Perl::Packet\->new($ssh, type => SSH_CMSG_USER);
\&    $packet\->put_str($user);
.Ve
.PP
this would construct a new packet object \fI\f(CI$packet\fI\fR,
then fill its internal buffer by calling the
\&\fIput_str\fR method on it.
.PP
Refer to the \fINet::SSH::Perl::Buffer\fR documentation
(the \fI\s-1GET AND PUT METHODS\s0\fR section) for more details
on those methods.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
