.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SOAP::Serializer 3"
.TH SOAP::Serializer 3 "2021-05-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SOAP::Serializer \- the means by which the toolkit manages the expression of data as XML
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The SOAP::Serializer class is the means by which the toolkit manages the expression of data as \s-1XML.\s0 The object that a SOAP::Lite instance uses by default is generally enough for the task, with no need for the application to create its own. The main purpose of this class is to provide a place for applications to extend the serializer by defining additional methods for handling new datatypes.
.SH "METHODS"
.IX Header "METHODS"
.IP "new(optional key/value pairs)" 4
.IX Item "new(optional key/value pairs)"
.Vb 1
\&    $serialize = SOAP::Serializer\->new( );
.Ve
.Sp
This is the constructor method for the class. In addition to creating a basic object and initializing it with default values, the constructor can also take names and values for most of the accessor methods that the class supports.
.IP "envelope(method, data arguments)" 4
.IX Item "envelope(method, data arguments)"
.Vb 1
\&    $serialize\->envelope(fault => $fault_obj);
.Ve
.Sp
Provides the core purpose for the SOAP::Serializer class. It creates the full \s-1SOAP\s0 envelope based on the input passed in to it. The data arguments passed in the list of parameters to the method are divided into two sublists: any parameters that are SOAP::Header objects or derivatives of go into one list, while the remainder go into the other. The nonheader objects are used as the content for the message body, with the body itself being largely dependent on the value of the first argument in the list. This argument is expected to be a string and should be one of the following:
.IP "context" 4
.IX Item "context"
.Vb 1
\&    $serialize\->context\->packager();
.Ve
.Sp
This provides access to the calling context of \f(CW\*(C`SOAP::Serializer\*(C'\fR. In a client side context the often means a reference to an instance of SOAP::Lite. In a server side context this means a reference to a SOAP::Server instance.
.RS 4
.IP "method" 4
.IX Item "method"
The envelope is being created to encapsulate a RPC-style method call.
.IP "response" 4
.IX Item "response"
The message being created is that of a response stemming from a RPC-style method call.
.IP "fault" 4
.IX Item "fault"
For this specifier, the envelope being created is to transmit a fault.
.IP "freeform" 4
.IX Item "freeform"
This identifier is used as a general-case encoding style for messages that
don't fit into any of the previous cases. The arguments are encoded into the
envelope's Body tag without any sort of context sensitivity.
.RE
.RS 4
.Sp
Any value other than these four results in an error.
.RE
.IP "envprefix(optional value)" 4
.IX Item "envprefix(optional value)"
.Vb 1
\&    $serialize\->envprefix(\*(Aqenv\*(Aq);
.Ve
.Sp
Gets or sets the prefix that labels the \s-1SOAP\s0 envelope namespace. This defaults to SOAP-ENV.
.IP "encprefix(optional value)" 4
.IX Item "encprefix(optional value)"
.Vb 1
\&    $serialize\->envprefix(\*(Aqenc\*(Aq);
.Ve
.Sp
Gets or sets the prefix that labels the \s-1SOAP\s0 encoding namespace. Defaults to SOAP-ENC.
.IP "soapversion(optional value)" 4
.IX Item "soapversion(optional value)"
.Vb 1
\&    $serialize\->soapversion(\*(Aq1.2\*(Aq);
.Ve
.Sp
If no parameter is given, returns the current version of \s-1SOAP\s0 that is being used as the basis for serializing messages. If a parameter is given, attempts to set that as the version of \s-1SOAP\s0 being used. The value should be either 1.1 or 1.2. When the \s-1SOAP\s0 version is being set, the package selects new URNs for envelope and encoding spaces and also calls the xmlschema method to set the appropriate schema definition.
.IP "xmlschema(optional value)" 4
.IX Item "xmlschema(optional value)"
.Vb 1
\&    $serialize\->xmlschema($xml_schema_1999);
.Ve
.Sp
Gets or sets the \s-1URN\s0 for the schema being used to express the structure of the \s-1XML\s0 generated by the serializer. If setting the value, the input must be the full \s-1URN\s0 for the new schema and is checked against the list of known \s-1SOAP\s0 schemas.
.IP "register_ns" 4
.IX Item "register_ns"
The register_ns subroutine allows users to register a global namespace
with the \s-1SOAP\s0 Envelope. The first parameter is the namespace, the second
parameter to this subroutine is an optional prefix. If a prefix is not
provided, one will be generated automatically for you. All namespaces
registered with the serializer get declared in the <soap:Envelope />
element.
.IP "find_prefix" 4
.IX Item "find_prefix"
The find_prefix subroutine takes a namespace as a parameter and returns
the assigned prefix to that namespace. This eliminates the need to declare
and redeclare namespaces within an envelope. This subroutine is especially
helpful in determining the proper prefix when assigning a type to a
SOAP::Data element. A good example of how this might be used is as follows:
.Sp
.Vb 2
\&    SOAP::Data\->name("foo" => $inputParams{\*(Aqfoo\*(Aq})
\&       \->type($client\->serializer\->find_prefix(\*(Aqurn:Foo\*(Aq).\*(Aq:Foo\*(Aq);
.Ve
.SH "CUSTOM DATA TYPES"
.IX Header "CUSTOM DATA TYPES"
When serializing an object, or blessed hash reference, into \s-1XML,\s0 \f(CW\*(C`SOAP::Serializer\*(C'\fR first checks to see if a subroutine has been defined for the corresponding class name. For example, in the code below, \f(CW\*(C`SOAP::Serializer\*(C'\fR will check to see if a subroutine called \f(CW\*(C`as_MyModule_\|_MyPackage\*(C'\fR has been defined. If so, then it will pass \f(CW$foo\fR to that subroutine along with other data known about the \f(CW\*(C`SOAP::Data\*(C'\fR element being encoded.
.PP
.Vb 5
\&   $foo = MyModule::MyPackage\->new;
\&   my $client = SOAP::Lite
\&      \->uri($NS)
\&      \->proxy($HOST);
\&   $som = $client\->someMethod(SOAP::Data\->name("foo" => $foo));
.Ve
.SH "as_TypeName SUBROUTINE REQUIREMENTS"
.IX Header "as_TypeName SUBROUTINE REQUIREMENTS"
.IP "Naming Convention" 4
.IX Item "Naming Convention"
The subroutine should always be prepended with \f(CW\*(C`as_\*(C'\fR followed by the type's name. The type's name must have all colons (':') substituted with an underscore ('_').
.IP "Input" 4
.IX Item "Input"
The input to \f(CW\*(C`as_TypeName\*(C'\fR will have at least one parameter, and at most four parameters. The first parameter will always be the value or the object to be encoded. The following three parameters depend upon the context of the value/object being encoded.
.Sp
If the value/object being encoded was part of a \f(CW\*(C`SOAP::Data\*(C'\fR object (as in the above example), then the second, third and fourth parameter will be the \f(CW\*(C`SOAP::Data\*(C'\fR element's name, type, and attribute set respectively. If on the other hand, the value/object being encoded is \fInot\fR part of a \f(CW\*(C`SOAP::Data\*(C'\fR object, as in the code below:
.Sp
.Vb 5
\&   $foo = MyModule::MyPackage\->new;
\&   my $client = SOAP::Lite
\&      \->uri($NS)
\&      \->proxy($HOST);
\&   $som = $client\->someMethod($foo);
.Ve
.Sp
Then the second and third parameters will be the class name of the value/object being encoded (e.g. \*(L"MyModule::MyPackage\*(R" in the example above), and the fourth parameter will be an empty hash.
.IP "Output" 4
.IX Item "Output"
The encoding subroutine must return an array containing three elements: 1) the name of the \s-1XML\s0 element, 2) a hash containing the attributes to be placed into the element, and 3) the value of the element.
.SH "AUTOTYPING"
.IX Header "AUTOTYPING"
When the type of an element has not been declared explicitly, SOAP::Lite must \*(L"guess\*(R" at the object's type. That is due to the fact that the only form of introspection that Perl provides (through the use of the \f(CW\*(C`ref\*(C'\fR subroutine) does not provide enough information to \f(CW\*(C`SOAP::Serializer\*(C'\fR to allow SOAP::Lite to determine the exact type of an element being serialized.
.PP
To work around this limitation, the \f(CW\*(C`SOAP::Serializer::typelookup\*(C'\fR hash was created. This hash is populated with all the data types that the current \f(CW\*(C`SOAP::Serializer\*(C'\fR can auto detect. Users and developers are free to modify the contents of this hash allowing them to register new data types with the system.
.PP
When \f(CW\*(C`SOAP::Serializer\*(C'\fR is asked to encode an object into \s-1XML,\s0 it goes through the following steps. First, \f(CW\*(C`SOAP::Serializer\*(C'\fR checks to see if a type has been explicitly stated for the current object. If a type has been provided \f(CW\*(C`SOAP::Serializer\*(C'\fR checks to see if an \f(CW\*(C`as_TypeName\*(C'\fR subroutine as been defined for that type. If such a subroutine exists, then \f(CW\*(C`SOAP::Serializer\*(C'\fR passes the object to it to be encoded. If the subroutine does not exist, or the type has not been provided, then \f(CW\*(C`SOAP::Serializer\*(C'\fR must attempt to \*(L"guess\*(R" the type of the object being serialized.
.PP
To do so, \f(CW\*(C`SOAP::Serializer\*(C'\fR runs in sequence a set of tests stored in the \f(CW\*(C`SOAP::Serializer::typelookup\*(C'\fR hash. \f(CW\*(C`SOAP::Serializer\*(C'\fR continues to run each test until one of the tests returns true, indicating that the type of the object has been detected. When the type of the object has been detected, then \f(CW\*(C`SOAP::Serializer\*(C'\fR passes the object to the encoding subroutine that corresponds with the test that was passed. If all the tests fail, and the type was not determined, then \f(CW\*(C`SOAP::Serializer\*(C'\fR will as a last resort encode the object based on one of the four basic data types known to Perl: \s-1REF, SCALAR, ARRAY\s0 and \s-1HASH.\s0
.PP
The following table contains the set of data types detectable by \f(CW\*(C`SOAP::Lite\*(C'\fR by default and the order in which their corresponding test subroutine will be run, according to their precedence value.
.PP
.Vb 1
\&  Table 1 \- Autotyping Precedence
\&
\&  TYPENAME    PRECEDENCE VALUE
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  base64      10
\&  int         20
\&  long        25
\&  float       30
\&  gMonth      35
\&  gDay        40
\&  gYear       45
\&  gMonthDay   50
\&  gYearMonth  55
\&  date        60
\&  time        70
\&  dateTime    75
\&  duration    80
\&  boolean     90
\&  anyURI      95
\&  string      100
.Ve
.SS "\s-1REGISTERING A NEW DATA TYPE\s0"
.IX Subsection "REGISTERING A NEW DATA TYPE"
To register a new data type that can be automatically detected by \f(CW\*(C`SOAP::Lite\*(C'\fR and then serialized into \s-1XML,\s0 the developer must provide the following four things:
.IP "\(bu" 4
The name of the new data type.
.IP "\(bu" 4
A subroutine that is capable of detecting whether a value passed to it is of the corresponding data type.
.IP "\(bu" 4
A number representing the test subroutine's precedence relative to all the other types' test subroutinestypes. See \fITable 1 \- Autotyping Precedence\fR.
.IP "\(bu" 4
A subroutine that is capable of providing \f(CW\*(C`SOAP::Serializer\*(C'\fR with the information necessary to serialize an object of the corresponding data type into \s-1XML.\s0
.PP
\fI\s-1EXAMPLE 1\s0\fR
.IX Subsection "EXAMPLE 1"
.PP
If, for example, you wish to create a new datatype called \f(CW\*(C`uriReference\*(C'\fR for which you would like Perl values to be automatically detected and serialized into, then you follow these steps.
.PP
\&\fBStep 1: Write a Test Subroutine\fR
.PP
The test subroutine will have passed to it by \f(CW\*(C`SOAP::Serializer\*(C'\fR a value to be tested. The test subroutine must return 1 if the value passed to it is of the corresponding type, or else it must return 0.
.PP
.Vb 5
\&    sub SOAP::Serializer::uriReferenceTest {
\&      my ($value) = @_;
\&      return 1 if ($value =~ m!^http://!);
\&      return 0;
\&    }
.Ve
.PP
\&\fBStep 2: Write an Encoding Subroutine\fR
.PP
The encoding subroutine provides \f(CW\*(C`SOAP::Serializer\*(C'\fR with the data necessary to encode the value passed to it into \s-1XML.\s0 The encoding subroutine name's should be of the following format: \f(CW\*(C`as_\*(C'\fR<Type Name>.
.PP
The encoding subroutine will have passed to it by \f(CW\*(C`SOAP::Serializer\*(C'\fR four parameters: the value to be encoded, the name of the element being encoded, the assumed type of the element being encoded, and a reference to a hash containing the attributes of the element being encoded. The encoding subroutine must return an array representing the encoded datatype. \f(CW\*(C`SOAP::Serializer\*(C'\fR will use the contents of this array to generate the corresponding \s-1XML\s0 of the value being encoded, or serialized. This array contains the following 3 elements: the name of the \s-1XML\s0 element, a hash containing the attributes to be placed into the element, and the value of the element.
.PP
.Vb 5
\&  sub SOAP::Serializer::as_uriReference {
\&    my $self = shift;
\&    my($value, $name, $type, $attr) = @_;
\&    return [$name, {\*(Aqxsi:type\*(Aq => \*(Aqxsd:uriReference\*(Aq, %$attr}, $value];
\&  }
.Ve
.PP
\&\fBStep 3: Register the New Data Type\fR
.PP
To register the new data type, simply add the type to the \f(CW\*(C`SOAP::Serializer::typelookup\*(C'\fR hash using the type name as the key, and an array containing the precedence value, the test subroutine, and the encoding subroutine.
.PP
.Vb 2
\&  $s\->typelookup\->{uriReference}
\&      = [11, \e&uriReferenceTest, \*(Aqas_uriReference\*(Aq];
.Ve
.PP
\&\fITip: As a short hand, you could just as easily use an anonymous test subroutine when registering the new datatype in place of the \f(CI\*(C`urlReferenceTest\*(C'\fI subroutine above. For example:\fR
.PP
.Vb 2
\&  $s\->typelookup\->{uriReference}
\&      = [11, sub { $_[0] =~ m!^http://! }, \*(Aqas_uriReference\*(Aq];
.Ve
.PP
Once complete, \f(CW\*(C`SOAP::Serializer\*(C'\fR will be able to serialize the following \f(CW\*(C`SOAP::Data\*(C'\fR object into \s-1XML:\s0
.PP
.Vb 1
\&  $elem = SOAP::Data\->name("someUri" => \*(Aqhttp://yahoo.com\*(Aq)\->type(\*(AquriReference\*(Aq);
.Ve
.PP
\&\f(CW\*(C`SOAP::Serializer\*(C'\fR will also be able to automatically determine and serialize the following untyped \f(CW\*(C`SOAP::Data\*(C'\fR object into \s-1XML:\s0
.PP
.Vb 1
\&  $elem = SOAP::Data\->name("someUri" => \*(Aqhttp://yahoo.com\*(Aq);
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Special thanks to O'Reilly publishing which has graciously allowed SOAP::Lite to republish and redistribute large excerpts from \fIProgramming Web Services with Perl\fR, mainly the SOAP::Lite reference found in Appendix B.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2004 Paul Kulchenko. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Kulchenko (paulclinger@yahoo.com)
.PP
Randy J. Ray (rjray@blackperl.com)
.PP
Byrne Reese (byrne@majordojo.com)
