.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Auth 3"
.TH Net::SSH::Perl::Auth 3 "2021-07-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH::Perl::Auth \- Base authentication class, plus utility methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Net::SSH::Perl::Cipher;
\&
\&   # Get list of supported authentication IDs.
\&   my $supported = Net::SSH::Perl::Auth::supported();
\&
\&   # Translate an auth name into an ID.
\&   my $id = Net::SSH::Perl::Auth::id($name);
\&
\&   # Translate an auth ID into a name.
\&   my $name = Net::SSH::Perl::Auth::name($id);
\&
\&   # Get the order in which auth methods are tested.
\&   my $order = Net::SSH::Perl::Auth::order();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Auth\fR provides a base class for each of
the authentication method classes. In addition, it defines
a set of utility methods that can be called either as
functions or object methods.
.SH "UTILITY METHODS"
.IX Header "UTILITY METHODS"
.ie n .SS "supported( [ $auth_id [, $server_supports ] ])"
.el .SS "supported( [ \f(CW$auth_id\fP [, \f(CW$server_supports\fP ] ])"
.IX Subsection "supported( [ $auth_id [, $server_supports ] ])"
Without arguments, returns a reference to an array of
auth methods supported by \fINet::SSH::Perl\fR. These are methods
that have working Net::SSH::Perl::Auth:: implementations,
essentially.
.PP
With one argument \fI\f(CI$auth_id\fI\fR, returns a true value if
that auth method is supported by \fINet::SSH::Perl\fR, and
false otherwise.
.PP
With two arguments, \fI\f(CI$auth_id\fI\fR and \fI\f(CI$server_supports\fI\fR,
returns true if the auth represented by \fI\f(CI$auth_id\fI\fR
is supported both by \fINet::SSH::Perl\fR and by the sshd
server. The list of methods supported by the server
should be in \fI\f(CI$server_supports\fI\fR, a bit mask sent
from the server during the session identification
phase.
.PP
Can be called either as a non-exported function, i.e.
.PP
.Vb 1
\&    my $i_support = Net::SSH::Perl::Auth::supported();
.Ve
.PP
or as an object method of a \fINet::SSH::Perl::Auth\fR
object, or an object of a subclass (in which case
the first argument should be \fI\f(CI$server_supports\fI\fR,
not the \fI\f(CI$auth_id\fI\fR):
.PP
.Vb 3
\&    if ($auth\->supported($server_supports)) {
\&        print "Server supports auth method $auth";
\&    }
.Ve
.ie n .SS "id( [ $auth_name ] )"
.el .SS "id( [ \f(CW$auth_name\fP ] )"
.IX Subsection "id( [ $auth_name ] )"
Translates an auth method name into an \s-1ID \s0(suitable
for sending to the sshd server, for example).
.PP
If given \fI\f(CI$auth_name\fI\fR translates that name into
the corresponding \s-1ID.\s0 If called as an object method,
translates the object's auth class name into the
\&\s-1ID.\s0
.ie n .SS "name( [ $auth_id ] )"
.el .SS "name( [ \f(CW$auth_id\fP ] )"
.IX Subsection "name( [ $auth_id ] )"
Translates an auth method \s-1ID\s0 into a name.
.PP
If given \fI\f(CI$auth_id\fI\fR translates that \s-1ID\s0 into the
corresponding name. If called as an object method,
returns the (stripped) object's auth class name;
for example, if the object were of type
\&\fINet::SSH::Perl::Auth::Rhosts\fR, \fIname\fR would return
\&\fIRhosts\fR.
.SS "\fIauth_order()\fP"
.IX Subsection "auth_order()"
Returns a reference to an array containing auth method
IDs. These IDs describe the order in which authentication
should be tested against the server. So, for example, if
the array listed (2, 4, 3), then the client should test:
\&\s-1RSA,\s0 then Rhosts-RSA, then Password authentication.
.SH "AUTH USAGE"
.IX Header "AUTH USAGE"
.ie n .SS "Net::SSH::Perl::Auth\->new($auth_name, $ssh)"
.el .SS "Net::SSH::Perl::Auth\->new($auth_name, \f(CW$ssh\fP)"
.IX Subsection "Net::SSH::Perl::Auth->new($auth_name, $ssh)"
Instantiates a new auth object of the type
\&\fI\f(CI$auth_name\fI\fR, and gives it the \fINet::SSH::Perl\fR
object \fI\f(CI$ssh\fI\fR, which should contain an open
connection to an sshd server.
.PP
Returns the auth object, which will be blessed into
the actual auth subclass.
.ie n .SS "$valid = $auth\->\fIauthenticate()\fP"
.el .SS "\f(CW$valid\fP = \f(CW$auth\fP\->\fIauthenticate()\fP"
.IX Subsection "$valid = $auth->authenticate()"
Talks to the sshd server to authenticate the user;
if valid, returns true, and if invalid, returns
false.
.SH "AUTH DEVELOPMENT"
.IX Header "AUTH DEVELOPMENT"
Classes implementing an authentication method must implement
the following two methods:
.IP "\(bu" 4
\&\f(CW$class\fR\->new($ssh)
.Sp
Given a \fINet::SSH::Perl\fR object \fI\f(CI$ssh\fI\fR, should construct a
new auth object and bless it into \fI\f(CI$class\fI\fR, presumably.
.IP "\(bu" 4
\&\f(CW$class\fR\->\fIauthenticate()\fR
.Sp
Authenticate the current user with the remote daemon. This
requires following the messaging protocol defined for your
authentication method. All of the data you need\*(--user name,
password (if required), etc.\-\-should be in the \fI\f(CI$ssh\fI\fR
object.
.Sp
Returns 1 if the authentication is successful, 0 otherwise.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
