.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::Reactor::Poll 3"
.TH Mojo::Reactor::Poll 3 "2021-07-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mojo::Reactor::Poll \- Low\-level event reactor with poll support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::Reactor::Poll;
\&
\&  # Watch if handle becomes readable or writable
\&  my $reactor = Mojo::Reactor::Poll\->new;
\&  $reactor\->io($first => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqFirst handle is writable\*(Aq : \*(AqFirst handle is readable\*(Aq;
\&  });
\&
\&  # Change to watching only if handle becomes writable
\&  $reactor\->watch($first, 0, 1);
\&
\&  # Turn file descriptor into handle and watch if it becomes readable
\&  my $second = IO::Handle\->new_from_fd($fd, \*(Aqr\*(Aq);
\&  $reactor\->io($second => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqSecond handle is writable\*(Aq : \*(AqSecond handle is readable\*(Aq;
\&  })\->watch($second, 1, 0);
\&
\&  # Add a timer
\&  $reactor\->timer(15 => sub {
\&    my $reactor = shift;
\&    $reactor\->remove($first);
\&    $reactor\->remove($second);
\&    say \*(AqTimeout!\*(Aq;
\&  });
\&
\&  # Start reactor if necessary
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mojo::Reactor::Poll is a low-level event reactor based on IO::Poll.
.SH "EVENTS"
.IX Header "EVENTS"
Mojo::Reactor::Poll inherits all events from Mojo::Reactor.
.SH "METHODS"
.IX Header "METHODS"
Mojo::Reactor::Poll inherits all methods from Mojo::Reactor and
implements the following new ones.
.SS "again"
.IX Subsection "again"
.Vb 1
\&  $reactor\->again($id);
.Ve
.PP
Restart timer. Note that this method requires an active timer.
.SS "io"
.IX Subsection "io"
.Vb 1
\&  $reactor = $reactor\->io($handle => sub {...});
.Ve
.PP
Watch handle for I/O events, invoking the callback whenever handle becomes
readable or writable.
.PP
.Vb 5
\&  # Callback will be executed twice if handle becomes readable and writable
\&  $reactor\->io($handle => sub {
\&    my ($reactor, $writable) = @_;
\&    say $writable ? \*(AqHandle is writable\*(Aq : \*(AqHandle is readable\*(Aq;
\&  });
.Ve
.SS "is_running"
.IX Subsection "is_running"
.Vb 1
\&  my $bool = $reactor\->is_running;
.Ve
.PP
Check if reactor is running.
.SS "next_tick"
.IX Subsection "next_tick"
.Vb 1
\&  my $undef = $reactor\->next_tick(sub {...});
.Ve
.PP
Execute callback as soon as possible, but not before returning or other
callbacks that have been registered with this method, always returns \f(CW\*(C`undef\*(C'\fR.
.SS "one_tick"
.IX Subsection "one_tick"
.Vb 1
\&  $reactor\->one_tick;
.Ve
.PP
Run reactor until an event occurs or no events are being watched anymore. Note
that this method can recurse back into the reactor, so you need to be careful.
.PP
.Vb 4
\&  # Don\*(Aqt block longer than 0.5 seconds
\&  my $id = $reactor\->timer(0.5 => sub {});
\&  $reactor\->one_tick;
\&  $reactor\->remove($id);
.Ve
.SS "recurring"
.IX Subsection "recurring"
.Vb 1
\&  my $id = $reactor\->recurring(0.25 => sub {...});
.Ve
.PP
Create a new recurring timer, invoking the callback repeatedly after a given
amount of time in seconds.
.SS "remove"
.IX Subsection "remove"
.Vb 2
\&  my $bool = $reactor\->remove($handle);
\&  my $bool = $reactor\->remove($id);
.Ve
.PP
Remove handle or timer.
.SS "reset"
.IX Subsection "reset"
.Vb 1
\&  $reactor\->reset;
.Ve
.PP
Remove all handles and timers.
.SS "start"
.IX Subsection "start"
.Vb 1
\&  $reactor\->start;
.Ve
.PP
Start watching for I/O and timer events, this will block until \*(L"stop\*(R" is
called or no events are being watched anymore.
.PP
.Vb 2
\&  # Start reactor only if it is not running already
\&  $reactor\->start unless $reactor\->is_running;
.Ve
.SS "stop"
.IX Subsection "stop"
.Vb 1
\&  $reactor\->stop;
.Ve
.PP
Stop watching for I/O and timer events.
.SS "timer"
.IX Subsection "timer"
.Vb 1
\&  my $id = $reactor\->timer(0.5 => sub {...});
.Ve
.PP
Create a new timer, invoking the callback after a given amount of time in
seconds.
.SS "watch"
.IX Subsection "watch"
.Vb 1
\&  $reactor = $reactor\->watch($handle, $readable, $writable);
.Ve
.PP
Change I/O events to watch handle for with true and false values. Note that
this method requires an active I/O watcher.
.PP
.Vb 2
\&  # Watch only for readable events
\&  $reactor\->watch($handle, 1, 0);
\&
\&  # Watch only for writable events
\&  $reactor\->watch($handle, 0, 1);
\&
\&  # Watch for readable and writable events
\&  $reactor\->watch($handle, 1, 1);
\&
\&  # Pause watching for events
\&  $reactor\->watch($handle, 0, 0);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojolicious, Mojolicious::Guides, <http://mojolicious.org>.
