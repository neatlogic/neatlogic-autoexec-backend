#!/usr/bin/perl

use FindBin;
use lib "$FindBin::Bin/../lib/perl-lib/lib/perl5";
use lib "$FindBin::Bin/../lib";

use strict;
use Utils;
use Logger;
use RUNLock;
use MVNbuild;
use ANTbuild;
use NPMbuild;
use BuildGradle;
use ExecAuth;
use ENVInfo;
use ServerAdapter;
use IO::File;
use File::Path;
use File::Find;
use File::Copy;
use File::Basename;
use Cwd;
use VerGet;
use Getopt::Long;
Getopt::Long::Configure("pass_through");

sub usage {
    my $pname = $FindBin::Script;

    print(
"Usage: $pname [-v|--verbose] [-U|--update] --subsyspath <subsys path> --type <ant|mvn|gradle> --forcecompile [--diffdirname <diff build dir>] [--tag4cmpto <tag for source compare to>] [--startrev <revision>] [--endrev <revision>] [--srcpaths <source paths>] [--cmpoutpath <compile output path>] [--websrcpath <web source path>] [--webdistpath <web package path>] [ --jdk <jdk version> --nodejs <nodejs version> --startpath <start path> --lang <output charset> --args <build arguments> <version>\n"
    );
    print("       subsyspath:   sub system path\n");
    print("       jdk:          jdk version ,support [1.6|1.7(default)|1.8]\n");
    print("       startpath:    project releative path which contains build config file: build.xml, pom.xml...\n");
    print("       lang:         LANGUAGE, default: en_US.UTF8\n");
    print("       type:         build type: mvn|ant|gradle, default is auto detect.\n");
    print("       diffdirname:  diff build save directory, default:build.diff.\n");
    print("       tag4cmpto:    source code compare to, if not defined, use master or trunk config in repo config.\n");
    print("       startrev:     start revision.\n");
    print("       endrev:       end revision.\n");
    print("       srcpaths:     source code paths: example: 'src,*/src'\n");
    print("       testsrcpaths: test source code paths: example: 'src/test'\n");
    print("       websrcpath:   web content source path, default:src/main/webapp\n");
    print("       webdistpath:  web distribute path, default:WebContent\n");
    print("       cmpoutpath:   compile output path: example: 'target/webapp/WEB-INF/classes'\n");
    print("       args:         arguments for ant|mvn|gradle, default is blank.\n");

    exit(1);
}

sub main {
    my ( $ishelp, $subSysPath, $startPath, $lang, $version, $jdk, $nodejs, $buildType, $args, $isVerbose, $isUpdate );
    my $pname = $FindBin::Script;

    my $forceCompile;
    my $makeToolVer = '';
    my $diffDirName = 'build.diff';
    my $tag4CmpTo   = '';
    my $startRev    = '';
    my $endRev;
    my $srcPaths     = '';
    my $testSrcPaths = 'src/test';
    my $webSrcPath   = 'src/main/webapp';
    my $webDistPath  = 'WebContent';
    my $cmpOutPath   = '';

    Utils::setEnv();

    GetOptions(
        'h|help'         => \$ishelp,
        'v|verbose'      => \$isVerbose,
        'U|update'       => \$isUpdate,
        'tag4cmpto:s'    => \$tag4CmpTo,
        'startrev:s'     => \$startRev,
        'endrev:s'       => \$endRev,
        'diffdirname:s'  => \$diffDirName,
        'subsyspath:s'   => \$subSysPath,
        'startpath:s'    => \$startPath,
        'srcpaths:s'     => \$srcPaths,
        'testsrcpaths:s' => \$testSrcPaths,
        'websrcpath:s'   => \$webSrcPath,
        'webdistpath:s'  => \$webDistPath,
        'cmpoutpath:s'   => \$cmpOutPath,
        'lang:s'         => \$lang,
        'jdk:s'          => \$jdk,
        'forcecompile'   => \$forceCompile,
        'nodejs:s'       => \$nodejs,
        'type:s'         => \$buildType,
        'args=s'         => \$args,
        '<>'             => sub { my $item = shift(@_); $version = $item; }
    );

    usage() if ( not defined($subSysPath) or not defined($version) );

    print("INFO: Begin to compile project and get the patch...\n");

    my $subSysInfo = SubSysInfo::parse( $subSysPath, $version );

    my $sysRoot       = $ENV{TECHSURE_HOME};
    my $deploysysHome = Cwd::fast_abs_path("$FindBin::Bin/..");

    if ( defined $jdk ) {
        if ( -d "$sysRoot/serverware/jdk$jdk" ) {
            $jdk = "$sysRoot/serverware/jdk$jdk";
        }
        elsif ( -d "$sysRoot/serverware/$jdk" ) {
            $jdk = "$sysRoot/serverware/$jdk";
        }
        else {
            print("jdk $jdk is not supported\n");
            exit(-1);
        }
    }
    else {
        $jdk = "$sysRoot/serverware/jdk1.8";
    }

    if ( defined($lang) ) {
        $ENV{LANG}   = $lang;
        $ENV{LC_ALL} = $lang;
    }
    $ENV{CLASSPATH} = '';

    my $versionsDir = $subSysInfo->{versdir};
    my $verDir      = $subSysInfo->{verdir};
    my $subSysDir   = $subSysInfo->{subsysrealpath};
    my $appbuildDir = $subSysInfo->{buildsrc};
    my $prjDir      = $subSysInfo->{prjsrc};

    my $cwd = getcwd();
    chdir($prjDir);

    my $optError = 0;

    #去掉webSrcPath后面的斜杠，如果有的话
    $webSrcPath =~ s/\/+$//;

    #支持通配符对所有的目录定义进行展开
    my @allSrcPaths = ();
    foreach my $aPath ( split( /\s*,\s*/, $srcPaths ) ) {
        foreach my $bPath ( glob($aPath) ) {
            $bPath =~ s/\/$//;
            if ( -d $bPath ) {
                push( @allSrcPaths, $bPath );
            }
            else {
                $optError = 1;
                print("ERROR: $aPath($bPath) is not a directory.\n");
            }
        }
    }

    my @excludeDirs = ();
    foreach my $aPath ( split( /\s*,\s*/, $testSrcPaths ) ) {
        foreach my $bPath ( glob($aPath) ) {
            $bPath =~ s/\/$//;
            if ( -d $bPath ) {
                push( @excludeDirs, $bPath );
            }
            else {
                $optError = 1;
                print("ERROR: $aPath($bPath) is not a directory.\n");
            }
        }
    }

    chdir($cwd);
    if ( $optError == 1 ) {
        exit(-1);
    }

    my $opUser     = $ENV{OPUSER};
    my $prjLock    = RUNLock->new("$prjDir.lock");
    my $preLockMsg = $prjLock->tryLock("$opUser running build");

    if ( not defined($preLockMsg) ) {

        my $appbuildLock = RUNLock->new("$appbuildDir.lock");
        $appbuildLock->lock();
        rmtree("$appbuildDir/app") if ( -e "$appbuildDir/app" );
        rmtree("$appbuildDir/db")  if ( -e "$appbuildDir/db" );
        rmtree("$appbuildDir/res") if ( -e "$appbuildDir/res" );
        $appbuildLock->release();

        my $isFail = 0;
        my $logger = Logger->new("$deploysysHome/logs");

        if ( $isFail eq 0 ) {
            my $opts = {
                subSysPath  => $subSysPath,
                version     => $version,
                startPath   => $startPath,
                versionsDir => $versionsDir,
                buildType   => $buildType,
                args        => $args,
                isUpdate    => $isUpdate,
                isVerbose   => $isVerbose,
                jdk         => $jdk,
                logger      => $logger,
                nodejs      => $nodejs,
                prjDir      => $prjDir,
                makeToolVer => $makeToolVer
            };

            #全量编译, 目的是为了生成增量编译可能需要的class，不管成功失败，如果增量编译缺少了依赖的class，自然会失败
            #$isFail = compile($opts);

            #if ( $isFail == 0 ) {
            my $diffDir = "$prjDir/$diffDirName";
            rmtree($diffDir);
            my $patchDir = "$diffDir/patch";
            if ( not -e $patchDir ) {
                mkpath("$patchDir");
            }

            my $verGet = VerGet->new( $subSysInfo, $version, 1 );

            #如果没有定义$tag4CmpTo和$startRev则获取getver记录的revision的start和end
            if ( $tag4CmpTo eq '' and $startRev eq '' ) {
                ( $startRev, $endRev ) = $verGet->getVerRevRange();
            }

            eval {
                #通过代码仓库比较获取差异文件存放到目录$diffDir
                my $getDiffStatus = $verGet->getBuildDiff( $tag4CmpTo, $startRev, $endRev, $prjDir, "$diffDir/tmp", \@excludeDirs, $isVerbose );
                if ( $getDiffStatus ne 1 ) {
                    Utils::setErrFlag();
                    die("ERROR:$pname $subSysPath $version get diff failed.\n");
                }

                #全量编译, 目的是为了生成增量编译可能需要的class，不管成功失败，如果增量编译缺少了依赖的class，自然会失败
                if ( defined($forceCompile) ) {
                    print("INFO: Force to compile, begin to compile...\n");
                    $isFail = compile($opts);
                    if ( $isFail != 0 ) {
                        return $isFail;
                    }
                }
                elsif ( ifDiffHasJava("$diffDir/tmp/diff-list.txt") ) {
                    print("INFO: Java files modified, begin to compile...\n");
                    $isFail = compile($opts);
                    if ( $isFail != 0 ) {
                        return $isFail;
                    }
                }

                print("INFO: begin to make patch in $diffDir for this build.\n");
                makePatch( $prjDir, $diffDir, \@allSrcPaths, $webSrcPath, $webDistPath, $cmpOutPath );
                print("INFO: make patche complete.\n");

                #生成del文件的shell, 用于发布时可以使用
                my $fd = IO::File->new("<$diffDir/tmp/diff-del-list.txt");
                if ( defined($fd) ) {
                    my $delShellFd = IO::File->new(">$diffDir/diff-del-list.sh");
                    if ( defined($delShellFd) ) {
                        my $line;
                        while ( $line = $fd->getline() ) {
                            chomp($line);

                            my $destRelPath;
                            if ( $destRelPath = isSrc( \@allSrcPaths, $line ) ) {
                                $line = "$cmpOutPath/$destRelPath";
                            }
                            if ( $destRelPath = isWebSrc( $webSrcPath, $line ) ) {
                                if ( $destRelPath =~ /\.java/ ) {
                                    $destRelPath =~ s/\.java//;
                                    if ( not print $delShellFd ("if [ -f '$destRelPath.class' ]; then rm -f '$destRelPath.class'; rm -f '$destRelPath\$*.class' 2>/dev/null; fi\n") ) {
                                        die("ERROR: write to file $diffDir/diff-del-list.sh failed:$!\n");
                                    }
                                }
                                else {
                                    if ( not print $delShellFd ("if [ -f '$destRelPath' ]; then rm -f $destRelPath; fi\n") ) {
                                        die("ERROR: write to file $diffDir/diff-del-list.sh failed:$!\n");
                                    }
                                }
                            }
                        }
                        print $delShellFd ("\n");
                        $delShellFd->close();
                    }
                    else {
                        die("ERROR: open file $diffDir/diff-del-list.sh failed:$!\n");
                    }

                    $fd->seek( 0, 0 );
                    my $delCmdFd = IO::File->new(">$diffDir/diff-del-list.cmd");
                    if ( defined($delCmdFd) ) {
                        my $line;
                        while ( $line = $fd->getline() ) {
                            chomp($line);

                            my $destRelPath;
                            if ( $destRelPath = isSrc( \@allSrcPaths, $line ) ) {
                                $line = "$cmpOutPath/$destRelPath";
                            }
                            if ( $destRelPath = isWebSrc( $webSrcPath, $line ) ) {
                                if ( $destRelPath =~ /\.java/ ) {
                                    $destRelPath =~ s/\.java//;
                                    if ( not print $delCmdFd (qq{if exist "$destRelPath.class" (del /F "$destRelPath.class" && del /F "$destRelPath\$*" 2>nul )\n}) ) {
                                        die("ERROR: write to file $diffDir/diff-del-list.cmd failed:$!\n");
                                    }
                                }
                                else {
                                    if ( not print $delCmdFd (qq{if exist "$destRelPath" (del /F "$destRelPath")\n}) ) {
                                        die("ERROR: write to file $diffDir/diff-del-list.cmd failed:$!\n");
                                    }
                                }
                            }
                        }
                        print $delCmdFd ("\n");
                        $delCmdFd->close();
                    }
                    else {
                        die("ERROR: open file $diffDir/diff-del-list.cmd failed:$!\n");
                    }

                    $fd->close();
                }
            };

            if ($@) {
                $isFail = 1;
                my $msg = $@;
                $msg =~ s/ at .*?$//;
                print($msg);
                Utils::setErrFlag();
            }

            #}
        }

        if ( $isFail eq 0 ) {
            print("FINEST:build $subSysPath $version success.\n");
        }
        else {
            Utils::setErrFlag();
            print("ERROR:build $subSysPath $version failed.\n");
        }

        $logger->close();
    }
    else {
        print("INFO:$pname is in progress, $preLockMsg.\n");

        my $msg = $prjLock->lock("$opUser running build");

        if ( $msg ne 'success' ) {
            Utils::setErrFlag();
        }
        print("INFO: build $subSysPath $version complete.\n");
    }

    if ( Utils::getErrFlag() eq 0 ) {
        $prjLock->release('success');
    }
    else {
        $prjLock->release('failed');
    }

    Utils::exitWithFlag();
}

sub compile {
    my ($opts)      = @_;
    my $subSysPath  = $opts->{subSysPath};
    my $version     = $opts->{version};
    my $startPath   = $opts->{startPath};
    my $versionsDir = $opts->{versionsDir};
    my $buildType   = $opts->{buildType};
    my $codePath    = $opts->{prjDir};
    my $args        = $opts->{args};
    my $isUpdate    = $opts->{isUpdate};
    my $isVerbose   = $opts->{isVerbose};
    my $jdk         = $opts->{jdk};
    my $logger      = $opts->{logger};
    my $nodejs      = $opts->{nodejs};
    my $prjDir      = $opts->{prjDir};
    my $makeToolVer = $opts->{makeToolVer};

    if ( defined($startPath) and $startPath ne '' ) {
        $codePath = "$codePath/$startPath";
        if ( not -d $codePath ) {
            print("ERROR: start path:$startPath($codePath) not exists.\n");
            exit(-1);
        }
    }

    my $isFail = 0;
    my $buildSuccess;
    my @codePaths;

    if ( defined($startPath) and $startPath ne '' and defined($buildType) and $buildType ne '' ) {
        print("INFO: start path and build type defined, use $buildType to build $startPath under $prjDir.\n");
        @codePaths = ($codePath);
    }
    else {
        @codePaths = Utils::getPrjRoots($codePath);
    }

    my $aCodePath;
    foreach $aCodePath (@codePaths) {
        if ( not defined($buildType) ) {
            if ( -e "$aCodePath/build.xml" ) {
                $buildType = 'ant';
            }
            elsif ( -e "$aCodePath/pom.xml" ) {
                $buildType = 'mvn';
            }
            elsif ( -e "$aCodePath/build.gradle" ) {
                $buildType = 'gradle';
            }
            elsif ( -e "$aCodePath/package.json" ) {
                $buildType = 'npm';
            }
        }
        else {
            if ( $buildType =~ /^(.*?)([\d\.\-\_]+)$/ ) {
                $buildType   = $1;
                $makeToolVer = $2;
            }
            if ( $buildType eq 'maven' ) {
                $buildType = 'mvn';
            }
            elsif ( $buildType eq 'nodejs' ) {
                $buildType = 'npm';
            }
        }

        my %opt = (
            prjDir      => $aCodePath,
            versDir     => $versionsDir,
            version     => $version,
            jdk         => $jdk,
            args        => $args,
            isVerbose   => $isVerbose,
            isUpdate    => $isUpdate,
            nodejs      => $nodejs,
            makeToolVer => $makeToolVer
        );

        if ( $buildType eq 'ant' ) {

            #$buildSuccess = ANTbuild::build( $aCodePath, $versionsDir, $version, $jdk, $args, $isVerbose );
            $buildSuccess = ANTbuild::build(%opt);
        }
        elsif ( $buildType eq 'mvn' ) {

            #$buildSuccess = MVNbuild::build( $aCodePath, $versionsDir, $version, $jdk, $args, $isVerbose, $isUpdate );
            $buildSuccess = MVNbuild::build(%opt);
        }
        elsif ( $buildType eq 'gradle' ) {

            #$buildSuccess = BuildGradle::build( $aCodePath, $versionsDir, $version, $jdk, $args, $isVerbose );
            $buildSuccess = BuildGradle::build(%opt);
        }
        elsif ( $buildType eq 'npm' ) {

            #$buildSuccess = NPMbuild::build( $aCodePath, $versionsDir, $version, $nodejs, $args, $isVerbose );
            $buildSuccess = NPMbuild::build(%opt);
        }
        else {
            print("ERROR: It is not java project, if compile is needed, use slave host to compile.\n");
            $buildSuccess = 0;
        }

        if ( $buildSuccess ne 1 ) {
            $isFail = 1;
            $logger->log( "Build $subSysPath $version with src code path:$aCodePath failed.", "ERROR" );
        }
    }

    if ( $isFail == 0 ) {
        $logger->log( "Build $subSysPath $version success.", "INFO" );
    }
    else {
        $logger->log( "Build $subSysPath $version failed.", "ERROR" );
        Utils::setErrFlag();
    }

    return $isFail;
}

sub isSrc {
    my ( $allSrcPaths, $path ) = @_;

    foreach my $aSrcPath (@$allSrcPaths) {
        if ( $path =~ s/^$aSrcPath// ) {
            $path =~ s/\/$//;
            $path =~ s/^\///;
            return $path;
        }
    }

    return undef;
}

sub isWebSrc {
    my ( $webSrcPath, $path ) = @_;

    if ( $path =~ s/^$webSrcPath\/// ) {
        $path =~ s/\/+$//;
        return $path;
    }

    return undef;
}

sub isCmpOut {
    my ( $cmpOutPath, $path ) = @_;

    if ( $path =~ /^$cmpOutPath/ ) {
        return 1;
    }

    return 0;
}

sub makePatch {
    my ( $prjDir, $diffDir, $allSrcPaths, $webSrcPath, $webDistPath, $cmpOutPath ) = @_;

    my $patchDir       = "$diffDir/patch";
    my $rootPath       = "$diffDir/tmp";
    my $updateListFile = "$diffDir/patch-files-list.txt";

    chdir($rootPath);

    my $updateListFH = IO::File->new(">$updateListFile");

    if ( not defined($updateListFH) ) {
        die("ERROR:Create $updateListFile failed.\n");
    }

    my $patchFileCount = 0;

    my $ignoreFileNames = { '.svn', '.git', '.svnignore', '.gitignore', '.classpath', '.project', '.DS_Store' };

    find(
        {
            wanted => sub {
                my $filePath = substr( $File::Find::name, 2 );
                my $fileDir  = substr( $File::Find::dir,  2 );

                my $file = $_;
                if ( defined( $ignoreFileNames->{$file} ) or $filePath =~ /^\./ ) {
                    $File::Find::prune = 1;
                    return;
                }

                if ( -f $file ) {
                    my $srcFile;
                    my $destFile;
                    my $destRelPath;    #相对于代码路径的字路径
                    if ( $destRelPath = isSrc( $allSrcPaths, $filePath ) ) {

                        #如果是代码文件，则抽取对应的class文件
                        if ( $destRelPath =~ s/\.java$// ) {
                            my $srcPathPrefix = "$prjDir/$cmpOutPath/$destRelPath";

                            if ( not -f "$srcPathPrefix.class" ) {

                                #如果文件不在编译输出目录中，则检查跟java同级目录是否存在此文件
                                my $classPath = $filePath;
                                $classPath =~ s/\.java$//;
                                $srcPathPrefix = "$prjDir/$classPath";
                                if ( not -f "$srcPathPrefix.class" ) {

                                    #如果跟java同级目录也不存在class则报错
                                    die("ERROR: can not find class file for java file:$filePath\n");
                                }
                            }

                            #拷贝主class文件
                            $srcFile  = "$srcPathPrefix.class";
                            $destFile = "$patchDir/$cmpOutPath/$destRelPath.class";
                            my $destDir = dirname($destFile);

                            if ( not -d $destDir ) {
                                mkpath($destDir);
                            }

                            copy( $srcFile, $destFile ) || die("ERROR: copy class $srcFile to $destFile failed, $!");
                            print $updateListFH ("$cmpOutPath/$destRelPath.class\n") || die("ERROR: write $cmpOutPath/$destRelPath.class to file:$updateListFile failed, $!");

                            #拷贝同一个主类下的内嵌类
                            foreach my $aClassPath ( glob("$srcPathPrefix\$*.class") ) {
                                $srcFile  = $aClassPath;
                                $destFile = "$destDir/";
                                copy( $srcFile, $destFile ) || die("ERROR: copy class $srcFile to $destFile failed:$!");
                                my $innerClass = dirname($destRelPath) + '/' + basename($aClassPath);
                                print $updateListFH ("$cmpOutPath/$innerClass\n") || die("ERROR: write $cmpOutPath/$innerClass.class to file:$updateListFile failed, $!");
                            }
                        }
                        elsif ( $destRelPath !~ /\.class$/ ) {

                            #如果源代码目录中文件不是java以及class文件则拷贝到补丁目录的编译输出目录中
                            $destFile = "$patchDir/$cmpOutPath/$destRelPath";
                            my $destDir = dirname($destFile);
                            if ( not -d $destDir ) {
                                mkpath($destDir);
                            }

                            copy( $file, $destFile ) || die("ERROR: copy file $file to $destFile failed:$!");
                            print $updateListFH ("$cmpOutPath/$destRelPath\n") || die("ERROR: write $cmpOutPath/$destRelPath to file:$updateListFile failed, $!");
                        }
                    }
                    elsif ( $destRelPath = isWebSrc( $webSrcPath, $filePath ) ) {
                        $destFile = "$patchDir/$webDistPath/$destRelPath";
                        my $destDir = dirname($destFile);
                        if ( not -d $destDir ) {
                            mkpath($destDir);
                        }
                        if ( not -f $destFile ) {
                            print $updateListFH ("$webDistPath/$destRelPath\n") || die("ERROR: write $webDistPath/$destRelPath to file:$updateListFile failed, $!");
                        }
                        copy( $file, $destFile ) || die("ERROR: copy web $file to $destFile failed:$!");
                    }
                    else {
                        #如果不是编译输出目录则直接拷贝
                        if ( $filePath eq 'diff-del-list.txt' or $filePath eq 'diff-list.txt' ) {
                            return;
                        }

                        #如果是工程根目录下的文件直接略过
                        if ( $file eq $filePath and -f $file ) {
                            return;
                        }

                        $destFile = "$patchDir/$filePath";
                        my $destDir = dirname($destFile);
                        if ( not -d $destDir ) {
                            mkpath($destDir);
                        }
                        if ( not -f $destFile ) {    #这个判断，防止通过java文件拷贝到目标的class被checkin到仓库的编译输出目录的class覆盖
                            copy( $file, $destFile ) || die("ERROR: copy $srcFile to $destFile failed:$!");
                            print $updateListFH ("$filePath\n") || die("ERROR: write $filePath to file:$updateListFile failed, $!");
                        }
                    }
                }
                elsif ( -d $file ) {
                    my $destPath = '';
                    my $destRelPath;
                    if ( defined( $destRelPath = isSrc( $allSrcPaths, $filePath ) ) ) {

                        #如果是源代码下的字目录，则在目标编译输出目录下创建该目录
                        $destPath = "$patchDir/$cmpOutPath/$destRelPath";
                    }
                    elsif ( defined( $destRelPath = isWebSrc( $webSrcPath, $filePath ) ) ) {
                        $destPath = "$patchDir/$webDistPath/$destRelPath";
                    }

                    if ( $destPath ne '' and not -e $destPath ) {
                        mkpath($destPath) || die("ERROR: create path $destPath failed:$!\n");
                    }
                }
            },
            follow => 0
        },
        '.'
    );

    if ( defined($updateListFH) ) {
        $updateListFH->close();
    }

    if ( not -e "$patchDir/$webDistPath" ) {
        mkdir("$patchDir/$webDistPath");
    }
}

sub ifDiffHasJava {
    my ($diffFileList) = @_;

    my $hasJava = 0;
    my $fh = IO::File->new( $diffFileList, 'r' );
    if ( defined($fh) ) {
        my $line;
        while ( $line = $fh->getline() ) {
            if ( $line =~ /\.java$/ ) {
                $hasJava = 1;
                last;
            }
        }
        $fh->close();
    }
    else {
        die("ERROR: Open file $diffFileList failed, $!\n");
    }

    return $hasJava;
}

main();

