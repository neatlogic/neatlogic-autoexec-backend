#!/usr/bin/python
# -*- coding:UTF-8 -*-

import os
from ssl import create_default_context
import sys
import traceback
import argparse
import re
import datetime

import AutoExecUtils

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('rest', nargs=argparse.REMAINDER, help="Output key")
    args = parser.parse_args()
    outputKeys = args.rest

    exitCode = 0

    dbclient = None
    outCollection = None
    try:
        (dbclient, db) = AutoExecUtils.getDB()
        outCollection = db['_node_output']
    except Exception as err:
        exitCode = 2
        print("ERROR: Can not connect to database, {}".format(err))

    for outputKey in outputKeys:
        hasOptError = False
        if outputKey == '':
            hasOptError = True
            print("ERROR: Must define output key name by option --outputkey")

        if hasOptError:
            sys.exit(2)

        outputKey = re.sub(r'^#\{', '', outputKey)
        outputKey = re.sub(r'\}$', '', outputKey)
        outputKeyInfo = outputKey.split('.')

        if len(outputKeyInfo) != 3:
            print("ERROR: Malform output key %s." % (outputKey))
            sys.exit(3)

        opId = outputKeyInfo[1]
        varKey = outputKeyInfo[2]

        jobId = os.getenv('AUTOEXEC_JOBID')

        aggDatas = []

        try:
            print("INFO: Try to query output for operation id:%s output:%s." % (opId, varKey))
            for nodeOut in outCollection.find(
                    {
                        'jobId': jobId,
                        'resourceId': {'$ne': 0},
                        'data.%s' % opId: {'$ne': None}
                    },
                    {
                        'host': 1,
                        'port': 1,
                        'data.%s' % opId: 1
                    }).limit(2):

                val = nodeOut['data'].get(opId).get(varKey)
                aggDatas.append(val)

            if len(aggDatas) == 0:
                print("WARN: Can not find any output for:%s." % (outputKey))
            elif len(aggDatas) == 1:
                # Load local output
                pk = {'jobId': jobId, 'resourceId': 0}
                outData = outCollection.find_one(pk, {'_id': False})
                output = {}
                if outData is not None:
                    outData['host'] = 'local'
                    outData['port'] = 0
                    outData['resourceId'] = 0
                    output = outData['data']
                else:
                    outData = {
                        'host': 'local',
                        'port': 0,
                        'resourceId': 0,
                        'createDate': datetime.datetime.utcnow()
                    }
                    outData.update(pk)

                opOut = output.get(opId, {})
                opOut[varKey] = val
                output[opId] = opOut
                outData['data'] = output
                result = outCollection.update_one(pk, {'$set': outData}, upsert=True)
                if result.modified_count == 1:
                    print("FINE: Convert output for:%s to local success." % (outputKey))
                else:
                    print("ERROR: Convert output for:%s to local failed." % (outputKey))
                    exitCode = 1
            else:
                print("ERROR: More than one remote node output found, suggest to use aggoutput.")
                exitCode = 2
        except Exception as err:
            exitCode = 1
            print('ERROR: Convert output for {} to local failed, {}'.format(outputKey, err))

    if dbclient is not None:
        dbclient.close()

    sys.exit(exitCode)
