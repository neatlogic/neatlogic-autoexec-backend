#!/usr/bin/perl
use strict;
use FindBin;

use File::Basename;
use Cwd 'abs_path';
use Getopt::Long;
use File::Temp;
use Digest::MD5 qw(md5 md5_hex);
use JSON qw(to_json from_json);

use SSHRemoteExec;
use SCPExec;
use DeployUtils;

Getopt::Long::Configure("pass_through");

sub usage {
    my $pname = $FindBin::Script;

    print("Usage: $pname [--verbose 0|1]\n");
    print("              [--supass SuPassword] [--eofstr EOFString] [--failstr FailString]\n");
    print("              [--timeout TimeoutSecs] [-o SSHOptions]\n");
    print("              [--destencoding TargetOsEncoding] [--script ScriptJson]\n");
    print("\n");
    print("       --node:         Host node json\n");
    print("       --supass:       su execute user password\n");
    print("       --eofstr:       when command outpute match eofstr, the execute will be terminated\n");
    print("       --failstr:      when command outpute match failstr, the execute will be terminated and return faled\n");
    print("       --timeout:      tiemout for ssh execute\n");
    print("       --o:            ssh options, example: \"SendEnv EXEC_PASSWORD;ForwardX11 yes\"\n");
    print("       --destencoding: Target OS encoding\n");
    print("       --script:       example: '{\"name\":\"t.bat\",\"arguments\":\"\$SYSNAME \$SUBSYSNAME\",\"content\":\"#!/bin/bash\necho helloworld!\n\"}'\n");

    exit(1);
}

sub main {
    my ( $isHelp, $isVerbose, $envPath, $version );
    my ( $node, $destCharset, $supass, $sshOpts, $scriptObj, $eofStr, $failStr, $timeOut );
    my $interpreter = 'sh';
    $isVerbose = 0;
    $scriptObj = '';

    GetOptions(
        'h|help'         => \$isHelp,
        'v|verbose=i'    => \$isVerbose,
        'destencoding:s' => \$destCharset,
        'node=s'         => \$node,
        'supass=s'       => \$supass,
        'eofstr=s'       => \$eofStr,
        'failstr=s'      => \$failStr,
        'timeout=i'      => \$timeOut,
        'o=s'            => \$sshOpts,
        'interpreter=s'  => \$interpreter,
        'script=s'       => \$scriptObj
    );

    usage() if ( defined($isHelp) );
    my $deployUtils = DeployUtils->new();

    my $optionError = 0;

    my $nodeInfo = $deployUtils->getNodeInfo($node);
    if ( not $nodeInfo ) {
        $optionError = 1;
        print("ERROR: Execute node json not defined by environment AUTOEXEC_NODE or option --node\n");
    }

    if ( defined($eofStr) ) {
        if ( $eofStr =~ /^\{([\w-\d]+)\}/ ) {
            $eofStr =~ s/^\{[\w-\d]+\}//;
            $eofStr = Encode::encode( lc($1), Encode::decode( 'utf-8', $eofStr ) );
        }
        elsif ( defined($destCharset) and $destCharset ne '' ) {
            $eofStr = Encode::encode( lc($destCharset), Encode::decode( 'utf-8', $eofStr ) );
        }
    }

    if ( not defined($scriptObj) ) {
        $optionError = 1;
        print("ERROR: must defined script obj with --script option.\n");
    }

    if ( $optionError == 1 ) {
        usage();
    }

    my $scriptJson = from_json($scriptObj);

    my $scriptInterpreter = $interpreter;
    my $scriptContent     = $scriptJson->{content};
    my $arguments         = '';
    foreach my $arg (@ARGV) {
        $arguments = qq{$arguments "$arg"};
    }

    while ( $arguments =~ /(?<!\\)\$(\w+)/g ) {
        my $varName = $1;
        if ( exists( $ENV{$varName} ) ) {
            $arguments =~ s/(?<!\\)\$$varName/$ENV{$varName}/g;
        }
    }

    while ( $arguments =~ /(?<!\\)\$\{(\w+)\}/g ) {
        my $varName = $1;
        if ( exists( $ENV{$varName} ) ) {
            $arguments =~ s/(?<!\\)\$\{$varName\}/$ENV{$varName}/g;
        }
    }

    if ( defined($scriptContent) and $scriptContent ne '' ) {
        my $unHexContent = pack( 'H*', $scriptContent );
        my $hexContent   = unpack( 'H*', $unHexContent );

        if ( $hexContent eq lc($scriptContent) ) {
            $scriptContent = $unHexContent;
        }
    }

    #$scriptName = md5_hex($scriptContent);    # . "$scriptName";

    if ( defined($destCharset) and $destCharset ne '' ) {
        $scriptContent = Encode::encode( lc($destCharset), Encode::decode( 'utf-8', $scriptContent ) );
    }
    my $TMPDIR  = $ENV{AUTOEXEC_HOME} . '/tmp';
    my $tmp     = File::Temp->new( DIR => $TMPDIR, SUFFIX => '' );
    my $tmpPath = $tmp->filename;
    print $tmp ($scriptContent);
    $tmp->flush();

    my $scriptName = basename($tmpPath) . $deployUtils->getScriptExtName($scriptInterpreter);

    my $hasError = 0;

    my $host    = $nodeInfo->{host};
    my $port    = $nodeInfo->{protocolPort};
    my $user    = $nodeInfo->{username};
    my $pass    = $nodeInfo->{password};
    my $insId   = $nodeInfo->{resourceId};
    my $insName = $nodeInfo->{nodeName};

    if ( defined($pass) and $pass ne '' ) {
        $pass = $deployUtils->decryptPwd($pass);
    }

    my $scpExec = new SCPExec(
        host        => $host,
        port        => $port,
        username    => $user,
        password    => $pass,
        source      => $tmpPath,
        destination => "$user\@$host:/tmp/$scriptName",
        verbose     => $isVerbose
    );
    my $rc = $scpExec->exec();

    if ( $rc != 0 ) {
        print("ERROR: Copy scirpt to /tmp/$scriptName failed.\n");
        exit(1);
    }

    my $cmd     = "$scriptInterpreter /tmp/$scriptName $arguments; rc=\$?; rm -f /tmp/$scriptName; exit \$rc";
    my $sshExec = new SSHRemoteExec(
        host       => $host,
        port       => $port,
        username   => $user,
        password   => $pass,
        verbose    => $isVerbose,
        cmd        => $cmd,
        scriptFile => undef,
        eofStr     => $eofStr,
        failStr    => $failStr,
        supassword => $supass,
        timeout    => $timeOut,
        sshOpts    => $sshOpts
    );

    my $ret = $sshExec->exec();
    $hasError = $hasError + $ret;
    if ( $sshExec->{status} eq 'SUCCESS' ) {
        print("FINEST: ssh remote exec success.\n");
    }
    elsif ( $sshExec->{status} eq 'WARN' ) {
        print("WARN: ssh remote exec has warning.\n");
    }
    elsif ( $sshExec->{status} eq 'ERROR' ) {
        $hasError = $hasError + 1;
        print("ERROR: ssh remote exec has error.\n");
    }

    return $hasError;
}

exit main();

