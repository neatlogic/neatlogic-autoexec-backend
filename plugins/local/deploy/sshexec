#!/usr/bin/perl
use strict;
use FindBin;
use JSON;
use File::Basename;
use Cwd 'abs_path';
use Getopt::Long;

use SSHRemoteExec;
use DeployUtils;

Getopt::Long::Configure("pass_through");

sub usage {
    my $pname = $FindBin::Script;

    print("Usage: $pname [--verbose 0|1]\n");
    print("              [--supass SuPassword] [--eofstr EOFString] [--failstr FailString]\n");
    print("              [--timeout TimeoutSecs] [-o SSHOptions] cmd\n");
    print("\n");
    print("       --node:      Host node json\n");
    print("       --supass:    su execute user password\n");
    print("       --eofstr:    when command outpute match eofstr, the execute will be terminated\n");
    print("       --failstr:   when command outpute match failstr, the execute will be terminated and return faled\n");
    print("       --timeout:   tiemout for ssh execute\n");
    print("       --o:         ssh options, example: \"SendEnv EXEC_PASSWORD;ForwardX11 yes\"\n");
    print("       cmd:         command text\n");

    exit(1);
}

sub main {
    my ( $isHelp, $isVerbose );
    my ( $node, $supass, $sshOpts, $cmd, $eofStr, $failStr, $timeOut );

    $isVerbose = 0;

    $cmd = '';

    sub addCmd {
        my $item = shift(@_);
        $cmd = $cmd . ' ' . $item;
    }

    GetOptions(
        'h|help'      => \$isHelp,
        'v|verbose=i' => \$isVerbose,
        'node=s'      => \$node,
        'supass=s'    => \$supass,
        'eofstr=s'    => \$eofStr,
        'failstr=s'   => \$failStr,
        'timeout=i'   => \$timeOut,
        'o=s'         => \$sshOpts,
        '<>'          => \&addCmd
    );

    usage() if ( defined($isHelp) );

    my $optionError = 0;

    my $nodeInfo = {};
    if ( not defined($node) ) {
        $node = $ENV{AUTOEXEC_NODE};
    }

    if ( not defined($node) or $node eq '' ) {
        $optionError = 1;
    }
    else {
        $nodeInfo = from_json($node);
    }

    if ( $cmd eq '' ) {
        $optionError = 1;
        print("ERROR: must instance path with optoin --inspath.\n");
    }

    if ( $optionError == 1 ) {
        usage();
    }

    if ( defined($eofStr) and $eofStr =~ /^\{([\w-\d]+)\}/ ) {
        $eofStr =~ s/^\{[\w-\d]+\}//;
        $eofStr = Encode::encode( lc($1), Encode::decode( 'utf-8', $eofStr ) );
    }

    my $hasError = 0;

    my $host    = $nodeInfo->{host};
    my $port    = $nodeInfo->{protocolPort};
    my $user    = $nodeInfo->{username};
    my $pass    = $nodeInfo->{password};
    my $insId   = $nodeInfo->{resourceId};
    my $insName = $nodeInfo->{nodeName};

    my $deployUtils = DeployUtils->new();

    if ( defined($pass) and $pass ne '' ) {
        if ( $pass =~ s/^\{ENCRYPTED\}// ) {
            $pass = $deployUtils->_rc4_decrypt_hex( $DeployUtils::MY_KEY, $pass );
        }
    }

    my $namePath = $ENV{_DEPLOY_PATH};
    my $idPath   = $ENV{_DEPLOY_ID_PATH};
    if ( defined($namePath) and $namePath ne '' ) {
        $ENV{_INS_ID_PATH} = "$idPath/$insId";
        $ENV{_INS_PATH}    = "$namePath/$insName";
    }

    my $sshExec = new SSHRemoteExec(
        host       => $host,
        port       => $port,
        username   => $user,
        password   => $pass,
        verbose    => $isVerbose,
        cmd        => $cmd,
        scriptFile => undef,
        eofStr     => $eofStr,
        failStr    => $failStr,
        supass     => $supass,
        timeout    => $timeOut,
        sshOpts    => $sshOpts
    );

    my $ret = $sshExec->exec();

    $hasError = $hasError + $ret;

    if ( $sshExec->{status} eq 'SUCCESS' ) {
        print("FINEST: ssh remote exec success.\n");
    }
    elsif ( $sshExec->{status} eq 'WARN' ) {
        print("WARN: ssh remote exec has warning.\n");
    }
    elsif ( $sshExec->{status} eq 'ERROR' ) {
        $hasError = $hasError + 1;
        print("ERROR: ssh remote exec has error.\n");
    }

    return $hasError;
}

exit main();

