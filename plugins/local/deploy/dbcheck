#!/usr/bin/perl

use FindBin;
use lib $FindBin::Bin;
use lib "$FindBin::Bin/../lib/perl-lib/lib/perl5";

use strict;
use Cwd;
use Digest::MD5;
use Getopt::Long;
use JSON;
use SQLFileRunner;

sub usage {
    my $pname = $FindBin::Script;

    print("Usage: $pname [--verbose 0|1] [--envpath EnvPath] [--version VERSION]\n");
    print("       --envpath:      example:SYS-A/MODULE-X/SIT\n");

    exit(1);
}

sub main {
    my $isforce = 0;

    my $envPath;
    my $version;
    my $isHelp     = 0;
    my $isVerbose  = 0;
    my $isRollback = 0;
    my $filter;
    my $index;

    GetOptions(
        'help'        => \$isHelp,
        'v|verbose=i' => \$isVerbose,
        'envpath=s'   => \$envPath,
        'version=s'   => \$version,
        'rollback=i'  => \$isRollback,
        'filter=s'    => \$filter,
        'index=s'     => \$index
    );

    my $hasOptError = 0;

    my $dbNode;
    my $dbNodeJson = $ENV{AUTOEXEC_NODE};
    if ( defined($dbNodeJson) and $dbNodeJson ne '' ) {
        $dbNode = from_json($dbNodeJson);
    }

    if ( not defined($dbNode) ) {
        $hasOptError = 1;
        print("ERROR: Must define db schema with envirment varialble AUTOEXEC_NODE in json string.\n");
    }

    my $phaseName = $ENV{AUTOEXEC_PHASE_NAME};
    if ( not defined($phaseName) or $phaseName eq '' ) {
        $hasOptError = 1;
        print("ERROR: Must define phase name with envirment varialble AUTOEXEC_PHASE_NAME.\n");
    }

    my $execUser = $ENV{AUTOEXEC_USER};
    if ( not defined($execUser) or $execUser eq '' ) {
        $ENV{AUTOEXEC_USER} = 'anonymous';
    }

    if ( not defined($dbNode) ) {
        $hasOptError = 1;
        print("ERROR: Must define db schema with envirment varialble AUTOEXEC_NODE in json string.\n");
    }

    if ( $hasOptError == 1 ) {
        usage();
    }

    my $jobPath = $ENV{AUTOEXEC_WORK_PATH};
    if ( not defined($jobPath) or $jobPath eq '' ) {
        $jobPath = getcwd();
    }

    my $buildEnv  = DeployUtils->deployInit( $envPath, $version );
    my $buildConf = $buildEnv->{DEPLOY_CONF};
    my $dirInfo   = DeployUtils->getDataDirStruct($buildEnv);

    #sqlfile, log, status
    #jobpath/
    #|-- file
    #|   |-- 1.sql
    #|   `-- 2.sql
    #|-- log
    #|   `-- phase-run
    #|       `-- 192.168.0.26-3306-bsm
    #|           |-- 2.sql.hislog
    #|           |   |-- 20210625-163515-failed-anonymous.txt
    #|           |   |-- 20210625-163607-failed-anonymous.txt
    #|           |   `-- 20210625-164543-failed-anonymous.txt
    #|           `-- 2.sql.txt
    #|-- sqlfile
    #|   `-- phase-run
    #|       `-- 2.sql
    #`-- status
    #    `-- phase-run
    #            `-- 192.168.0.26-3306-bsm
    #                        `-- 2.sql.txt

    my $distPath     = $dirInfo->{distribute};
    my $sqlFileDir   = "$distPath/db";
    my $logFileDir   = "$jobPath/log/$phaseName";
    my $sqlStatusDir = "$distPath/db.status";

    my $batchUtils = SQLBatchUtils->new(
        sqlExtNames => [ 'sql', 'prc', 'pck', 'pkg', 'pkgh', 'pkgb' ],
        buildEnv    => $buildEnv,
        dirInfo     => $dirInfo
    );

    my $sqlFiles = [];
    if ( defined($index) and $index ne '' ) {
        $sqlFiles = $batchUtils->getSqlFilePathByIdx( $index, $filter, $isRollback );
    }
    else {
        $sqlFiles = $batchUtils->getSqlFilePath( $filter, $isRollback );
    }

    my $dbSchemasMap = {};
    my $dbConf       = ServerAdapter->getDBConf($buildEnv);
    while ( my ( $dbSchema, $conf ) = each(%$dbConf) ) {
        my $dbInfo = DBInfo->new( $conf->{node}, $conf->{args} );
        $dbSchemasMap->{ lc($dbSchema) } = $dbInfo;
    }

    my $sqlFileRunner = SQLFileRunner->new(
        dbSchemasMap => $dbSchemasMap,
        nodeInfo     => { nodeId => 0 },
        sqlFileDir   => $sqlFileDir,
        sqlStatusDir => $sqlStatusDir,
        logFileDir   => $logFileDir,
        sqlFiles     => $sqlFiles
    );

    $sqlFileRunner->checkSqlFiles();
}

main();

