#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
 Copyright © 2017 TechSure<http://www.techsure.com.cn/>
"""
import os
import sys
import traceback
import threading

import io
import shutil
import initenv
import platform
import argparse
import time
import signal
import re
import json
import glob
import logging
from logging.handlers import RotatingFileHandler

import JobRunner
import Utils
import VContext
import Context
import ServerAdapter
import OutputStore


class ConsoleLog(io.TextIOWrapper):
    def write(self, text, encoding=sys.getdefaultencoding()):
        if isinstance(text, bytes):
            text = text.decode(encoding)

        if text == "\n":
            return

        isTTY = sys.__stdout__.isatty()

        for line in text.splitlines(True):
            if isTTY:
                sys.__stdout__.write(line)

            super().write(Utils.getTimeStr() + line)
            super().flush()


def threadDump(signum, frame):
    id2name = {}
    for th in threading.enumerate():
        id2name[th.ident] = th.name

        code = []
        for threadId, stack in sys._current_frames().items():
            subcode = []
            subcode.append("\n# Thread: %s(%d)" % (id2name.get(threadId, ""), threadId))
            for filename, lineno, name, line in traceback.extract_stack(stack):
                if line:
                    subcode.insert(1, "  at %s(%s, line %d, in %s)\n" % (line.strip(), filename, lineno, name))
                else:
                    subcode.insert(1, "  at (%s, line %d, in %s)\n" % (filename, lineno, name))
            code.append("".join(subcode))
        print("\n==Thread dump begin=====\n" + "".join(code) + "\n==Thread dump end=====\n")


def _getLogSubPath(jobId):
    jobIdStr = str(jobId)
    jobIdLen = len(jobIdStr)
    subPath = [jobIdStr[i:i+3] for i in range(0, jobIdLen, 3)]
    return '/'.join(subPath)


def registerTools(serverAdapter, pluginsPath, opType):
    os.chdir(pluginsPath + '/' + opType)
    with os.scandir() as iterator:
        for entry in iterator:
            if entry.is_dir():
                for descPath in glob.glob(entry.name + '/' + '*.json'):
                    toolSubName = os.path.basename(descPath)[:-5]
                    opName = entry.name + '/' + toolSubName
                    if toolSubName.startswith(entry.name) or os.path.isfile(opName):
                        print("INFO: Begin to register tool:{} {}...\n".format(opType, opName))
                        descFile = open(descPath, 'r')
                        pluginObj = json.loads(descFile.read())
                        pluginObj['opName'] = opName
                        # 后台的配置可能会使用local、localremote、remote的类型标记，转换为后台使用的类别名称runner、runner_target、target
                        if opType == 'local':
                            if 'opType' in pluginObj:
                                if pluginObj['opType'] == 'localremote':
                                    pluginObj['opType'] = 'runner_target'
                                elif pluginObj['opType'] == 'local':
                                    pluginObj['opType'] = 'runner'
                            else:
                                pluginObj['opType'] = 'runner'

                        if opType == 'remote':
                            pluginObj['opType'] = 'target'

                        try:
                            retObj = serverAdapter.registerTool(pluginObj)
                            if 'Status' in retObj and retObj['Status'] == 'OK':
                                print("INFO: Register tool:{} {} success.\n".format(opType, opName))
                        except Exception as ex:
                            print("ERROR: Register tool:{} {} failed, {}\n".format(opType, opName, ex))


def findJobProcess(jobId):
    autoexecPid = 0
    with os.scandir('/proc') as it:
        for entry in it:
            if not entry.name.startswith('.') and entry.is_dir():
                if re.match('^\d+$', entry.name):
                    pid = entry.name
                    try:
                        cf = open(entry.path + '/comm')
                        comm = cf.read()
                        comm = comm.strip()
                        if comm == 'autoexec':
                            f = open(entry.path + '/cmdline')
                            content = f.read()
                            if content.index(jobId) > 0:
                                autoexecPid = int(pid)
                                break
                    except:
                        pass
    return autoexecPid


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action='store_true', default=False, help="Automation Runner")
    parser.add_argument('--jobid', '-j', default='0', help='Job id for this execution')
    parser.add_argument('--execuser', '-u', default='anonymous',  help='Operator')
    parser.add_argument('--paramsfile', '-p', default='', help='Params file path for this execution')
    parser.add_argument('--nodesfile', '-n', default='', help='Nodes file path for this execution')
    parser.add_argument('--force', '-f', default=False, action='store_true', help='Force to run all nodes regardless the node status')
    parser.add_argument('--firstfire', '-i', default=False, action='store_true', help='the first phase fired, create new log file')
    parser.add_argument('--abort', '-k', default=False, action='store_true', help='abort the job')
    parser.add_argument('--pause', '-s', default=False, action='store_true', help='puase the job')
    parser.add_argument('--register', '-r', default='', help='register all tools to tenent')
    parser.add_argument('--cleanstatus', '-c', default=False, action='store_true', help='clean all stats of job')
    parser.add_argument('--devmode', '-d', default=False, action='store_true', help='develope test in command line')
    parser.add_argument('--nofirenext', default=False, action='store_true', help='do not fire next job phase')
    parser.add_argument('--passthroughenv', default='{}', help='Additinal json parameter while callback to console')

    os.environ['TERM'] = 'dumb'
    args = parser.parse_args()
    os.environ['AUTOEXEC_PID'] = str(os.getpid())
    os.environ['AUTOEXEC_USER'] = args.execuser

    binPaths = os.path.split(os.path.realpath(__file__))
    homePath = os.path.realpath(binPaths[0]+'/..')
    progName = binPaths[1]

    if args.cleanstatus:
        passThroughEnv = json.loads(args.passthroughenv)
        vContext = VContext.VContext(args.jobid, passThroughEnv)
        vContext.initDB(1)

        outputStore = OutputStore.OutputStore(vContext, None, None)
        outputStore.removeJobStatus()

        statusPath = '{}/status'.format(vContext.runPath)
        if os.path.exists(statusPath):
            shutil.rmtree(statusPath)

    elif args.register:
        pluginsPath = homePath + '/plugins'

        # 因为serverAdapter是从context中获取tenant，所以需要构造虚拟的context
        passThroughEnv = json.loads(args.passthroughenv)
        vContext = VContext.VContext(0, passThroughEnv)
        vContext.tenant = args.register
        serverAdapter = ServerAdapter.ServerAdapter(vContext)

        registerTools(serverAdapter, pluginsPath, 'local')
        registerTools(serverAdapter, pluginsPath, 'remote')
    elif args.pause:
        passThroughEnv = json.loads(args.passthroughenv)
        vContext = VContext.VContext(args.jobid, passThroughEnv)
        serverAdapter = ServerAdapter.ServerAdapter(vContext)

        ret = 0
        print("INFO: try to pause job:{}\n".format(args.jobid))
        autoexecIsPaused = False
        autoexecPid = findJobProcess(args.jobid)

        if autoexecPid != 0:
            try:
                print("INFO: Try to pause process {}...\n".format(autoexecPid))
                os.kill(autoexecPid, signal.SIGUSR1)

                for i in range(1800):
                    os.kill(autoexecPid, 0)
                    time.sleep(3)
                    os.kill(autoexecPid, signal.SIGUSR1)
            except:
                autoexecIsPaused = True
                serverAdapter.jobPaused()
                print("INFO: Process {} puased.\n".format(autoexecPid))

            if not autoexecIsPaused:
                ret = 1
                print("WARN: Kill process {} failed.\n".format(autoexecPid))
        else:
            ret = 2
            serverAdapter.jobPaused()
            print("INFO: Can not find job {} process.\n".format(args.jobid))
        sys.exit(ret)
    elif args.abort:
        passThroughEnv = json.loads(args.passthroughenv)
        vContext = VContext.VContext(args.jobid, passThroughEnv)
        serverAdapter = ServerAdapter.ServerAdapter(vContext)

        ret = 0
        print("INFO: try to kill job:{}\n".format(args.jobid))
        autoexecIsKilled = False
        autoexecPid = findJobProcess(args.jobid)

        if autoexecPid != 0:
            try:
                print("INFO: Try to stop process {}...\n".format(autoexecPid))
                for i in range(10):
                    os.kill(autoexecPid, signal.SIGTERM)
                    time.sleep(1)

                os.kill(autoexecPid, signal.SIGKILL)
                time.sleep(1)
                os.kill(autoexecPid, 0)
            except:
                autoexecIsKilled = True
                serverAdapter.jobKilled()
                print("INFO: Process {} killed.\n".format(autoexecPid))

            if not autoexecIsKilled:
                ret = 1
                print("WARN: Kill process {} failed.\n".format(autoexecPid))
        else:
            ret = 2
            serverAdapter.jobKilled()
            print("INFO: Can not find job {} process.\n".format(args.jobid))
        sys.exit(ret)
    else:
        # 初始化运行context
        dataPath = homePath + '/data'
        context = Context.Context(args.jobid, paramsFile=args.paramsfile, isForce=args.force, devMode=args.devmode, dataPath=dataPath, noFireNext=args.nofirenext)
        os.environ['AUTOEXEC_JOBID'] = context.jobId
        os.environ['AUTOEXEC_WORK_PATH'] = context.runPath

        # 初始化console日志文件
        logDir = context.runPath + '/log'
        consoleLogPath = logDir + '/console.txt'

        consoleLogFile = None
        if args.firstfire:
            # 作业的第一个阶段执行，需要创建新的console 日志文件
            if os.path.exists(consoleLogPath):
                os.unlink(consoleLogPath)

            consoleLogFile = open(consoleLogPath, 'w').detach()

            consoleHisLogDir = logDir + '/console.hislog'
            if not os.path.isdir(consoleHisLogDir):
                os.mkdir(consoleHisLogDir)
            consoleHisLogPath = '{}/{}.{}.txt'.format(consoleHisLogDir, time.strftime('%Y%m%d-%H%M%S'), args.execuser)
            os.link(consoleLogPath, consoleHisLogPath)
        else:
            # 后续阶段执行，不需要新建文件，在原来的console文件中追加日志
            consoleLogFile = open(consoleLogPath, 'a').detach()

        # console输出重定向到console log文件
        sys.stdout = ConsoleLog(consoleLogFile)
        sys.stderr = ConsoleLog(consoleLogFile)

        # 初始化全局Logger
        loggingLevel = context.config.get(progName, 'logging.level')

        logFilePath = '{}/logs/{}.log'.format(homePath, progName)
        logHandler = RotatingFileHandler(logFilePath, maxBytes=10*1024*1024, backupCount=5)
        logger = logging.getLogger('')
        logger.setLevel(loggingLevel)
        formatter = logging.Formatter('%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)-8s %(message)s')
        logHandler.setFormatter(formatter)
        logger.addHandler(logHandler)

        signal.signal(signal.SIGQUIT, threadDump)

        # 开始运行作业
        print("INFO: JobId:{} start...\n".format(args.jobid))
        runner = JobRunner.JobRunner(context, nodesFile=args.nodesfile)

        # 信号处理函数，pause runner
        def pauseHandler(signum, frame):
            runner.pause()

        # 信号处理函数，kill runner
        def killHandler(signum, frame):
            runner.kill()

        # 注册TERM、INT的信号，当kill是响应信号进行退出处理，kill是另外独立的autoexec进程，仅仅发送一个信号
        signal.signal(signal.SIGTERM, killHandler)
        signal.signal(signal.SIGINT, killHandler)

        if platform.system() != 'Windows':
            signal.signal(signal.SIGHUP, killHandler)
            signal.signal(signal.SIGUSR1, pauseHandler)

        sys.exit(runner.execute())
