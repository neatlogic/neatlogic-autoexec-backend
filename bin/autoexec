#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
 Copyright © 2017 TechSure<http://www.techsure.com.cn/>
"""
import os
import sys
binPaths = os.path.split(os.path.realpath(__file__))
libPath = os.path.realpath(binPaths[0]+'/../lib')
sys.path.append(libPath)

import time
import re
import signal
import json
import argparse
import logging
from logging.handlers import RotatingFileHandler

import Context
import Operation
import TaskExecutor

class ExecError(RuntimeError):

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class Runner:
    def __init__(self, stepId, taskId, isForce=False, failBreak=False, dataPath=None):
        # 初始化运行上下文
        context = Context.Context(stepId, taskId, isForce, failBreak, dataPath)
        self.context = context
        self.executor = None

        loggingLevel = context.config.get('autoexec', 'logging.level')

        pPaths = os.path.split(os.path.realpath(__file__))
        logFilePath = '{}/logs/{}.log'.format(os.path.realpath(pPaths[0]+'/..'), pPaths[1])
        logHandler = RotatingFileHandler(logFilePath, maxBytes=10*1024*1024, backupCount=5)
        logger = logging.getLogger('')
        logger.setLevel(loggingLevel)
        formatter = logging.Formatter('%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)-8s %(message)s')
        logHandler.setFormatter(formatter)
        logger.addHandler(logHandler)

        # 切换到任务的执行路径
        os.chdir(context.runPath)

        # 获取运行参数和运行节点参数文件
        serverAdapter = context.serverAdapter
        serverAdapter.getParams()
        serverAdapter.getNodes()

        # 加载运行参数文件
        paramFile = open(context.paramsFilePath, 'r')
        self.params = json.loads(paramFile.read())
        paramFile.close()

    def execOperations(self, opsParams, opArgsRefMap, parallelCount):
        self.context.hasLocal = False
        self.context.hasRemote = False

        operations = []
        # 遍历参数文件中定义的操作，逐个初始化，包括参数处理和准备，以及文件参数相关的文件下载

        for operation in opsParams:
            if 'arg' in operation:
                opArgsRefMap[operation['opId']] = operation['arg']
            else:
                opArgsRefMap[operation['opId']] = {}

            op = Operation.Operation(self.context, opArgsRefMap, operation)
            op.parseParam()

            # 如果有本地操作，则在context中进行标记
            if op.opType == 'local':
                self.context.hasLocal = True
            else:
                self.context.hasRemote = True

            operations.append(op)

        executor = TaskExecutor.TaskExecutor(self.context, operations, parallelCount)
        self.executor = executor
        return executor.execute()

    def execute(self):
        params = self.params
        parallelCount = 25
        if 'parallel' in params:
            parallelCount = int(params['parallel'])

        opArgsRefMap = {}

        failCount = 0
        if 'pre' in params:
            self.context.phase = 'pre'
            print("INFO: Begin to execute pre operations...")
            failCount = self.execOperations(params['pre'], opArgsRefMap, parallelCount)
            print("INFO: Execute pre operations finish, failCount:{}".format(failCount))

        if failCount == 0 and 'run' in params:
            self.context.phase = 'run'
            print("INFO: Begin to execute operations...")
            failCount = self.execOperations(params['run'], opArgsRefMap, parallelCount)
            print("INFO: Execute operations finish, failCount:{}".format(failCount))

        if failCount == 0 and 'post' in params:
            self.context.phase = 'post'
            print("INFO: Begin to execute post operations...")
            failCount = self.execOperations(params['post'], opArgsRefMap, parallelCount)
            print("INFO: Execute post operations finish, failCount:{}".format(failCount))

        if failCount == 0:
            print("INFO: ======Execute succeed======")
        else:
            print("INFO: ======Execute failed======")

        return failCount

    def kill(self):
        self.context.goToStop = True
        if self.executor is not None:
            self.executor.kill()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action='store_true', default=False, help="Automation Runner")
    parser.add_argument('--stepid', '-s', default='00', help='Step id for task, default is "00"')
    parser.add_argument('--taskid', '-t', default='00', help='Task id for this execution')
    parser.add_argument('--force', '-f', default=False, action='store_true', help='Force to run all nodes regardless the node status')
    parser.add_argument('--failbreak', '-b', default=False, action='store_true', help='Break the running loop while the node status is failed')
    parser.add_argument('--abort', '-k', default=False, action='store_true', help='abort the job')

    args = parser.parse_args()
    print("INFO: StepId:{}, TaskId:{}, isForce:{}".format(args.stepid, args.taskid, args.force))

    if not args.abort:
        os.environ['AUTOEXEC_TASKID'] = args.taskid
        os.environ['AUTOEXEC_STEPID'] = args.stepid
        runner = Runner(args.stepid, args.taskid, args.force, args.failbreak)

        def handler(signum, frame):
            runner.kill()

        signal.signal(signal.SIGTERM, handler)
        signal.signal(signal.SIGINT, handler)
        signal.signal(signal.SIGHUP, handler)

        sys.exit(runner.execute())
    else:
        loopCount = 0
        hasProcess = True
        while hasProcess:
            hasProcess = False
            with os.scandir('/proc') as it:
                for entry in it:
                    if not entry.name.startswith('.') and entry.is_dir():
                        if re.match('^\d+$', entry.name):
                            pid = entry.name
                            try:
                                f = open(entry.path + '/environ')
                                content = f.read()
                                if re.match('AUTOEXEC_TASKID=' + args.taskid, content) and re.match('AUTOEXEC_STEPID=' + args.stepid, content):
                                    hasProcess = True
                                    if loopCount < 10:
                                        os.kill(pid, signal.SIGTERM)
                                    else:
                                        os.kill(pid, signal.SIGKILL)
                                        break
                            except:
                                pass
            if hasProcess and loopCount < 10:
                time.sleep(1)

            loopCount = loopCount + 1
