#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
 Copyright © 2017 TechSure<http://www.techsure.com.cn/>
"""
import os
import sys
import initenv
import platform
import argparse
import time
import signal
import re
import json
import logging
from logging.handlers import RotatingFileHandler
from shutil import copyfile

import Context
import Operation
import JobExecutor
import NodeStatus


class ExecError(RuntimeError):

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class Runner:
    def __init__(self, jobId, isForce=False, paramsFile=None, nodesFile=None, failBreak=False, devMode=False, dataPath=None):
        # 初始化运行上下文
        context = Context.Context(jobId, isForce, failBreak, devMode, dataPath)
        self.context = context
        self.executor = None
        self.localDefinedParams = False
        self.localDefinedNodes = False

        loggingLevel = context.config.get('autoexec', 'logging.level')

        pPaths = os.path.split(os.path.realpath(__file__))
        homePath = os.path.realpath(pPaths[0]+'/..')
        sys.path.append(homePath + '/plugins/local/bin')
        sys.path.append(homePath + '/plugins/local/lib')
        sys.path.append(homePath + '/plugins/local/tools')

        if 'PERLLIB' in os.environ:
            os.environ['PERLLIB'] = '{}:{}'.format(homePath + '/plugins/local/lib', os.environ['PERLLIB'])
        else:
            os.environ['PERLLIB'] = homePath + '/plugins/local/lib'

        logFilePath = '{}/logs/{}.log'.format(homePath, pPaths[1])
        logHandler = RotatingFileHandler(logFilePath, maxBytes=10*1024*1024, backupCount=5)
        logger = logging.getLogger('')
        logger.setLevel(loggingLevel)
        formatter = logging.Formatter('%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)-8s %(message)s')
        logHandler.setFormatter(formatter)
        logger.addHandler(logHandler)

        # 切换到任务的执行路径
        os.chdir(context.runPath)

        # 获取运行参数和运行节点参数文件，如果命令行提供的文件路径则不到服务端进行下载
        serverAdapter = context.serverAdapter
        if paramsFile is None or paramsFile == '':
            serverAdapter.getParams()
        else:
            self.localDefinedParams = True
            # 如果指定的参数文件存在，而且目录不是params文件最终的存放目录，则拷贝到最终的存放目录
            dstPath = '{}/params.json'.format(self.context.runPath)
            print(dstPath)
            if (os.path.exists(paramsFile) and dstPath != os.path.realpath(paramsFile)):
                copyfile(paramsFile, dstPath)

        # 加载运行参数文件
        paramFile = open(context.paramsFilePath, 'r')
        self.params = json.loads(paramFile.read())

        if 'jobId' in self.params:
            jobId = self.params['jobId']
            self.context.jobId = jobId
        if 'tenant' in self.params:
            self.context.tenant = self.params['tenant']

        if 'arg' in self.params:
            self.context.arg = self.params['arg']

        if 'passThroughEnv' in self.params:
            self.context.passThroughENv = self.params['passThroughEnv']

        paramFile.close()

        if 'runNode' in self.params:
            # 如果在参数文件中声明了runNode，则以此作为运行目标
            dstPath = '{}/nodes.json'.format(self.context.runPath)
            nodesFile = open(dstPath, 'w')
            for node in self.params['runNode']:
                nodesFile.write(json.dump(node))
            nodesFile.close()
        elif nodesFile is None or nodesFile == '':
            # 如果命令行没有指定nodesfile参数，则通过作业id到服务端下载节点参数文件
            serverAdapter.getNodes()
        else:
            # 如果命令行参数指定了nodesfile参数，则以此文件做为运行目标节点列表
            self.localDefinedNodes = True
            # 如果指定的参数文件存在，而且目录不是params文件最终的存放目录，则拷贝到最终的存放目录
            dstPath = '{}/nodes.json'.format(self.context.runPath)
            if (os.path.exists(nodesFile) and dstPath != os.path.realpath(nodesFile)):
                copyfile(nodesFile, dstPath)

    def execOperations(self, opsParams, opArgsRefMap, parallelCount):
        self.context.hasLocal = False
        self.context.hasRemote = False
        self.context.initDB(parallelCount)

        operations = []
        # 遍历参数文件中定义的操作，逐个初始化，包括参数处理和准备，以及文件参数相关的文件下载

        for operation in opsParams:
            if 'arg' in operation:
                opArgsRefMap[operation['opId']] = operation['arg']
            else:
                opArgsRefMap[operation['opId']] = {}

            op = Operation.Operation(self.context, opArgsRefMap, operation)
            # op.parseParam()

            # 如果有本地操作，则在context中进行标记
            if op.opType == 'local':
                self.context.hasLocal = True
            else:
                self.context.hasRemote = True

            operations.append(op)

        executor = JobExecutor.JobExecutor(self.context, operations, parallelCount)
        self.executor = executor
        return executor.execute()

    def execute(self):
        params = self.params
        parallelCount = 25
        if 'parallel' in params:
            parallelCount = int(params['parallel'])
            self.context.parallelCount = parallelCount

        opArgsRefMap = {}

        failCount = 0
        if 'runFlow' in params:
            for phase in params['runFlow']:
                phaseName = None
                phaseNames = list(phase.keys())
                if len(phaseNames) > 0:
                    phaseName = phaseNames[0]

                if phaseName is not None:
                    if failCount == 0 or self.context.failBreak == False:
                        serverAdapter = self.context.serverAdapter
                        if not self.localDefinedNodes:
                            serverAdapter.getNodes(phaseName)

                        self.context.setPhase(phaseName)
                        self.context.resetCounter()
                        print("INFO: Begin to execute phase:{} operations...".format(phaseName))
                        self.context.serverAdapter.pushPhaseStatus(phaseName, NodeStatus.running)
                        failCount = self.execOperations(phase[phaseName], opArgsRefMap, parallelCount)
                        if failCount == 0:
                            self.context.serverAdapter.pushPhaseStatus(phaseName, NodeStatus.succeed)
                        else:
                            self.context.serverAdapter.pushPhaseStatus(phaseName, NodeStatus.failed)
                        print("INFO: Execute phase:{} operations finish, suceessCount:{}, failCount:{}, skipCount:{}".format(phaseName, self.context.sucNodeCount, self.context.failNodeCount, self.context.skipNodeCount))
                        print("--------------------------------\n")

        # 如果全局存在失败的节点，或者failBreak是False，则通知console调度器调度下一个phase
        if (failCount == 0 or self.context.hasFailNodeInGlobal == False) or self.context.failBreak == False:
            # 所有跑完了，通知后台做fireNext的处理
            self.context.serverAdapter.pushPhaseStatus(None, '', 1)

        if failCount == 0:
            print("INFO: ======Execute succeed======")
        else:
            print("INFO: ======Execute failed======")

        return failCount

    def kill(self):
        self.context.goToStop = True
        if self.executor is not None:
            self.executor.kill()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action='store_true', default=False, help="Automation Runner")
    parser.add_argument('--jobid', '-j', default='0', help='Job id for this execution')
    parser.add_argument('--paramsfile', '-p', default='', help='Params file path for this execution')
    parser.add_argument('--nodesfile', '-n', default='', help='Nodes file path for this execution')
    parser.add_argument('--force', '-f', default=False, action='store_true', help='Force to run all nodes regardless the node status')
    parser.add_argument('--failbreak', '-b', default=False, action='store_true', help='Break the running loop while the node status is failed')
    parser.add_argument('--abort', '-k', default=False, action='store_true', help='abort the job')
    parser.add_argument('--devmode', '-d', default=False, action='store_true', help='develope test in command line')

    args = parser.parse_args()
    print("INFO: JobId:{}, isForce:{}, paramsFile:{}, nodesFile:{}".format(args.jobid, args.force, args.paramsfile, args.nodesfile))

    if not args.abort:
        os.environ['AUTOEXEC_JOBID'] = args.jobid
        runner = Runner(args.jobid, args.force, args.paramsfile, args.nodesfile, args.failbreak, args.devmode)

        def handler(signum, frame):
            runner.kill()

        signal.signal(signal.SIGTERM, handler)
        signal.signal(signal.SIGINT, handler)

        if platform.system() != 'Windows':
            signal.signal(signal.SIGHUP, handler)

        sys.exit(runner.execute())
    else:
        loopCount = 0
        hasProcess = True
        while hasProcess:
            hasProcess = False
            with os.scandir('/proc') as it:
                for entry in it:
                    if not entry.name.startswith('.') and entry.is_dir():
                        if re.match('^\d+$', entry.name):
                            pid = entry.name
                            try:
                                f = open(entry.path + '/environ')
                                content = f.read()
                                if re.match('AUTOEXEC_JOBID=' + args.jobid, content):
                                    hasProcess = True
                                    if loopCount < 10:
                                        os.kill(pid, signal.SIGTERM)
                                    else:
                                        os.kill(pid, signal.SIGKILL)
                                        break
                            except:
                                pass
            if hasProcess and loopCount < 10:
                time.sleep(1)

            loopCount = loopCount + 1
