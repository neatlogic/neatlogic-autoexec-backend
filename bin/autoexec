#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
 Copyright © 2017 TechSure<http://www.techsure.com.cn/>
"""
import os
import sys
import io
import shutil
import threading
import initenv
import platform
import argparse
import time
import signal
from shutil import copyfile
import re
import json
import glob
import logging
from logging.handlers import RotatingFileHandler

import Utils
import VContext
import Context
import ServerAdapter
import Operation
import PhaseExecutor
import NodeStatus
import OutputStore


class ConsoleLog(io.TextIOWrapper):
    def write(self, text, encoding=sys.getdefaultencoding()):
        if isinstance(text, bytes):
            text = text.decode(encoding)

        if text == "\n":
            return

        isTTY = sys.__stdout__.isatty()

        for line in text.splitlines(True):
            if isTTY:
                sys.__stdout__.write(line)

            super().write(Utils.getTimeStr() + line)
            super().flush()


class Runner:
    def __init__(self, context, nodesFile=None):
        # 初始化运行上下文
        pPaths = os.path.split(os.path.realpath(__file__))
        homePath = os.path.realpath(pPaths[0]+'/..')

        self.context = context
        self.localDefinedParams = False
        self.localDefinedNodes = False

        # 切换到任务的执行路径
        os.chdir(context.runPath)

        if 'runNode' in context.params:
            # 如果在参数文件中声明了runNode，则以此作为运行目标，用于工具测试的执行，所以不支持phase内部定义runNode
            self.localDefinedNodes = True
            dstPath = '{}/nodes.json'.format(self.context.runPath)
            nodesFile = open(dstPath, 'w')
            for node in context.params['runNode']:
                nodesFile.write(json.dumps(node))
            nodesFile.close()
        elif nodesFile is None or nodesFile == '':
            # 如果命令行没有指定nodesfile参数，则通过作业id到服务端下载节点参数文件
            context.serverAdapter.getNodes()
        else:
            # 如果命令行参数指定了nodesfile参数，则以此文件做为运行目标节点列表
            self.localDefinedNodes = True
            # 如果指定的参数文件存在，而且目录不是params文件最终的存放目录，则拷贝到最终的存放目录
            dstPath = '{}/nodes.json'.format(self.context.runPath)
            if os.path.exists(nodesFile):
                if dstPath != os.path.realpath(nodesFile):
                    copyfile(nodesFile, dstPath)
            else:
                print("ERROR: Nodes file directory:{} not exists.\n".format(nodesFile))

    def execOperations(self, phaseName, opsParams, opArgsRefMap, parallelCount):
        phaseStatus = self.context.phases[phaseName]
        phaseStatus.hasLocal = False
        phaseStatus.hasRemote = False

        self.context.initDB(parallelCount)
        self.context.loadEnv()

        operations = []
        # 遍历参数文件中定义的操作，逐个初始化，包括参数处理和准备，以及文件参数相关的文件下载

        for operation in opsParams:
            if 'arg' in operation:
                opArgsRefMap[operation['opId']] = operation['arg']
            else:
                opArgsRefMap[operation['opId']] = {}

            op = Operation.Operation(self.context, opArgsRefMap, operation)
            # op.parseParam()

            # 如果有本地操作，则在context中进行标记
            if op.opType == 'local':
                phaseStatus.hasLocal = True
            else:
                phaseStatus.hasRemote = True

            operations.append(op)

        executor = PhaseExecutor.PhaseExecutor(self.context, phaseName, operations, parallelCount)
        phaseStatus.executor = executor
        return executor.execute()

    def execPhase(self, phaseName, phaseConfig, parallelCount, opArgsRefMap):
        self.context.addPhase(phaseName)

        serverAdapter = self.context.serverAdapter
        if not self.localDefinedNodes:
            serverAdapter.getNodes(phaseName)

        phaseStatus = self.context.phases[phaseName]
        print("INFO: Begin to execute phase:{} operations...\n".format(phaseName))
        self.context.serverAdapter.pushPhaseStatus(phaseName, phaseStatus, NodeStatus.running)
        failCount = self.execOperations(phaseName, phaseConfig, opArgsRefMap, parallelCount)
        if failCount == 0:
            if phaseStatus.ignoreFailNodeCount > 0:
                self.context.serverAdapter.pushPhaseStatus(phaseName, phaseStatus, NodeStatus.completed)
            else:
                self.context.serverAdapter.pushPhaseStatus(phaseName, phaseStatus, NodeStatus.succeed)
        else:
            self.context.hasFailNodeInGlobal = True
            failStatus = NodeStatus.failed
            if phaseStatus.isAborting:
                failStatus = NodeStatus.aborted
            elif phaseStatus.isPausing:
                failStatus = NodeStatus.paused
            self.context.serverAdapter.pushPhaseStatus(phaseName, phaseStatus, failStatus)

        print("INFO: Execute phase:{} finish, suceessCount:{}, failCount:{}, ignoreCount:{}, skipCount:{}\n".format(phaseName, phaseStatus.sucNodeCount, phaseStatus.failNodeCount, phaseStatus.ignoreFailNodeCount, phaseStatus.skipNodeCount))
        print("--------------------------------------------------------------\n\n")

    def execute(self):
        params = self.context.params
        parallelCount = 25
        if 'parallel' in params:
            parallelCount = int(params['parallel'])
            self.context.parallelCount = parallelCount

        opArgsRefMap = {}
        lastPhase = None
        if 'runFlow' in params:
            for phaseGroup in params['runFlow']:
                if self.context.goToStop == True:
                    break

                # runFlow是一个数组，每个元素是一个phaseGroup
                threads = []
                # 每个group有多个phase，使用线程并发执行
                for phaseName, phaseConfig in phaseGroup.items():
                    if self.context.goToStop == True:
                        break

                    lastPhase = phaseName
                    if not self.context.hasFailNodeInGlobal:
                        thread = threading.Thread(target=self.execPhase, args=(phaseName, phaseConfig, parallelCount, opArgsRefMap))
                        thread.start()
                        thread.name = 'PhaseExecutor-' + phaseName
                        threads.append(thread)

                for thread in threads:
                    thread.join()

        status = 0
        if self.context.hasFailNodeInGlobal:
            status = 1
        elif not self.context.goToStop:
            # 所有跑完了，如果全局不存在失败的节点，且nofirenext则通知后台调度器调度下一个phase,通知后台做fireNext的处理
            if not args.nofirenext:
                self.context.serverAdapter.fireNextPhase(lastPhase)

        return status

    def kill(self):
        self.context.goToStop = True
        # 找出所有的正在之心的phase关联的PhaseExecutor执行kill
        for phaseStatus in self.context.phases.values():
            phaseStatus.isAborting = 1
            if phaseStatus.executor is not None:
                phaseStatus.executor.kill()
        self.context.serverAdapter.jobKilled()

    def pause(self):
        self.context.goToStop = True
        # 找出所有的正在之心的phase关联的PhaseExecutor执行pause
        for phaseStatus in self.context.phases.values():
            phaseStatus.isPausing = 1
            if phaseStatus.executor is not None:
                phaseStatus.executor.pause()
        self.context.serverAdapter.jobPaused()


def _getLogSubPath(jobId):
    jobIdStr = str(jobId)
    jobIdLen = len(jobIdStr)
    subPath = [jobIdStr[i:i+3] for i in range(0, jobIdLen, 3)]
    return '/'.join(subPath)


def registerTools(serverAdapter, pluginsPath, opType):
    os.chdir(pluginsPath + '/' + opType)
    with os.scandir() as iterator:
        for entry in iterator:
            if entry.is_dir():
                for descPath in glob.glob(entry.name + '/' + '*.json'):
                    toolSubName = os.path.basename(descPath)[:-5]
                    opName = entry.name + '/' + toolSubName
                    if toolSubName.startswith(entry.name) or os.path.isfile(opName):
                        print("INFO: Begin to register tool:{} {}...\n".format(opType, opName))
                        descFile = open(descPath, 'r')
                        pluginObj = json.loads(descFile.read())
                        pluginObj['opName'] = opName
                        # 后台的配置可能会使用local、localremote、remote的类型标记，转换为后台使用的类别名称runner、runner_target、target
                        if opType == 'local':
                            if 'opType' in pluginObj:
                                if pluginObj['opType'] == 'localremote':
                                    pluginObj['opType'] = 'runner_target'
                                elif pluginObj['opType'] == 'local':
                                    pluginObj['opType'] = 'runner'
                            else:
                                pluginObj['opType'] = 'runner'

                        if opType == 'remote':
                            pluginObj['opType'] = 'target'

                        try:
                            retObj = serverAdapter.registerTool(pluginObj)
                            if 'Status' in retObj and retObj['Status'] == 'OK':
                                print("INFO: Register tool:{} {} success.\n".format(opType, opName))
                        except Exception as ex:
                            print("ERROR: Register tool:{} {} failed, {}\n".format(opType, opName, ex))


def findJobProcess(jobId):
    autoexecPid = 0
    with os.scandir('/proc') as it:
        for entry in it:
            if not entry.name.startswith('.') and entry.is_dir():
                if re.match('^\d+$', entry.name):
                    pid = entry.name
                    try:
                        cf = open(entry.path + '/comm')
                        comm = cf.read()
                        comm = comm.strip()
                        if comm == 'autoexec':
                            f = open(entry.path + '/cmdline')
                            content = f.read()
                            if content.index(jobId) > 0:
                                autoexecPid = int(pid)
                                break
                    except:
                        pass
    return autoexecPid


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action='store_true', default=False, help="Automation Runner")
    parser.add_argument('--jobid', '-j', default='0', help='Job id for this execution')
    parser.add_argument('--execuser', '-u', default='anonymous',  help='Operator')
    parser.add_argument('--paramsfile', '-p', default='', help='Params file path for this execution')
    parser.add_argument('--nodesfile', '-n', default='', help='Nodes file path for this execution')
    parser.add_argument('--force', '-f', default=False, action='store_true', help='Force to run all nodes regardless the node status')
    parser.add_argument('--firstfire', '-i', default=False, action='store_true', help='the first phase fired, create new log file')
    parser.add_argument('--abort', '-k', default=False, action='store_true', help='abort the job')
    parser.add_argument('--pause', '-s', default=False, action='store_true', help='puase the job')
    parser.add_argument('--register', '-r', default='', help='register all tools to tenent')
    parser.add_argument('--cleanstatus', '-c', default=False, action='store_true', help='clean all stats of job')
    parser.add_argument('--devmode', '-d', default=False, action='store_true', help='develope test in command line')
    parser.add_argument('--nofirenext', '-e', default=False, action='store_true', help='do not fire next job phase')

    os.environ['TERM'] = 'dumb'
    args = parser.parse_args()
    os.environ['AUTOEXEC_PID'] = str(os.getpid())
    os.environ['AUTOEXEC_USER'] = args.execuser

    binPaths = os.path.split(os.path.realpath(__file__))
    homePath = os.path.realpath(binPaths[0]+'/..')
    progName = binPaths[1]

    if args.cleanstatus:
        vContext = VContext.VContext(args.jobid)
        vContext.initDB(1)

        outputStore = OutputStore.OutputStore(vContext, None, None)
        outputStore.removeJobStatus()

        statusPath = '{}/status'.format(vContext.runPath)
        if os.path.exists(statusPath):
            shutil.rmtree(statusPath)

    elif args.register:
        pluginsPath = homePath + '/plugins'

        # 因为serverAdapter是从context中获取tenant，所以需要构造虚拟的context
        vContext = VContext.VContext(0)
        vContext.tenant = args.register
        serverAdapter = ServerAdapter.ServerAdapter(vContext)

        registerTools(serverAdapter, pluginsPath, 'local')
        registerTools(serverAdapter, pluginsPath, 'remote')
    elif args.pause:
        ret = 0
        print("INFO: try to pause job:{}\n".format(args.jobid))
        autoexecIsPaused = False
        autoexecPid = findJobProcess(args.jobid)

        if autoexecPid != 0:
            try:
                print("INFO: Try to pause process {}...\n".format(autoexecPid))
                os.kill(autoexecPid, signal.SIGUSR1)

                for i in range(1800):
                    os.kill(autoexecPid, 0)
                    time.sleep(3)
                    os.kill(autoexecPid, signal.SIGUSR1)
            except:
                autoexecIsPaused = True
                # TODO: call back job paused
                print("INFO: Process {} puased.\n".format(autoexecPid))

            if not autoexecIsPaused:
                ret = 1
                print("WARN: Kill process {} failed.\n".format(autoexecPid))
        else:
            ret = 2
            print("INFO: Can not find job {} process.\n".format(args.jobid))
        sys.exit(ret)
    elif args.abort:
        ret = 0
        print("INFO: try to kill job:{}\n".format(args.jobid))
        autoexecIsKilled = False
        autoexecPid = findJobProcess(args.jobid)

        if autoexecPid != 0:
            try:
                print("INFO: Try to stop process {}...\n".format(autoexecPid))
                for i in range(10):
                    os.kill(autoexecPid, signal.SIGTERM)
                    time.sleep(1)

                os.kill(autoexecPid, signal.SIGKILL)
                time.sleep(1)
                os.kill(autoexecPid, 0)
            except:
                autoexecIsKilled = True
                # TODO: call back job killed
                print("INFO: Process {} killed.\n".format(autoexecPid))

            if not autoexecIsKilled:
                ret = 1
                print("WARN: Kill process {} failed.\n".format(autoexecPid))
        else:
            ret = 2
            print("INFO: Can not find job {} process.\n".format(args.jobid))
        sys.exit(ret)
    else:
        # 初始化运行context
        dataPath = homePath + '/data'
        context = Context.Context(args.jobid, paramsFile=args.paramsfile, isForce=args.force, devMode=args.devmode, dataPath=dataPath)
        os.environ['AUTOEXEC_JOBID'] = context.jobId
        os.environ['AUTOEXEC_WORK_PATH'] = context.runPath

        # 初始化console日志文件
        logDir = context.runPath + '/log'
        consoleLogPath = logDir + '/console.txt'

        # console输出重定向到console log文件
        consoleLogFile = open(consoleLogPath, 'a').detach()
        sys.stdout = ConsoleLog(consoleLogFile)
        sys.stderr = ConsoleLog(consoleLogFile)

        if args.firstfire:
            # console输出重定向到console log文件
            if os.path.exists(consoleLogPath):
                os.unlink(consoleLogPath)

            consoleLogFile = open(consoleLogPath, 'w').detach()
            sys.stdout = ConsoleLog(consoleLogFile)
            sys.stderr = ConsoleLog(consoleLogFile)

            consoleHisLogDir = logDir + '/console.hislog'
            if not os.path.isdir(consoleHisLogDir):
                os.mkdir(consoleHisLogDir)
            consoleHisLogPath = '{}/{}.{}.txt'.format(consoleHisLogDir, time.strftime('%Y%m%d-%H%M%S'), args.execuser)
            os.link(consoleLogPath, consoleHisLogPath)
        else:
            # console输出重定向到console log文件
            consoleLogFile = open(consoleLogPath, 'a').detach()
            sys.stdout = ConsoleLog(consoleLogFile)
            sys.stderr = ConsoleLog(consoleLogFile)

        # 初始化全局Logger
        loggingLevel = context.config.get(progName, 'logging.level')

        logFilePath = '{}/logs/{}.log'.format(homePath, progName)
        logHandler = RotatingFileHandler(logFilePath, maxBytes=10*1024*1024, backupCount=5)
        logger = logging.getLogger('')
        logger.setLevel(loggingLevel)
        formatter = logging.Formatter('%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)-8s %(message)s')
        logHandler.setFormatter(formatter)
        logger.addHandler(logHandler)

        # 开始运行作业
        print("INFO: JobId:{} start...\n".format(args.jobid))
        runner = Runner(context, nodesFile=args.nodesfile)

        # 信号处理函数，pause runner
        def pauseHandler(signum, frame):
            runner.pause()

        # 信号处理函数，kill runner
        def killHandler(signum, frame):
            runner.kill()

        # 注册TERM、INT的信号，当kill是响应信号进行退出处理，kill是另外独立的autoexec进程，仅仅发送一个信号
        signal.signal(signal.SIGTERM, killHandler)
        signal.signal(signal.SIGINT, killHandler)

        if platform.system() != 'Windows':
            signal.signal(signal.SIGHUP, killHandler)
            signal.signal(signal.SIGUSR1, pauseHandler)

        sys.exit(runner.execute())
